http://cython.readthedocs.io/en/latest/src/quickstart/index.html
http://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html
http://cython.readthedocs.io/en/latest/src/userguide/index.html#indices-and-tables


last on:
http://cython.readthedocs.io/en/latest/src/tutorial/clibraries.html



https://docs.python.org/2/distutils/index.html

#------------------------------
# contents
#------------------------------
1::ctypes
  1.1::guide
    1.1.1::loading libraries
    1.1.2::accessing functions
    1.1.3::calling functions
    1.1.4::datatypes
    1.1.5::arg/ret types
    1.1.6::pointers or references
    1.1.7::structs/unions
    1.1.8::arrays
    1.1.9::pointers
    1.1.10::conversion
    1.1.11::forward declarations
    1.1.12::callables/function pointers
    1.1.13::library variables
    1.1.14::surprises
    1.1.15::variable size data structures
  1.2::reference
    1.2.1::finding shared libraries
    1.2.2::foreign functions
    1.2.3::prototypes
    1.2.4::utility functions
    1.2.5::data types
2::cython
  2.1::setup
    2.1.1::installation
    2.1.2::building
    2.1.3::static typing (c type variables)
    2.1.4::c type functions
    2.1.5::pyximport
    2.1.6::c functions
      2.1.6.1::include C libraries
      2.1.6.2::external declarations
      2.1.6.3::naming parameters
      2.1.6.4::libraries and wrappers
    2.1.7::memory management

#------------------------------
#1::ctypes
#------------------------------
foreign-language libraries (.dll, .so, etc)
compile c using gcc -o [name].so -shared -fPIC [files, libs, dirs, etc]
NOTE: -l might expect something of form lib[namehere].[dll, a, so, etc]
      use -l:actualfilename


______________________________
#1.1.1::loading libraries
  library classes:
    [all]   [windows only...???]
    cdll,   windll, oledll
  cdll: cdecl convention
  windll, oledll: stdcall convention
  ex:
    import ctypes
    ctypes.windll.kernel32
    ctypes.cdll.msvcrt
  windows adds .dll automatically??
  linux requires the extension too:
    use LoadLibrary() or constructor
  ex2:
    cdll.LoadLibrary("full-path-to-library-file")
    CDLL("full-path-to-library-file")

______________________________
#1.1.2::accessing functions
functions are attributes
win32: use ANSI and UNICODE versions of functions (end in A or W)
       (usually macro auto-picks, but with this module, must choose one yourself)
use getattr(lib, 'funcname') for function names that are messy
functions by ordinals:
lib[i]

______________________________
#1.1.3::calling functions
just call
ctypes tries protect against bad calls (need to look at headers or documentation)

None, ints, longs, bytestrings, unicode strings can be passed directly as params

None->NULL
bytestring, unicode->char* or wchar_t*
ints, longs-> int
ex:
  printf = libc.printf
  printf("Hello, %s, %d, %f\n", "World!", 5, 4.2)
NOTES:
  example raises an error because only auto-conversions are
  bytestring, int, and None
  must use ctypes.c_float(4.2) instead of just 4.2


______________________________
#1.1.4::datatypes
ctypes type     C type                  python type
c_bool          _Bool                   truthy object
c_char          char                    1-char string
c_wchar         wchar_t                 1-char unicode string
c_byte          char                    int/long
c_ubyte         unsigned char           int/long
c_short         short                   int/long
c_ushort        unsigned short          int/long
c_int           int                     int/long
c_uint          unsigned int            int/long
c_long          long                    int/long
c_ulong         unsigned long           int/long
c_longlong      __int64 or long long    int/long
c_ulonglong     unsigned __int64 or     int/long
                unsigned long long      
c_float         float                   float
c_double        double                  float
c_longdouble    long double             float
c_char_p        char* (NULL termed)     string or None
c_wchar_p       wchar_t* (NULL termed)  unicode or None
c_void_p        void*                   int/long or None

types: created with optional initialier
       mutable (var.value)
  NOTE1:
    new value to memory pointer type changes pointer
  NOTE2:
    python strings are IMMUTABLE
    need mutable strings, use ctypes.create_string_buffer()
                              ctypes.create_unicode_buffer()
    ex:
      p = create_string_buffer(3)
      print sizeof(p), repr(p.raw)
      p = create_string_buffer("Hello")
      print sizeof(p), repr(p.raw)
      print repr(p.value)
      p = create_string_buffer("Hello", 10)
      print sizeof(p), repr(p.raw)
      print repr(p.value)
      p.value = "Hi"      
      print sizeof(p), repr(p.raw)
      print repr(p.value)


NOTE:
  printf prints to std (not sys.std)
  
custom types require:
  _as_parameter_ (value to represent your object)
      or
  _as_parameter_ = property([fget, fset, fdel, doc])
  
______________________________
#1.1.5::arg/ret types
lib.function.argtypes 
lib.function.restype

tries to protect against invalid types and attemps auto-conversion
classes must have from_param() to be used in argtypes sequence
  from_param: receives object, should typecheck
              returns any valid object (ctypes, int, str, none, or _as_parameter_ object)

all return-types assumed to be ints
ex:
  strchr = ctypes.cdll.libc.strchr
  strchr("abcdef", ord("d"))
  strchr.restype = c_char_p
  strchr("abcdef", ord("d"))
  strchr.argtypes = [ctypes.c_char_p, ctypes.c_char]
  strchr("abcdef", "d")
  
restype can also be a callable function (will be called with returned integer)

______________________________
#1.1.6::pointers or references
ctypes.byref()
ctypes.pointer()

pointer: constructs a pointer (more work)
byref  : idk... but doc says does less work


______________________________
#1.1.7::structs/unions
must be Structure and Union classes
subclass must have _fields_ attr
_fields_: 2-tuple list of attrname, attrtype
  attrtype: a ctypes type, or structure, union, array, pointer
ex:
  class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_int),
                ("y", ctypes.c_int)]
  point = POINT(10, 20)
  print point.x, point.y
  point = POINT(y=5)
  print point.x, point.y
  POINT(1,2,3)
  (error)
  class RECT(ctypes.Structure):
    _fields_ = [("upperleft", POINT),
                ("lowerright", POINT)]

  r = RECT(POINT(1,2), POINT(3,4))
  r = RECT((1,2), (3,4))
  RECT.upperleft
  POINT.x

alignment/bytes:
  aligned as C
  use _pack_ to offset
    _pack_ = int > 0
  use ctypes.BigEndianStructure, 
             LittleEndianStructure, 
             BigEndianUnion, 
             LittleEndianUnion
bit fields (for ints only)
bit width as 3rd arg to int field


______________________________
#1.1.8::arrays
multiply datatype by int > 0

ex:
  class MyStruct(ctypes.Structure):
    _fields_ = [("a", c_int),
                ("b", c_float),
                ("parray", POINT * 4)]

______________________________
#1.1.9::pointer
call pointer() on ctypes type
pointer.contents->original object
whenever retrieve obj constructs a new one
p = ctypes.pointer(thing)
thing is p = False
thing.contents is p = False

can assign to contents or use indexing

use POINTER() to explicitly create a pointer TYPE
ex:
  intpointer = ctypes.POINTER(ctypes.c_int)
  point_to_5 = intpointer(5)

______________________________
#1.1.10::conversion
pointers and arrays are compatible like c-type arrays   
for passing pointers, can use object of same type,
  ctypes calls byref() automatically

can assign None to pointer to make it NULL
ctypes.cast(pointerobjthing, desiredtype)  

______________________________
#1.1.11::forward declarations
ex:
  class Link(ctypes.Structure):
    _fields_ = [("next", ctypes.POINTER(Link)),
                ("data", ctypes.c_int)]


______________________________
#1.1.12::callables/function pointers    
create class for callback
calling convention, return type, #/types of args
use CFUNCTYPE factory function for cdecl
use WINFUNCTYPE for stdcall

ex:
  CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
  def py_cmp_func(a, b):
      return a[0] - b[0]

  qsort = ctypes.cdll.libc.qsort
  qsort.restype = None

  callback = CMPFUNC(py_cmp_func)

NOTE: if references to callbacks are not kept, they may be garbage collected = crash

______________________________
#1.1.13::library variables
ex:
  opt_flag = c_int.in_dll(library, "variable_name")


______________________________
#1.1.14::surprises
swapping members of objects: uses memory
ex:
  p1 = POINT(1,2)
  p2 = POINT(3,4)
  rect = RECT(p1, p2)
  rect.a, rect.b = rect.b, rect.a

b copied into a (mutated), then a copied back to b

ex2:
  s = ctypes.c_char_p()
  s.value = "abc def ghi"
  s.value
  s.value is s.value
(using .value returns a new object every time)

______________________________
#1.1.15::variable size data structures
use resize() kind of like malloc

ex:
  short_array = (c_short * 4)()
  print ctypes.sizeof(short_array)
  ctypes.resize(short_array, 4)
  #(>>>error occurs<<<)
  ctypes.resize(short_array, 32)
  short_array[:]
  short_array[3]
  short_array[4]
  #(>>>error occurs<<<)
  new_short_array = (ctypes.c_short*16).from_address(ctypes.addressof(short_array))

##############################
#1.2::reference
##############################
#1.2.1::finding shared libraries
import ctypes
import ctypes.util
ctypes.util.find_library(name)
  name has no prefix or suffix
might be better to hard-code library name instead of using find_library

instantiation:
  ctypes.CDLL(path)
  ctypes.WinDLL(path)
  ctypes.OleDLL(path)
  NOTE:
    above: releases GIL before call

  ctypes.PyDLL(path)
  NOTE:
    above: does not release GIL (only useful for calling Python C api functions directly)

LoadLibrary:
  ctypes.cdll.LoadLibrary(path)
  ctypes.oledll.LoadLibrary(path)
  ctypes.windll.LoadLibrary(path)
  ctypes.pythonapi
______________________________
#1.2.2::foreign functions
  by default: return int, accept any number of arguments
  ctypes._FuncPtr
    restype:    return type, None for void, ctypes.c_type or related (structure etc)
    argtypes:   list of argument types (ctypes, structs etc)
    errcheck:   callable for error checking on the return value
                signature: callable(result, func, arguments)

______________________________
#1.2.3::prototypes
ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
*above releases the GIL*

ctypes.PYFUNCTYPE(restype, *argtypes)
*above doesn't release GIL*

instantiation:
  prototype(address)
    (for the foreign types)
  prototype(callable)
    (for pytype)
  prototype(func_spec, [paramflags])
    func_spec: tuple: (name/ordinal, library)
  prototype(vtbl_index, name[,paramflags, iid]):
    foreign func call COM method
    vtbl_index: index into virtual function table
    name: COM method
    iid: pointer to interface identifier

  paramflags:
    list of same length as argtypes
    each entry : a tuple
      each tuple:
        index 0: 1|2|4: input|output|input defaults 0
        index 1: param name as string
        index 2: default value for parameter
    
ex:
  from ctypes import c_int, WINFUNCTYPE, windll
  from ctypes.wintypes import HWND, LPCSTR, UINT
  prototype = WINFUNCTYPE(c_int, HWND, LPCSTR, LPCSTR, UINT)
  paramflags = (1, "hwnd", 0), (1, "text", "Hi"), (1, "caption", None), (1, "flags", 0)
  MessageBox = prototype(("MessageBoxA", windll.user32), paramflags)
  MessageBox()
  MessageBox(text = "Spam, spam spam")
  MessageBox(flags = 2, text = "foo bar")

______________________________
#1.2.4::utility functions
  ctypes:
    addressof(obj)
    alignment(obj_or_type)
    byref(obj, [offset])
    cast(obj, type)
    create_string_buffer(init_or_size, [size])
    create_unicode_buffer(init_or_size, [size])
    DllCanUnloadNow()
      windows only, COM servers,
    DllGetClassObject()
      windows only, COM servers, 
    FormatError([code])
      windows only
    GetLastError()
      windows only
    get_errno()
      ctypes-private copy
    get_last_error()
      windows only, gets ctypes-private copy
    memmove(dst, src, count)
      like strncpy
    memset(dst, c, count)
      sets vals to c
    POINTER(type)
      returns ctypes pointer class
    pointer(obj)
      creates a pointer
    resize(obj, size)
    set_conversion_mode(encoding, errors)
      sets rules ctypes objs use when converting 8-bit strings and unicode strings
        encoding: string specifying encoding like utf-8, mbcs, etc
        errors:   string specifying error handling ("strict", "replace", "ignore"
      empty args returns 2-tuple:
        (encoding, errors)
    set_errno(value)
    set_last_error(value)
      windows only
    sizeof(obj or type)
    string_at(address, [size])
    WinError(code=None, descr=None)
      windows only
    wstring_at(address, [size])
      wide character string at address length size
  ctypes.util
    find_library(name)
    find_msvcrt()
______________________________
#1.2.5::data types
  ______________________________
  _CData
    base class of ctypes.c_*
    from_buffer(source, [offset])
      ctypes instance from the buffer
      must support writeable buffer interface
    from_buffer_copy(source, [offset])
      copy buffer from source (must be readable)
    from_address(address)
      use memory at address
    from_param(obj)
      adapts obj to ctypes type
      called when argtypes is set
    in_dll(library, name)
      gets library var
    _b_base_
      for shared memory-read-only member
    _b_needsfree_
      read-only, true when ctypes data instance has allocated memory block itself
    _objects
      None or dict of python objects that must be alive
      (only for looking, do not modify or death)
  ______________________________
  _SimpleCData
    value
      value of instance
      access returns a new object
  ______________________________
  Fundamental types:
    always converted to python types when specified as _restype_ or accessed from struct
    
    c_byte
    c_char
    c_char_p
    c_double
    c_longdouble
    c_float
    c_int
    c_int8
    c_int16
    c_int32
    c_int64
    c_long
    c_longlong
    c_short
    c_size_t
    c_ssize_t
    c_ubyte
    c_uint
    c_uint8
    c_uint16
    c_uint32
    c_uint64
    c_ulong
    c_ulonglong
    c_ushort
    c_void_p
    c_wchar
    c_wchar_p
    c_bool
    HRESULT
      Windows only
    py_object
      C PyObject* datatype
    ctypes.wintypes
      HWND
      WPARAM
      DWORD
      MSG
      RECT
  ______________________________
  Structured Data Types
    Union(*args, **kw)
    BigEndianStructure(*args, **kw)
    LittleEndianStructure(*args, **kw)
    Structure(*args, **kw)
    NOTE:
      Structure and Union should be subclassed
      must define _fields_ variable
    _fields_:
      list of 2 or 3-tuples
        name, type, [bit-width (for ints only)
    _pack_:
      overrides allignment
    _anonymous_:
      names unnamed fields
      used for fields of non-fundamental types
      ex:
        class Identity(ctypes.Structure):
          _fields_ = [('name', ctypes.c_char_p),
                      ('age',  ctypes.c_int)]
        class Human(ctypes.Structure):
          _anonymous_ = ("u",)
          _fields_ = [('id', Identity)]
        i = Identity('jason', 25)
        h = Human(i)
        h.name
        h.age
        h.id.name
        h.d.age
      all work, but h.id.age/name is going to be slower
        (needs to create an Identity object first)
    Note:
      subclasses' _fields_ are appended to superclass' _fields_
  ______________________________
  arrays and pointers
    Array(*args)
      abstract base class for arrays
      create by ctypes.c_type * int
      _length_: length of array, returned by len()
      _type_  : type of each element
#------------------------------
#2::cython
#------------------------------
#2.1::setup

______________________________
#2.1.1::installation
1. needs a C compiler
   (linux: sudo apt-get install build-essential)
2. mac: install XCode
3. Windows: MinGW
download: http://cython.org
unzip
enter directory
python setup.py install
  or
pip install Cython
pip install Cython --install-option="--no-cython-compile"

______________________________
#2.1.2::building
  compilation:
    1: .pyx file compiled by Cython to .c
    2: .c compiled by C compiler to .so (or .pyd) to be import-ed
  methods:
    write setup.py with distutils (most common)
    use pyximport to import .pyx and distutils to compile and build
    run cython command-line to make .c and then compile
    
  distutils method:
    ______________________________
    hello.pyx:
      def say_hello_to(name):
        print("Hello {}!".format(name))
    ______________________________
    setup.py:
      from distutils.core import setup
      from Cython.Build import cythonize
      setup(name = 'Hello world app',
            ext_modules = cythonize("mod1.pyx", "mod2.pyx"),)
    ______________________________
    command line:
      python setup.py build_ext --inplace --compiler=______
        bcpp
        cygwin
        mingw32
        otherwise, default uses visual studios (eww)
    ______________________________
    NOTE:
      should import distutils before cython because
      setup might replace extensions class
      would disagree on which extensions class to use

______________________________
#2.1.3::static typing (c type variables)
  NOTE: adding typing = harder to read, only use if
        really going to affect performance
  ex:
    def f(x):
      return x**2 - x
    def integrate_f(a, b, N):
      s = 0
      dx = (b - a) / N
      for i in xrange(N):
        s += f(a+i*dx)
      return s * dx

  add typings:
    def f(double x):
        return x**2 - x
    
    def integrate_f(a, b, N):
        cdef int i
        cdef double s, dx
        s = 0
        dx = (b - a) / N
        for i in xrange(N):
            s += f(a+i*dx)
        return s * dx
      
______________________________
#2.1.4::c type functions

reasoning: (i don't really get it)
  python function calls expensive
  cython: moreso (convert to and from Python objects)
  ex: f(): args assumed to be C double, but Python float
  must be created to pass it in

cdef: define a c data type
  ex:
    cdef int p[1000]
    cdef double s

change:
  cdef double f(double x) except? -2:
       return x**2 - x
add except-modifier or exceptions can't propagate
except? -2 means error checked for if -2 returned or -2 may be valid
except*: except all things

except may be left out if:
  returns a python object
  guaranteed no exceptions

results:
  function not available in python space
  function may not be modified

use cpdef and a wrapper created too

type-ing process
  1. profile
  2. check translation
     cython -a
  3. checks:
     some defs unnecessary 
       (infered based on function return type etc)
     integer arithmetic
       (in case of overflow, falls back to python big nums)

______________________________
#2.1.5::pyximport
automatically added to cython
ex:
  import pyximport; pyximport.install()
  import helloworld

can also import and compile .py files
  ex:
    pyximport.install(pyimport = True)
  if compile fails, then goes to normal import
  
______________________________
#2.1.6::c functions
use cimport (only understood by cython, don't use in py file)
ex:
  from libc.stdlib cimport atoi
  from libc.math cimport sin
  cdef parse_charptr_to_py_int(char* s):
      assert s is not NULL, "byte string value is NULL"
      return atoi(s)
cimport files found in:
  Cython/Includes/*.pxd

______________________________
#2.1.6.1::include C libraries
  cimport corresponding functions with cimport from .pxd
  ______________________________
  Dynamic linking
    ex:
      from distutils.core import setup
      from distutils.extension import Extension
      from Cython.Build import cythonize
      ext_modules = [Extension("modname",
                               sources=["f1.pyx"]
                               libraries=["m"])]
                               
      setup(ext_modules=cythonize(ext_modules))
  
______________________________
#2.1.6.2::external declarations:
  if not in a .pxd file, must write it myself:
  ex:
    cdef extern from "math.h":
        double sin(double x)
        double e
        double cos(double x)
        cpdef double acosh(double x) except -1 
        ...
  
______________________________
#2.1.6.3::naming parameters
cdef extern from "string.h":
    char* strstr(const char*, const char*) #as defined in .h file
    char* strstr(const char* haystack, const char* needle) #add it in in pxd for named arguments
______________________________
#2.1.6.4::libraries and wrappers
  case study: CAlg library
    ______________________________
    libcalg/queue.h:
      typedef struct _queue Queue;
      typedef void *QueueValue;
      Queue *Queue_new(void);
      void queue_free(Queue *queue);
      int queue_push_head(Queue *queue, QueueValue data);
      QueueValue queue_pop_head(Queue *queue);
      QueueValue queue_peek_head(Queue *queue);
      int queue_push_tail(Queue *queue, QueueValue data);
      QueueValue queue_pop_tail(Queue *queue);
      QueueValue queue_peek_tail(Queue *queue);
      int queue_is_empty(Queue *queue);
    ______________________________
    write a cqueue.pxd:
      cdef extern from "libcalg/queue.h":
          ctypedef struct Queue:
              pass
          ctypedef void* QueueValue;
          Queue* queue_new()
          void queue_free(Queue* queue)
          int queue_push_head(Queue *queue, QueueValue data)
          QueueValue queue_pop_head(Queue *queue)
          QueueValue queue_peek_head(Queue *queue)
          int queue_push_tail(Queue *queue, QueueValue data)
          QueueValue queue_pop_tail(Queue *queue)
          QueueValue queue_peek_tail(Queue *queue)
          bint queue_is_empty(Queue *queue)
    NOTE1:
        basically a copy and paste of header signatures
    NOTE2:
        ctypedef struct vs cdef struct:
          cdef    -> referred to in C as struct obj
          ctypedef-> referred to in C as obj
    NOTE3:
        bint: boolean int
        C has no bools so is an int in C
        but converted to True or False in python
    ______________________________
    wrapper: queue.pyx
      cimport cqueue #because cqueue.pxd is the pxd file name
      cdef class Queue:
          cdef cqueue.Queue* _c_queue
          def __cinit__(self):
              self._c_queue = cqueue.queue_new()

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    NOTE NOTE NOTE NOTE NOTE NOTE
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if a .pxd and .pyx file with same name are in same dir
    then .pxd interpreted as defining .pyx signatures
    thus, if .pxd defines clibrary, MUST BE DIF from any .pyx

    NOTE:
      def __cinit__ instead of def __init__
      difference:
        cinit:                      init:
        always called               maybe called
        self doesn't exist yet      self exists already
        (so only assign 
         to cdef fields)
        
    NOTE2:
      no-args __cinit__ is special case:
        doesn't receive parameters
        so subclasses can add whatever they want
      any __cinit__ parameters must match
      the params in __init__
______________________________
#2.1.7::memory management
  ex: queue_new returns NULL b/c no memory:
    cdef class Queue:
        cdef cqueue.Queue* _c_queue
        def __cinit__(self):
            self._c_queue = cqueue.queue_new()
            if self_c_queue is NULL:
                raise MemoryError()

        def __dealloc__(self):
            if self._c_queue is not NULL:
                cqueue.queue_free(self._c_queue)
  ______________________________
  setup.py:
    setup(ext_modules = cythonize([Extension("queue", ["queue.pyx"],
                                             libraries=["path to libs"])]))
    
  
