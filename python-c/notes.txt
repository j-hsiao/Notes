http://cython.readthedocs.io/en/latest/src/quickstart/index.html
http://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html
http://cython.readthedocs.io/en/latest/src/userguide/index.html#indices-and-tables


last on:
http://cython.readthedocs.io/en/latest/src/tutorial/clibraries.html



https://docs.python.org/2/distutils/index.html

#------------------------------
# contents
#------------------------------
1::ctypes
  1.1::guide
    1.1.1::loading libraries
    1.1.2::accessing functions
    1.1.3::calling functions
    1.1.4::datatypes
    1.1.5::arg/ret types
    1.1.6::pointers or references
    1.1.7::structs/unions
    1.1.8::arrays
    1.1.9::pointers
    1.1.10::conversion
    1.1.11::forward declarations
    1.1.12::callables/function pointers
    1.1.13::library variables
    1.1.14::surprises
    1.1.15::variable size data structures
  1.2::reference
    1.2.1::finding shared libraries
    1.2.2::foreign functions
    1.2.3::prototypes
    1.2.4::utility functions
    1.2.5::data types

2::cython
  2.0::independent testing
  2.1::intro
    2.1.1::installation
    2.1.2::building
    2.1.3::static typing (c type variables)
    2.1.4::c type functions
    2.1.5::pyximport
    2.1.6::c functions
      2.1.6.1::include C libraries
      2.1.6.2::external declarations
      2.1.6.3::naming parameters
      2.1.6.4::libraries and wrappers
      2.1.6.5::memory management
      2.1.6.6::compile and link
      2.1.6.7::mapping funcionality
      2.1.6.8::error checking
    2.1.7::extensions/cdef classes
    2.1.8::pxd files: like c headers
    2.1.9::caveats
    2.1.10::profiling
    2.1.11::strings and encoding
    2.1.12::memory allocation
    2.1.13::pure python mode
      2.1.13.1::augmenting pxd
      2.1.13.2::magic attributes
    2.1.14::working with numpy
    2.1.15::working with arrays
  2.2::users guide

    
    
#------------------------------
#1::ctypes
#------------------------------
foreign-language libraries (.dll, .so, etc)
compile c using gcc -o [name].so -shared -fPIC [files, libs, dirs, etc]
NOTE: -l might expect something of form lib[namehere].[dll, a, so, etc]
      use -l:actualfilename


______________________________
#1.1.1::loading libraries
  library classes:
    [all]   [windows only...???]
    cdll,   windll, oledll
  cdll: cdecl convention
  windll, oledll: stdcall convention
  ex:
    import ctypes
    ctypes.windll.kernel32
    ctypes.cdll.msvcrt
  windows adds .dll automatically??
  linux requires the extension too:
    use LoadLibrary() or constructor
  ex2:
    cdll.LoadLibrary("full-path-to-library-file")
    CDLL("full-path-to-library-file")

______________________________
#1.1.2::accessing functions
functions are attributes
win32: use ANSI and UNICODE versions of functions (end in A or W)
       (usually macro auto-picks, but with this module, must choose one yourself)
use getattr(lib, 'funcname') for function names that are messy
functions by ordinals:
lib[i]

______________________________
#1.1.3::calling functions
just call
ctypes tries protect against bad calls (need to look at headers or documentation)

None, ints, longs, bytestrings, unicode strings can be passed directly as params

None->NULL
bytestring, unicode->char* or wchar_t*
ints, longs-> int
ex:
  printf = libc.printf
  printf("Hello, %s, %d, %f\n", "World!", 5, 4.2)
NOTES:
  example raises an error because only auto-conversions are
  bytestring, int, and None
  must use ctypes.c_float(4.2) instead of just 4.2


______________________________
#1.1.4::datatypes
ctypes type     C type                  python type
c_bool          _Bool                   truthy object
c_char          char                    1-char string
c_wchar         wchar_t                 1-char unicode string
c_byte          char                    int/long
c_ubyte         unsigned char           int/long
c_short         short                   int/long
c_ushort        unsigned short          int/long
c_int           int                     int/long
c_uint          unsigned int            int/long
c_long          long                    int/long
c_ulong         unsigned long           int/long
c_longlong      __int64 or long long    int/long
c_ulonglong     unsigned __int64 or     int/long
                unsigned long long      
c_float         float                   float
c_double        double                  float
c_longdouble    long double             float
c_char_p        char* (NULL termed)     string or None
c_wchar_p       wchar_t* (NULL termed)  unicode or None
c_void_p        void*                   int/long or None

types: created with optional initialier
       mutable (var.value)
  NOTE1:
    new value to memory pointer type changes pointer
  NOTE2:
    python strings are IMMUTABLE
    need mutable strings, use ctypes.create_string_buffer()
                              ctypes.create_unicode_buffer()
    ex:
      p = create_string_buffer(3)
      print sizeof(p), repr(p.raw)
      p = create_string_buffer("Hello")
      print sizeof(p), repr(p.raw)
      print repr(p.value)
      p = create_string_buffer("Hello", 10)
      print sizeof(p), repr(p.raw)
      print repr(p.value)
      p.value = "Hi"      
      print sizeof(p), repr(p.raw)
      print repr(p.value)


NOTE:
  printf prints to std (not sys.std)
  
custom types require:
  _as_parameter_ (value to represent your object)
      or
  _as_parameter_ = property([fget, fset, fdel, doc])
  
______________________________
#1.1.5::arg/ret types
lib.function.argtypes 
lib.function.restype

tries to protect against invalid types and attemps auto-conversion
classes must have from_param() to be used in argtypes sequence
  from_param: receives object, should typecheck
              returns any valid object (ctypes, int, str, none, or _as_parameter_ object)

all return-types assumed to be ints
ex:
  strchr = ctypes.cdll.libc.strchr
  strchr("abcdef", ord("d"))
  strchr.restype = c_char_p
  strchr("abcdef", ord("d"))
  strchr.argtypes = [ctypes.c_char_p, ctypes.c_char]
  strchr("abcdef", "d")
  
restype can also be a callable function (will be called with returned integer)

______________________________
#1.1.6::pointers or references
ctypes.byref()
ctypes.pointer()

pointer: constructs a pointer (more work)
byref  : idk... but doc says does less work


______________________________
#1.1.7::structs/unions
must be Structure and Union classes
subclass must have _fields_ attr
_fields_: 2-tuple list of attrname, attrtype
  attrtype: a ctypes type, or structure, union, array, pointer
ex:
  class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_int),
                ("y", ctypes.c_int)]
  point = POINT(10, 20)
  print point.x, point.y
  point = POINT(y=5)
  print point.x, point.y
  POINT(1,2,3)
  (error)
  class RECT(ctypes.Structure):
    _fields_ = [("upperleft", POINT),
                ("lowerright", POINT)]

  r = RECT(POINT(1,2), POINT(3,4))
  r = RECT((1,2), (3,4))
  RECT.upperleft
  POINT.x

alignment/bytes:
  aligned as C
  use _pack_ to offset
    _pack_ = int > 0
  use ctypes.BigEndianStructure, 
             LittleEndianStructure, 
             BigEndianUnion, 
             LittleEndianUnion
bit fields (for ints only)
bit width as 3rd arg to int field


______________________________
#1.1.8::arrays
multiply datatype by int > 0

ex:
  class MyStruct(ctypes.Structure):
    _fields_ = [("a", c_int),
                ("b", c_float),
                ("parray", POINT * 4)]

______________________________
#1.1.9::pointer
call pointer() on ctypes type
pointer.contents->original object
whenever retrieve obj constructs a new one
p = ctypes.pointer(thing)
thing is p = False
thing.contents is p = False

can assign to contents or use indexing

use POINTER() to explicitly create a pointer TYPE
ex:
  intpointer = ctypes.POINTER(ctypes.c_int)
  point_to_5 = intpointer(5)

______________________________
#1.1.10::conversion
pointers and arrays are compatible like c-type arrays   
for passing pointers, can use object of same type,
  ctypes calls byref() automatically

can assign None to pointer to make it NULL
ctypes.cast(pointerobjthing, desiredtype)  

______________________________
#1.1.11::forward declarations
ex:
  class Link(ctypes.Structure):
    _fields_ = [("next", ctypes.POINTER(Link)),
                ("data", ctypes.c_int)]


______________________________
#1.1.12::callables/function pointers    
create class for callback
calling convention, return type, #/types of args
use CFUNCTYPE factory function for cdecl
use WINFUNCTYPE for stdcall

ex:
  CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
  def py_cmp_func(a, b):
      return a[0] - b[0]

  qsort = ctypes.cdll.libc.qsort
  qsort.restype = None

  callback = CMPFUNC(py_cmp_func)

NOTE: if references to callbacks are not kept, they may be garbage collected = crash

______________________________
#1.1.13::library variables
ex:
  opt_flag = c_int.in_dll(library, "variable_name")


______________________________
#1.1.14::surprises
swapping members of objects: uses memory
ex:
  p1 = POINT(1,2)
  p2 = POINT(3,4)
  rect = RECT(p1, p2)
  rect.a, rect.b = rect.b, rect.a

b copied into a (mutated), then a copied back to b

ex2:
  s = ctypes.c_char_p()
  s.value = "abc def ghi"
  s.value
  s.value is s.value
(using .value returns a new object every time)

______________________________
#1.1.15::variable size data structures
use resize() kind of like malloc

ex:
  short_array = (c_short * 4)()
  print ctypes.sizeof(short_array)
  ctypes.resize(short_array, 4)
  #(>>>error occurs<<<)
  ctypes.resize(short_array, 32)
  short_array[:]
  short_array[3]
  short_array[4]
  #(>>>error occurs<<<)
  new_short_array = (ctypes.c_short*16).from_address(ctypes.addressof(short_array))

##############################
#1.2::reference
##############################
#1.2.1::finding shared libraries
import ctypes
import ctypes.util
ctypes.util.find_library(name)
  name has no prefix or suffix
might be better to hard-code library name instead of using find_library

instantiation:
  ctypes.CDLL(path)
  ctypes.WinDLL(path)
  ctypes.OleDLL(path)
  NOTE:
    above: releases GIL before call

  ctypes.PyDLL(path)
  NOTE:
    above: does not release GIL (only useful for calling Python C api functions directly)

LoadLibrary:
  ctypes.cdll.LoadLibrary(path)
  ctypes.oledll.LoadLibrary(path)
  ctypes.windll.LoadLibrary(path)
  ctypes.pythonapi
______________________________
#1.2.2::foreign functions
  by default: return int, accept any number of arguments
  ctypes._FuncPtr
    restype:    return type, None for void, ctypes.c_type or related (structure etc)
    argtypes:   list of argument types (ctypes, structs etc)
    errcheck:   callable for error checking on the return value
                signature: callable(result, func, arguments)

______________________________
#1.2.3::prototypes
ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
*above releases the GIL*

ctypes.PYFUNCTYPE(restype, *argtypes)
*above doesn't release GIL*

instantiation:
  prototype(address)
    (for the foreign types)
  prototype(callable)
    (for pytype)
  prototype(func_spec, [paramflags])
    func_spec: tuple: (name/ordinal, library)
  prototype(vtbl_index, name[,paramflags, iid]):
    foreign func call COM method
    vtbl_index: index into virtual function table
    name: COM method
    iid: pointer to interface identifier

  paramflags:
    list of same length as argtypes
    each entry : a tuple
      each tuple:
        index 0: 1|2|4: input|output|input defaults 0
        index 1: param name as string
        index 2: default value for parameter
    
ex:
  from ctypes import c_int, WINFUNCTYPE, windll
  from ctypes.wintypes import HWND, LPCSTR, UINT
  prototype = WINFUNCTYPE(c_int, HWND, LPCSTR, LPCSTR, UINT)
  paramflags = (1, "hwnd", 0), (1, "text", "Hi"), (1, "caption", None), (1, "flags", 0)
  MessageBox = prototype(("MessageBoxA", windll.user32), paramflags)
  MessageBox()
  MessageBox(text = "Spam, spam spam")
  MessageBox(flags = 2, text = "foo bar")

______________________________
#1.2.4::utility functions
  ctypes:
    addressof(obj)
    alignment(obj_or_type)
    byref(obj, [offset])
    cast(obj, type)
    create_string_buffer(init_or_size, [size])
    create_unicode_buffer(init_or_size, [size])
    DllCanUnloadNow()
      windows only, COM servers,
    DllGetClassObject()
      windows only, COM servers, 
    FormatError([code])
      windows only
    GetLastError()
      windows only
    get_errno()
      ctypes-private copy
    get_last_error()
      windows only, gets ctypes-private copy
    memmove(dst, src, count)
      like strncpy
    memset(dst, c, count)
      sets vals to c
    POINTER(type)
      returns ctypes pointer class
    pointer(obj)
      creates a pointer
    resize(obj, size)
    set_conversion_mode(encoding, errors)
      sets rules ctypes objs use when converting 8-bit strings and unicode strings
        encoding: string specifying encoding like utf-8, mbcs, etc
        errors:   string specifying error handling ("strict", "replace", "ignore"
      empty args returns 2-tuple:
        (encoding, errors)
    set_errno(value)
    set_last_error(value)
      windows only
    sizeof(obj or type)
    string_at(address, [size])
    WinError(code=None, descr=None)
      windows only
    wstring_at(address, [size])
      wide character string at address length size
  ctypes.util
    find_library(name)
    find_msvcrt()
______________________________
#1.2.5::data types
  ______________________________
  _CData
    base class of ctypes.c_*
    from_buffer(source, [offset])
      ctypes instance from the buffer
      must support writeable buffer interface
    from_buffer_copy(source, [offset])
      copy buffer from source (must be readable)
    from_address(address)
      use memory at address
    from_param(obj)
      adapts obj to ctypes type
      called when argtypes is set
    in_dll(library, name)
      gets library var
    _b_base_
      for shared memory-read-only member
    _b_needsfree_
      read-only, true when ctypes data instance has allocated memory block itself
    _objects
      None or dict of python objects that must be alive
      (only for looking, do not modify or death)
  ______________________________
  _SimpleCData
    value
      value of instance
      access returns a new object
  ______________________________
  Fundamental types:
    always converted to python types when specified as _restype_ or accessed from struct
    
    c_byte
    c_char
    c_char_p
    c_double
    c_longdouble
    c_float
    c_int
    c_int8
    c_int16
    c_int32
    c_int64
    c_long
    c_longlong
    c_short
    c_size_t
    c_ssize_t
    c_ubyte
    c_uint
    c_uint8
    c_uint16
    c_uint32
    c_uint64
    c_ulong
    c_ulonglong
    c_ushort
    c_void_p
    c_wchar
    c_wchar_p
    c_bool
    HRESULT
      Windows only
    py_object
      C PyObject* datatype
    ctypes.wintypes
      HWND
      WPARAM
      DWORD
      MSG
      RECT
  ______________________________
  Structured Data Types
    Union(*args, **kw)
    BigEndianStructure(*args, **kw)
    LittleEndianStructure(*args, **kw)
    Structure(*args, **kw)
    NOTE:
      Structure and Union should be subclassed
      must define _fields_ variable
    _fields_:
      list of 2 or 3-tuples
        name, type, [bit-width (for ints only)
    _pack_:
      overrides allignment
    _anonymous_:
      names unnamed fields
      used for fields of non-fundamental types
      ex:
        class Identity(ctypes.Structure):
          _fields_ = [('name', ctypes.c_char_p),
                      ('age',  ctypes.c_int)]
        class Human(ctypes.Structure):
          _anonymous_ = ("u",)
          _fields_ = [('id', Identity)]
        i = Identity('jason', 25)
        h = Human(i)
        h.name
        h.age
        h.id.name
        h.d.age
      all work, but h.id.age/name is going to be slower
        (needs to create an Identity object first)
    Note:
      subclasses' _fields_ are appended to superclass' _fields_
  ______________________________
  arrays and pointers
    Array(*args)
      abstract base class for arrays
      create by ctypes.c_type * int
      _length_: length of array, returned by len()
      _type_  : type of each element
#------------------------------
#2::cython
#------------------------------
______________________________
#2.0::independent testing
  obs1:
    cython-compile f1.py
    f1.py imports f2.py and uses its functions
    f2.py is left uncompiled
    end result:
    f1.py still uses f2.py
    modify f2.py changes f1.py behavior (but can still lead to speed-ups)
    
  obs2:
    using decorators seems like it doesn't really change runtime much from using .pyx
    



#2.1::intro

______________________________
#2.1.1::installation
1. needs a C compiler
   (linux: sudo apt-get install build-essential)
2. mac: install XCode
3. Windows: MinGW
download: http://cython.org
unzip
enter directory
python setup.py install
  or
pip install Cython
pip install Cython --install-option="--no-cython-compile"

______________________________
#2.1.2::building
  compilation:
    1: .pyx file compiled by Cython to .c
    2: .c compiled by C compiler to .so (or .pyd) to be import-ed
  methods:
    write setup.py with distutils (most common)
    use pyximport to import .pyx and distutils to compile and build
    run cython command-line to make .c and then compile
    
  distutils method:
    ______________________________
    hello.pyx:
      def say_hello_to(name):
        print("Hello {}!".format(name))
    ______________________________
    setup.py:
      from distutils.core import setup
      from distutils.extension import Extension
      from Cython.Build import cythonize

      exts = [Extension(name, [files]),
              ...]

      setup(name = 'Hello world app',
            ext_modules = cythonize(exts),)
    ______________________________
    command line:
      python setup.py build_ext --inplace --compiler=______
        bcpp
        cygwin
        mingw32
        otherwise, default uses visual studios (eww)
    ______________________________
    NOTE:
      should import distutils before cython because
      setup might replace extensions class
      would disagree on which extensions class to use

______________________________
#2.1.3::static typing (c type variables)
  NOTE: adding typing = harder to read, only use if
        really going to affect performance
  ex:
    def f(x):
      return x**2 - x
    def integrate_f(a, b, N):
      s = 0
      dx = (b - a) / N
      for i in xrange(N):
        s += f(a+i*dx)
      return s * dx

  add typings:
    def f(double x):
        return x**2 - x
    
    def integrate_f(a, b, N):
        cdef int i
        cdef double s, dx
        s = 0
        dx = (b - a) / N
        for i in xrange(N):
            s += f(a+i*dx)
        return s * dx
      
______________________________
#2.1.4::c type functions

reasoning: (i don't really get it)
  python function calls expensive
  cython: moreso (convert to and from Python objects)
  ex: f(): args assumed to be C double, but Python float
  must be created to pass it in

cdef: define a c data type
  ex:
    cdef int p[1000]
    cdef double s

change:
  cdef double f(double x) except? -2:
       return x**2 - x
add except-modifier or exceptions can't propagate
except? -2 means error checked for if -2 returned or -2 may be valid
except*: except all things

except may be left out if:
  returns a python object
  guaranteed no exceptions

results:
  function not available in python space
  function may not be modified

use cpdef and a wrapper created too

type-ing process
  1. profile
  2. check translation
     cython -a
  3. checks:
     some defs unnecessary 
       (infered based on function return type etc)
     integer arithmetic
       (in case of overflow, falls back to python big nums)

______________________________
#2.1.5::pyximport
automatically added to cython
ex:
  import pyximport; pyximport.install()
  import helloworld

can also import and compile .py files
  ex:
    pyximport.install(pyimport = True)
  if compile fails, then goes to normal import
  
______________________________
#2.1.6::c functions
use cimport (only understood by cython, don't use in py file)
ex:
  from libc.stdlib cimport atoi
  from libc.math cimport sin
  cdef parse_charptr_to_py_int(char* s):
      assert s is not NULL, "byte string value is NULL"
      return atoi(s)
cimport files found in:
  Cython/Includes/*.pxd

______________________________
#2.1.6.1::include C libraries
  cimport corresponding functions with cimport from .pxd
  ______________________________
  Dynamic linking
    ex:
      from distutils.core import setup
      from distutils.extension import Extension
      from Cython.Build import cythonize
      ext_modules = [Extension("modname",
                               sources=["f1.pyx"]
                               libraries=["m"])]
                               
      setup(ext_modules=cythonize(ext_modules))
  
______________________________
#2.1.6.2::external declarations:
  if not in a .pxd file, must write it myself:
  ex:
    cdef extern from "math.h":
        double sin(double x)
        double e
        double cos(double x)
        cpdef double acosh(double x) except -1 
        ...
  
______________________________
#2.1.6.3::naming parameters
cdef extern from "string.h":
    char* strstr(const char*, const char*) #as defined in .h file
    char* strstr(const char* haystack, const char* needle) #add it in in pxd for named arguments
______________________________
#2.1.6.4::libraries and wrappers
  case study: CAlg library
    ______________________________
    libcalg/queue.h:
      typedef struct _queue Queue;
      typedef void *QueueValue;
      Queue *Queue_new(void);
      void queue_free(Queue *queue);
      int queue_push_head(Queue *queue, QueueValue data);
      QueueValue queue_pop_head(Queue *queue);
      QueueValue queue_peek_head(Queue *queue);
      int queue_push_tail(Queue *queue, QueueValue data);
      QueueValue queue_pop_tail(Queue *queue);
      QueueValue queue_peek_tail(Queue *queue);
      int queue_is_empty(Queue *queue);
    ______________________________
    write a cqueue.pxd:
      cdef extern from "libcalg/queue.h":
          ctypedef struct Queue:
              pass
          ctypedef void* QueueValue;
          Queue* queue_new()
          void queue_free(Queue* queue)
          int queue_push_head(Queue *queue, QueueValue data)
          QueueValue queue_pop_head(Queue *queue)
          QueueValue queue_peek_head(Queue *queue)
          int queue_push_tail(Queue *queue, QueueValue data)
          QueueValue queue_pop_tail(Queue *queue)
          QueueValue queue_peek_tail(Queue *queue)
          bint queue_is_empty(Queue *queue)
    NOTE1:
        basically a copy and paste of header signatures
    NOTE2:
        ctypedef struct vs cdef struct:
          cdef    -> referred to in C as struct obj
          ctypedef-> referred to in C as obj
    NOTE3:
        bint: boolean int
        C has no bools so is an int in C
        but converted to True or False in python
    ______________________________
    wrapper: queue.pyx
      cimport cqueue #because cqueue.pxd is the pxd file name
      cdef class Queue:
          cdef cqueue.Queue* _c_queue
          def __cinit__(self):
              self._c_queue = cqueue.queue_new()

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    NOTE NOTE NOTE NOTE NOTE NOTE
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if a .pxd and .pyx file with same name are in same dir
    then .pxd interpreted as defining .pyx signatures
    thus, if .pxd defines clibrary, MUST BE DIF from any .pyx

    NOTE:
      def __cinit__ instead of def __init__
      difference:
        cinit:                      init:
        always called               maybe called
        self doesn't exist yet      self exists already
        (so only assign 
         to cdef fields)
        
    NOTE2:
      no-args __cinit__ is special case:
        doesn't receive parameters
        so subclasses can add whatever they want
      any __cinit__ parameters must match
      the params in __init__
______________________________
#2.1.6.5::memory management
  ex: queue_new returns NULL b/c no memory:
    cdef class Queue:
        cdef cqueue.Queue* _c_queue
        def __cinit__(self):
            self._c_queue = cqueue.queue_new()
            if self_c_queue is NULL:
                raise MemoryError()

        def __dealloc__(self):
            if self._c_queue is not NULL:
                cqueue.queue_free(self._c_queue)
______________________________
#2.1.6.6::compile and link
  setup(ext_modules = cythonize([Extension("queue", ["queue.pyx"],
                                           libraries=["path to libs"])]))
  pass flags for other stuff:
  CFLAGS="-i/usr/local/otherincludestuffs"
  LDFLAGS="-L/usr/local/otherlibdirs"

______________________________
#2.1.6.7::mapping functionality
  map corresponding functionalities
  ex:
    cdef append(self, int value):
        if not cqueue.queue_push_tail(self._c_queue, <void*>value):
            raise MemoryError()
    cdef extend(self, int* values, size_t count):
        cdef size_t i
        for i in range(count):
            if not cqueue.queue_push_tail(self._c_queue,
                                          <void*>values[i]):
                raise MemoryError()
    cdef int peek(self):
        return cqueue.queue_peek_head(self._c_queue)
        
    cdef int pop(self):
        return cqueue.queue_pop_head(self._c_queue)
______________________________
#2.1.6.8::error checking
  empty queue, returns NULL pointer
  issue:
    NULL b/c empty, or NULL because 0 was stored?
  to function signature, at the end, before the :
    add:
      except [?] val
  except: exception may happen(only for cdef functions)
  [?]   : add a ? if val might also be a valid value
  val   : the value to return to the python caller
          as in: if this cdef function errors, immediately return
            the exception value (no ?, implies this value is ALWAYS an error when seen by python caller)
            when ? is present, then the val MIGHT be a valid value:
              when function returns val, then calls PyErr_Occurred automatically
              (if it was an error, you should have raised an error => error,
               if you didn't raise an error, then it assumes it was a valid return value)



  ex: add except clause:
    cdef int peek(self) except? -1:
        value=<int>cqueue.queue_peek_head(self._c_queue)
        if value == 0:
            if cqueue.queue_is_empty(self._c_queue):
                raise IndexError("Queue is empty")
        return value
    cdef int pop(self) except? -1:
        if cqueue.queue_is_empty(self._c_queue):
            raise IndexError("Queue is empty")
        return cqueue.queue_pop_head(self._c_queue)
    def __bool__(self):
        return not cqueue.queue_is_empty(self._c_queue)

______________________________
#2.1.6.9::callbacks
  ex: predicate: -1 on error, 0 for reject, 1 for accept
  cdef int evaluate_predicate(void* context, cqueue.QueueValue value):
      try:
          func = <object>context
          return bool(func(<int>value))
      except:
          return -1
  def pop_until(self, python_predicate_function):
      result=cqueue.queue_pop_head_until(self._c_queue, evaluate_predicate, <void*>python_predicate_function)
      if result == -1:
          raise RuntimeError("an error occurred")
______________________________
#2.1.7::extensions/cdef classes
  classes may be written as normal in python
    or...
  cdef class

  cdef cannot inherit from python classes

  ex:
    cdef class Function:
        cpdef double evaluate(self, double x) except *:
            return 0
    cdef class SinOfSquareFunction(Function):
        cpdef double evaluate(self, double x) except *:
            return sin(x**2)
  
    def integrate(Function f, double a, double b, int N):
        cdef int i
        cdef double dx, s = 0
        if f is None:
            raise ValueError("f cannot be None")
        dx = (b-a)/N
        for i in range(N):
            s += f.evaluate(a+i*dx)
        return s * dx
    print (integrate(SinOfSquareFunction(), 0, 1, 10000))
  
    def class PyFunction(Function):
        def evaluate(self, x):
            return 2*x*x + 3*x - 10
  
    print (integrate(SinOfSquareFunction(), 0, 1, 10000))
    
  NOTE1:
    evaluate is called fast only because Function has an evaluate method
    function in integrate, f: typed so faster
    typed, so must check for None (else uses None as if its a Function)->crash

  ex:
    cdef class WaveFunction(Function):
        #python can't see this
        cdef double offset
        #python can see this
        cdef public double freq
        
        @property
        def period(self):
            return 1.0 / self.freq

        @property.setter
        def period(self, val):
            self.freq = 1.0 / val
    
  NOTE2:
    cdef quirks:
      all attributes must be pre-declared
      accessible only from cython 
      can be exposed to python
______________________________
#2.1.8::pxd files: like c headers
  use cimport
  uses:
    share external C declarations
    functions for inlining by C compiler (marked inline)
      ex:
        cdef inline int int_min(int a, int b):
            return b if b < a else a
    accompanying a pyx file so other pyx files can just include
    the pxd (cimport pxd) instead of the pyx
  NOTE:
    any class attributes MUST be in pxd file
______________________________
#2.1.9::caveats
  Cython                 Python

  10**-2 == 0            10 ** -2 == 0.01

  a % -b < 0             a % -b < 0
  a % -b > 0 (if used @cython.cdivision(True))
  
  cdef unsigned n = 10; print(range(-n, n)) = empty (-n is large positive value because unsigned)

  double                 float
  long                   int
  
______________________________
#2.1.10::profiling
  use cython decorator:
    full file:
      # cython: profile=True
    per function:
      cimport cython
      @cython.profile(True/False)
  
  use the cProfile module
  
  ______________________________
  tracing:
    in files:
      # cython: linetrace=True
    in setup.py:  
      # distutils: define_macros=CYTHON_TRACE=1
        or
      # distutils: define_macros=CYTHON_TRACE_NOGIL=1
  ______________________________
  case study: basel problem
    pi^2 = sum(1/x^2, x=1, infinity)

    ex:
      def recip_square(i):
          return 1./i**2
      def approx_pi(n=10000000):
          val=0.
          for k in range(1, n+1):
              val += recip_square(k)
          return (6 * val)**.5

______________________________
#2.1.11::strings and encoding
  byte and unicode are separate
  must have separate encode/decode steps

  use c_string_type and c_string_encoding
  ______________________________
  cython string types:
    bytes        : typical ascii string
    bytearray    : ascii mutable string
    str          : python str (byte in python2, unicode in python3)
    unicode      : unicode string
    basestring   : reps all types of text, used for backwards compatibility, incompatible with bytes type
                   should rarely be used...??? then why make it?
  NOTE:
    str incompatible with python2 unicode type
    (assign python2 unicode to str in cython = TypeError)
    means maybe not type if going to use python2 (not safe)
  
  ______________________________
  use prefixes to specify:
    b'bytes'
    u'unicode'
    f'formated {value}'   ??? wats this

  ______________________________
  C strings are costly
    (len is not cached)
  
  ______________________________
  auto-casting:
    cdef char* c_string = c_call_returning_a_c_string()
    cdef bytes py_string = c_string
    py_string = <bytes> cstring

    cdef char* oc_string = py_string


    use slicing to incorporate length as well:
    (no need for linear-time strlen)
    get_a_c_string(&c_string, &length)
    py_bytes_string = c_string[:length]

    NOTE1:
      might fail due to memory allocation
      wrap in try-finally
    NOTE2:
      assigning pystring to char* points to pystring buffer
      make sure pystring is not garbage collected or 
        data corruption/crashes may occur

  ______________________________
  strings from python
    if deal only w/ bytestrings, maybe don't type as byte: restrict allowed input, use a view
    ex:
      def process_byte_data(unsigned char[:] data):
          length = data.shape[0]
          first_byte = data[0]
          slice_view = data[1:-1]
    may be good to copy data into a bytes object (can get rid of extra buffer size etc)
    ex:
      def process_byte_data(unsigned char[:] data):
          if return_all:
              return bytes(data)
          else:
              return bytes(data[5:35])
  ______________________________
  deal with unicode: first write converter to unicode
    ex:
      from cpython.version import PY_MAJOR_VERSION
      cdef unicode_ustring(s):
          if type(s) is unicode:
              return <unicode>s
          elif PY_MAJOR_VERSION < 3 and isinstance(s, bytes):
              return (<bytes>s).decode('ascii')
          elif isinstance(s, unicode):
              return unicode(s)
          else:
              raise TypeError()
  ______________________________
    cdef char_type[:] _chars(s):
        if isinstance(s, unicode):
            s = (<unicode>s).encode('utf8')
        return s
  ______________________________
  const:
    libraries may require const
    ex:
      typcdef const char specialChar;
      int process_string(const, char* s);
      const unsigned char* look_up_cached_string(const unsigned char* key);
      
      cdef extern from "someheader.h":
          ctypedef const char specialChar
          int process_string(const char* s)
          const unsigned char* look_up_cached_string(const unsigned char* key)
          
      note: generally can just ignore const in api functions
      use libc.string types:
        const_char
        const_uchar
  ______________________________
  decode bytes to text:
    bytes.decode
    ONLY if no null bytes
    ex:
      ustring = byte_string.decode('UTF-8')
      cdef char* some_c_string = c_call_returning_a_c_string()
      ustring = some_c_string.decode('UTF-8')
      get_a_c_string(&c_string, &length)
      ustring = c_string[:length].decode('UTF-8')

    ex:
      from libc.stdlib cimport free
      
      cdef unicode tounicode(char* s):
          return s.decode('UTF-8', 'strict')
      
      cdef unicode tounicode_with_length(
              char* s, size_t length):
          return s[:length].decode('UTF-8', 'strict')
      
      cdef unicode tounicode_with_length_and_free(
              char* s, size_t length):
          try:
              return s[:length].decode('UTF-8', 'strict')
          finally:
              free(s)      
  NOTE:
    cython will not compile if no python pointer is kept (segfault just asking to happen)

  ______________________________
  C++ strings:
    ex:
      from libcpp.string cimport string
      cdef string s = py_bytes_object
      try:
          s.append('abc')
          py_bytes_object = s
      finally:
          del s
  
  ______________________________
  automatics:
    ex:
      # cython: c_string_type=unicode, c_string_encoding=utf8
      # cython: c_string_type=str, c_string_encoding=ascii
  ______________________________
  source code encoding:
    hard-coded string literals: depend on source code encoding
    ex:
      # -*- coding: ISO-8859-15 -*-
    whenever use none-byte non-ascii, prefix string with u for unicode...
  ______________________________
  single bytes and characters
    can use Py_UNICODE, Py_UCS4, etc
    normal = char
    Py_UNICODE = 2-byte, 4-byte, or wchar_t (determined by CPython interpreter)
    PyUCS4: uint32
  
    char by default goes to an int
    want 1-char string, must cast to <bytes>
  ______________________________
  need be careful if narrow unicode 
    (16-bits, some unicode require more than 16 bites)
    ... don't think I'll ever use this so I'm going to skip

______________________________
#2.1.12::memory allocation
  multidim simple types: NumPy, memory views, Python stdlib array
  C malloc, realloc, free:
    from libc.stdlib cimport malloc, free
  python-c api:
    from cpython.mem cimport PyMem_Malloc, PyMemRealloc, PyMem_Free

  if possible, use python-c api functions (has optimizations and stuff etc)


  malloc, realloc, free:
    void* malloc(size_t size)
    void* realloc(void* ptr, size_t size)
    void free(void* ptr)




  ex:
    import random
    from libc.stdlib cimport malloc, free
    
    def random_noise(int number=1):
        cdef int i
        # allocate number * sizeof(double) bytes of memory
        cdef double *my_array = <double *>malloc(number * sizeof(double))
        if not my_array:
            raise MemoryError()
    
        try:
            ran = random.normalvariate
            for i in range(number):
                my_array[i] = ran(0,1)
    
            return [ my_array[i] for i in range(number) ]
        finally:
            # return the previously allocated memory to the system
            free(my_array)
  
  like in C, any malloc must be free'ed
             any PyMem_Malloc must be PyMem_Free'ed
  can just tie it to an object:

    cdef class SomeMemory:
      ex:    
        cdef double* data
    
        def __cinit__(self, size_t number):
            # allocate some memory (uninitialised, may contain arbitrary data)
            self.data = <double*> PyMem_Malloc(number * sizeof(double))
            if not self.data:
                raise MemoryError()
    
        def resize(self, size_t new_number):
            # Allocates new_number * sizeof(double) bytes,
            # preserving the current content and making a best-effort to
            # re-use the original data location.
            mem = <double*> PyMem_Realloc(self.data, new_number * sizeof(double))
            if not mem:
                raise MemoryError()
            # Only overwrite the pointer if the memory was really reallocated.
            # On error (mem is NULL), the originally memory has not been freed.
            self.data = mem
    
        def __dealloc__(self):
            PyMem_Free(self.data)     # no-op if self.data is NULL

______________________________
#2.1.13::pure python mode
  used to maintain python-runability
  use an augmenting .pxd file (a blah.pxd file with a blah.py file in same dir)
  or import cython and use decorators
  

  ______________________________
  #2.1.13.1::augmenting pxd
    pros: .py untouched
    cons: .pxd and .py must both be maintained
    .py definitions can be overridden by .pxd definitions
    (by comparison, .pyx and .pxd must match perfectly)
    
    can only modify class and function definitions?
    (cdef classes, cdef/cpdef functions)
    
    ex:
    ______________________________
    file.py:
      def myfunction(x, y=2):
          a = x-y
          return a + x * y
      
      def _helper(a):
          return a + 1
      
      class A:
          def __init__(self, b=0):
              self.a = 3
              self.b = b
      
          def foo(self, x):
              print x + _helper(1.0)
    ______________________________
    file.pxd        
      cpdef int myfunction(int x, int y=*)
      cdef double _helper(double a)
      
      cdef class A:
          cdef public int a,b
          cpdef foo(self, double x)

    NOTE1:
      use =* with default arguments to avoid repetition
    NOTE2:
      normal python def functions cannot be declared in .pxd files
      therefore local variables cannot be typed
    ______________________________
    #2.1.13.2::magic attributes
      pros: no extra .pxd file
      cons: adds cython module dependency
            (Cython.Shadow (cython.py) is a fake, can be copied if cython not installed)
            
      ______________________________
      compiled switch:
        cython.compiled (True if compiled, False otherwise)
      ______________________________
      cython.declare
        cython.declare declares typed variable in current scope (replaces cdef type var [= value] )
        ex:
          x = cython.declare(cython.int)
          y = cython.declare(cython.double, 3.1415926)
          cython.declare(x=cython.int, y=cython.double) # ?? what does this do? in intepreter, returns an obj
                                                        # used inside of an object? only? what happens when outside?
          class A:
              cython.declare(a=cythonint, b=cython.int)
              def __init__(self, b=0):
                  self.a=3
                  self.b=b
          #a cdef class
          @cython.cclass
          classB:
              cython.declare(a=cython.int, b=cython.int)
              c = cython.declare(cython.int, visibility='public')
              d = cython.declare(cython.int, 5) #private
              e = cython.declare(cython.int, 5, visibility = 'readonly')
          
          #how to make local variables typed as well (includes args)
          @cython.locals(a=cython.double, b=cython.double, n=cython.p_double)
          def foo(a, b, x, y):
              n = a*b
              ...

          #specifies return type
          @cython.returns(<type>)
       
      ______________________________
      cython types:
        basic types:
          short, char, int, long, longlong
          ushort, uchar, uint, ulong, ulonglong
          bint, Py_ssize_t
        pointers:
          p_int, pp_int, etc
          cython.pointer(cython.int)
          cython.int[10]
        can also use:
          user-defined types
          python built-in types (list, dict...)
      
      ______________________________
      extension types and cdef functions
        @cython.cclass: cdef class
        @cython.cfunc: cdef func
        @cython.ccall: cpdef func
        @cython.locals: local and args
        @cython.inline: c inline modifier
        @cython.returns(return-type)
      ______________________________
      other cython things:
        cython.address(obj)
          equivalent of C & operator
        cython.sizeof
          equivalent of sizeof operator
        cython.struct(name=type, ...)
          ex:
            MyStruct = cython.struct(x=cython.int, y=cython.double, d = cython.p_double)
            a = cython.declare(MyStruct)
            
            ##########same as ##########
            cdef struct MyStruct:
                int x
                double y
                double * d
            cdef MyStruct a
        cython.union
        cython.typedef
        cython.cast
          unsafe reinterpretation
          cython.cast(newtype, oldvar)
            ##########same as##########
          <T>t

          cython.cast(newtype, oldvar, typecheck=True)
            ##########same as##########
          <T?>t
      ______________________________
      other notes:
        above can also be used with the .pxd file
        ie: @cython.locals for typing local variables of functions
            cython.declare for global variables
    ______________________________
    tips and tricks
      ______________________________
      calling C functions:
        ______________________________
        mymod.pxd
          cdef extern from "math.h":
              cpdef double sin(double x)
        ______________________________
        mymod.py
          import cython
          if not cython.compiled:
            from math import sin
          print(sin(0))

      ______________________________
      C arays for fixed size lists
      import cython
      @cython.locals(counts=cython.int[10], digit=cython.int)
      def count_digits(digits):
        counts=[0]*10
        for digit in digits:
            assert 0 <= digit <= 9
            counts[digit] += 1
        return counts

______________________________
2.1.14::working with numpy
  cimport numpy as np
  runtime typings: just use np.type
  compiletime typings: use np.type_t, use ctypedef
  ______________________________
  efficient indexing:
    declare np.ndarray types as:
      np.ndarray[type, ndim=N]
    make sure indices are typed
  ______________________________
  remove safeties:
    cimport cython
    @cython.boundscheck(False) # bounds checking
    @cython.wraparound(False)  # negative indices
______________________________
2.1.15::working with arrays (array module)
  can access underlying arrays, and can be passed with multiprocessing
  ______________________________
  safe usage with memory views:
    ex:
      from cpython cimport array
      import array
      cdef array.array a = array.array('i', [1, 2, 3])
      cdef int[:] ca = a
      
      cdef int overhead(object a):
          cdef int[:] ca = a
          return ca[0]
      
      cdef int no_overhead(int[:] ca):
          return ca[0]
      
      print overhead(a)  # new memory view will be constructed, overhead
      print no_overhead(ca)  # ca is already a memory view, so no overhead
  ______________________________
  no-overhead unsafe access
    from cpython cimport array
    import array
    
    cdef array.array a = array.array('i', [1, 2, 3])
    
    # access underlying pointer:
    print a.data.as_ints[0]
    
    from libc.string cimport memset
    memset(a.data.as_voidptr, 0, len(a) * sizeof(int))
  ______________________________
  cloning, extending arrays
    cloning ex:
      from cpython cimport array
      import array
      
      cdef array.array int_array_template = array.array('i', [])
      cdef array.array newarray
      
      # create an array with 3 elements with same type as template
      newarray = array.clone(int_array_template, 3, zero=False)
    extending ex:
      from cpython cimport array
      import array
      
      cdef array.array a = array.array('i', [1, 2, 3])
      cdef array.array b = array.array('i', [4, 5, 6])
      
      # extend a with b, resize as needed
      array.extend(a, b)
      # resize a, leaving just original three elements
      array.resize(a, len(a) - len(b))    
  ______________________________
  reference::
    ______________________________
    data
      data.as_voidptr
      data.as_chars
      data.as_schars
      data.as_uchars
      data.as_shorts
      data.as_ints
      data.as_uints
      data.as_longs
      data.as_ulongs
      data.as_floats
      data.as_doubles
      data.as_pyunicodes
    ______________________________
    functions
      int resize(array self, Py_ssize_t n) except -1
      int resize_smart(array self, Py_ssize_t n) except -1
      cdef inline array clone(array template, Py_ssize_t length, bint zero)
      cdef inline array copy(array self)
      cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1
      cdef inline int extend(array self, array other) except -1
      cdef inline void zero(array self)
##############################
2.2::users guide
##############################
