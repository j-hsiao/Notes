______________________________
contents

-0- general
	-0.1- logic
	-0.2- variables
		-0.2.0- expansions
		-0.2.1- quoting
		-0.2.2- scopes/assignment
		-0.2.3- strings
		-0.2.4- numbers
		-0.2.5- arrays
		-0.2.6- ANSI-C quoting
		-0.2.7- special variables
	-0.3- functions
		-0.3.1- function outputs
	-0.4- pattern matching
	-0.5- shopt
	-0.6- brace expansion
	-0.7- configuration files
	-0.8- inputs
	-0.9- redirection
	-0.10- [$][[]|[[]]|()|(())]
		-0.10.1- [] test
		-0.10.2- $[] arithmetic expansion (old)
		-0.10.3- [[]] test (extended)
		-0.10.4- () subshell
		-0.10.5- $() command substitution
		-0.10.6- (()) nonzero arithmetic expansion test
		-0.10.7- $(()) arithmetic expansion
		-0.10.8- <() process substitution
		-0.10.9- {} command grouping
		-0.10.10- ${} paramater expansion
-1- regexp
-2- completion
-3- ps1 (prompt)
-4- various utilities
	-4.1- text manipulation
		-4.1.1- cut
		-4.1.2- cut
		-4.1.3- sed
		-4.1.4- grep
	-4.2- drives and devices
		4.1.1- lsblk
		4.1.2- blkid
		4.1.3- df
		4.1.4- mount
		4.1.5- umount
	-4.69- others
		-4.69.1- shuf
		-4.69.2- tput
		-4.69.3- stty
-5- tips/tricks
	-5.1- reset
-6- builtins
	-6.1- printf

______________________________
-0- general
	______________________________
	-0.1- logic
		every command has an exit code.  The exit code determines truthiness.
		0 = true, nonzero = false.  The exitcode for the last process can be
		obtained with $?

		if command; then <do stuff; and more stuff; ...;> fi

		while command; do <stuff; and morestuff; ...;> done

		for var in <sequence of items by ifs>; do <stuff; and more stuff...;> done

		case <pat> in
			pat)
				stuffs
				;; (break)
			pat)
				stuffs
				;& (fall through, only bash 4.0+)
			*)
				etc
		esac
		(see -0.4- pattern matching)
	______________________________
	-0.2- variables
		general note:
			using * and @ result in all relevant items.
			However, putting the thing into double quotes,
			* becomes a single item whereas @ preserves
			identity of each item
			eg:
				a=("this" "contains" "something with a space")
				>>> printf '%s\n' "${a[@]}"
				this
				contains
				something with a space
				>>> printf '%s\n' "${a[*]}"
				this contains something with a space

			if parameter is array-like, operations are usually
			applied to each item in the array

		creation:
			declare varname
			varname=value
		creation from other var
			printf format string and save under var name
				printf -v "${variable_containing_target_name}" 'format_string' args...
			read with herestring
				read [flags...] "${variable_containing_target_name}" <<<"string to save to var"
		deletion:
			unset varname

		______________________________
		-0.2.0- expansions
			normal expansion:
				${varname}
			indirect expansion:
				${!varContainingVarName}
					NOTE: only 1 level of indirection is allowed
					save to tempvariable and reuse for more levels
					It does not work on arrays

				For indirect array, must use a temporary variable:
					arr=(1 2 3)
					arrname=arr
					tmp="${arrname}[@]"
					arrcopy=("${!tmp}")

			existence/emptiness expansions:
				${[expr1][:][op][expr2]}
					op:
						-    replace with expr2 if empty/unset
						=    replace and assign if empty/unset
						?    print expr2 as error message if empty/unset
						+    replace with expr2 if not set/non-empty
					:
						check emptiness instead of unset-ness

				expr1:
					arrvar[@]: check the array length always (${arr[@]-expr2})
					           Even if arr=(), so arr is set, expr2 is still used
					var: check the value of the var as a string
				expr2:
					arrvar[@]: expand to the array.
					           NOTE: an empty array will be expanded as a single empty string argument...
					           ex:
					              arr=()
					              defaults=()
					              bash -c 'echo $#' progname "${arr[@]:-${defaults[@]}}"
					              will print 1 argument instead of 0, even though all arrays are empty
					var: expand to the single item
				NOTE: for arrays, expansion is still as expected with @, * and quoting

			slicing (substring/subarray expansion):
				${param:offset[:length]}
				offset/length are arithmetic expressions and expanded as such
				negative values are indices from end of var
				offset >= 0 = number of chars
				offset < 0 = end position (exclusive)
					NEED A SPACE TO AVOID :- existence/emptiness expansions
					if using literal negative values

				If param is arraylike, then operate on items instead of chars.
					Also, negative length is not allowed.

			key/idx/prefix expansions
				${!prefix*}
				${!prefix@}
					sequence of varnames that begin with prefix

				${!arrname[@]}
				${!arrname[*]}
					sequence of keys/indices for the arrays

			length expansion
				${#param}       number of characters
				                number of items if param is an array-like
				                (eg @, *, arr[@], arr[*]...)
			deletion expansion
				see also -0.4- pattern matching
				${param#pattern}        delete from beginning (shortest)
				${param##pattern}       delete from beginning (longest)
				${param%pattern}        delete from end (shortest)
				${param%%pattern}       delete from end (longest)

			substitution expansion
				like regex but pattern matching instead
				${parameter/pattern/replacement}        single replacement
				${parameter//pattern/replacement}       global replacement
				${parameter/#pattern/replacement}       at beginning
				${parameter/%pattern/replacement}       at end

				If the /replacement is omitted, matches are deleted instead
			case expansion
				${parameter^pattern}
				${parameter^^pattern}
				${parameter,pattern}
				${parameter,,pattern}

				pattern should be single-char, and if omitted, defaults to ?

		______________________________
		-0.2.1- quoting
			Variable expansion quoting can be inside or outside the expansion
			and behaves slightly differently for arrays using [@] or [*]

			"${var}"          : quoted variable expansion as a single argument
			"${var:+a b c}"   : a single arg "a b c" if var is non-empty, else empty arg ''
			${var:+a b c}     : 3 args a b c if var is non-empty, else nothing
			${var:+"a b c"}   : 1 arg "a b c" if var is non-empty, else nothing
			"${var[@]}"       : `arraysize` args, even if args have whitespace
			"${var[*]}"       : a single arg regardless of whitespace
			${var[*]}         : arguments, also split on whitespace
			${var[@]}         : same as [*]

			NOTE quoting matters within expansions as well:
				x='*'
				y='*lhello'
				echo "${y##${x}l}"   #--> o
				echo "${y##"${x}"l}" #--> hello

				Unquoted, "${y##${x}l}" becomes "${y##*l}" so everything up to the last l is removed
				Quoted, "${y##${x}l}" becomes "${y##"*"l}" so a leading literal * followed by an l is removed.
					y=()
					x=(1 2 3)
					"${y[*]:-${x[*]}}"
						"1 2 3"
					"${y[*]:-"${x[*]}"}"
						"1 2 3"
					"${y[*]:-${x[@]}}"
						"1"
						"2"
						"3"
					"${y[*]:-"${x[@]}"}"
						"1"
						"2"
						"3"
					"${y[@]:-${x[*]}}"
						"1 2 3"
					"${y[@]:-"${x[*]}"}"
						"1 2 3"
					"${y[@]:-${x[@]}}"
						"1"
						"2"
						"3"
					"${y[@]:-"${x[@]}"}"
						"1"
						"2"
						"3"
		______________________________
		-0.2.2- scopes
			Scope determines where variables are visible.
			In general, there are 3 observed scopes.
			1: local
			   Local variables only exist for functions.  They
			   can only be seen within the function where they were
			   created as well as by any functions called from there.
			2: global
			   Global variables are seen everywhere.  They can be
			   shadowed by other variables.

			Assignment scopes:
				Assignments will result in a local or global variable, but
				behavior can differ.

				example:
					outer()
					{
						local localvar
						inner
					}
					innest() {
					}
					outer

				local assignment:
					local assignment always results in a local variable:
						local var=value     (only within a function)
						declare var=value   (if within a function)
					ex:
					inner() { local var=val; innest; }
					var is visible:
						1. within innest
						2. within inner, after local var=val;

					Note, local variables can exist on multiple levels.
					ex. outer() { local var; inner; }
					inner() { local var; }
					the var in inner is a different local variable to the var in outer.

				global assignment:
					Always results in global variable, will not modify any local
					variables.
						declare -g var=val
						declare var=val (if outside a function)

					inner() { declare -g var=val; innest; }
					var is visible:
						1. within innest
						2. within inner, after declare -g var=val
						3. within outer after inner
						4. within the script, after outer

				natural assignment:
					Natural assignments will assign to the first local variable looking
					through ancestor scopes.  If none are found, then the variable will
					become global.
					examples:
						var=val
						eval "${varname}=${val}"
						printf -v "${varname}" '%s...' "$[val}" ...
						read "${varname}" <<<"${val}"
						declare -n ref="${varname}"; ref="${val}"
							NOTE: 'ref' is a name reference variable. ref itself is a local
							variable, but varname, the referenced name will be assigned
							naturally

					ex1:
						inner() { var=val; innest; }
						var is visible:
							1. within innest
							2. within inner, after var=val
							3. within outer, after inner
							4. within the script, after outer

					ex2:
						inner() { localvar=val; innest; }
						var is visible:
							1. within innest
							2. within inner, after localvar=val
							3. within outer, (note that changes by inner will be visible
							   after the inner call)

		______________________________
		-0.2.3- strings
			operations
				version 5.1+
					${var@op}
						ops:
							U to uppercase
							u capitalized
							L to lowercase
							Q quoted format (like printf %q)
							E expand backslash escape sequences
							P expand as if prompt string
							A creation command to recreate the var
							K same as Q except arrays->quoted key value pairs
							a "string consisting of flag values representing parameter's attributes"

		______________________________
		-0.2.4- numbers

		______________________________
		-0.2.5- arrays
			index arrays (int keys)
				creation:
					name[subscript]=value           create array+initialize single value
					declare -a name                 create empty array
					declare -a name[subscript]      same as above
					name=(val1 val2 val3 ...)       create/initialize array
					name=([key]=val [key]=val)      if key omitted, then place val
					                                after previous item in list
			expansion
				Expand arrays by indexing with [@] or [*]
				ex:
					${arr[@]}
					${arr[*]}
				If unquoted, normal word-splitting is used.
				If quoted, * results in a single string of items joined by space.
				           @ results in multiple arguments, one per index.

			adding items
				arr+=(stuff to append to arr)

			associative arrays (str keys)
				declare -A name                   associative array
				name=(key val key val...)         odd number assumes last value is empty str
				name=([key]=val [key]=val)

			indexing:
				subscripts are treated as arithmetic expressions
					ex:
						a=1
						${arr[a]} is the same as ${arr[$a]}
				(as if within $[])
				@ as subscript = all (separate words) * = all(single word)
				(index arrays only)
					negative indices are incremented by maxidx+1 (-1 = last item)

			getting info:
				get keys/idxs:
					${!arr[@]}
				get number of items (regardless of contiguity)
					${#arr[@]}

			deleting items
				unset arr[idxOrKey]

		______________________________
		-0.2.6- ANSI-C quoting
			Not really a variable, but putting it here because similar syntax
			Ansi quoted strings:
				escapes:
					$'\escape'
					ex:
						$'\r\n'
				byte:
					$'\ooo'         octal (1-3 digits)
					$'\xhh'         hex (1-2 digits)
					$'\uhhhh'       unicode hex (1-4 digits)
					$'\Uhhhhhhhh'   unicode hex (1-8 digits)
				control sequence:
					$'\cx'          control+x

		______________________________
		-0.2.7- special variables
		Bash has some special variables defined/?updated? by bash:
		SHLVL           The number of nested bash shells
		FUNCNAME        Array of functions being run. This is like a stack trace, 0 = current, 1 = parent, etc
		BASH_SOURCE     Array of source files per function in FUNCNAME
		BASH_REMATCH    Array of (fullregexmatch, group1, group2, ...)
		EPOCHREALTIME   floating point timestamp
		EPOCHSECONDS    seconds precision timestamp


	______________________________
	-0.3- functions
		defining functions:
			[function] funcname() {
				body
			}
			(function keyword is optional)

		functions run in the current shell (its variables will bleed out
		to caller, unless declared as local)
			arguments are same as scripts, ${1-9}, ${@}, shift, etc

		______________________________
		-0.3.1- function outputs
			Functions do not have an explicit output method.
			The `return` keyword for functions gives the function's exit code.
			There are various methods to return a value:
				(useful source: https://stackoverflow.com/a/55331060)

				1. echo and use command substitution.
				   funcname() { echo result; }
				   output=$(funcname args...)
				   echo "${output}"

				2. fixed variable
				   Use a fixed variable name as the function output.  This is
				   also a simple solution but might result in name clashes.

					 funcname() { FIXED_OUTPUT_VAR=result; }
					 funcname
					 output="${FIXED_OUTPUT_VAR}"
					 echo "${output}"

				3. Use an associative array and output to a key.

				   declare -A OUTPUTS_ARRAY
				   funcname() { OUTPUTS_ARRAY["${1}"]=result; }
				   funcname output
				   echo ${OUTPUTS_ARRAY['output']}

				4. Use an variable output variable
				   Pass the name of the output variable to the function.  The
				   function sets the value.

					4.1 printf (bash version 3.1)
					    the -v argument will set the variable to the result
					    instead of printing to stdout.

					    funcname() { printf -v "${1}" "%s" result; }
					    funcname output
					    echo "${output}"

					4.2 read
					    read already saves to variable but uses stdin.  Use a
					    herestring.  NOTE: herestrings automatically add a
					    newline.  If the result might have a newline then extra
					    processing might be needed.

					    funcname() { IFS=$'\n' read "${1}" <<<result; }
					    funcname output
					    echo "${output}"

					4.3 declare (bash version 4.3)
					    The -n argument creates a nameref.  Use the nameref to
					    assign the values.  Note that the output var name must not
					    clash with the internal nameref variable name or a
					    circular reference will be created.

					    funcname() { declare -n out="${1}"; out=result; }
					    funcname output
					    echo "${output}"


			Comparisons:
				safety:
					Variable output variables all have code injection
					vulnerability.  Setting the output variable to
					'x[$(injected code here)]' will cause the injected code to
					run, but built-in read already has this vulnerability as well,
					so maybe it's acceptable/can be ignored?

					The fixed output varnames/echo methods do not have this issue.

				speed:
					fixed variable output is the fastest followed by array.
					Next is printf/declare, then read, and lastly echo.
					echo method uses IO as well as subshells so is the slowest.
					read uses IO so is slower than the others.

				nameclashes:
					echo has no name clashes since there are no variables.
					Fixed output might have name clashes.  Variable output
					vars can avoid name clashes as long as the right variable
					is chosen.

				The fixed output var method is the output method for
				programmable bash completion (COMPREPLY etc) so maybe this is
				generally the best choice?

	______________________________
	-0.4- pattern matching
		*: any length of any char
		?: any single char
		[...]: any enclosed char
			ranges are allowed (ascii)
			negated with ! or ^
			-: must be 1st or last to match
			]: must be first to match
			character classes:
				alnum   cntrl   print   word
				alpha   digit   punct   xdigit
				ascii   graph   space
				blank   lower   upper
			[=<thing>=]: equivalence class (eg. a or accented a, etc)
			[.<thing>.]: collating class (like the ae in encyclopaedia)

		extended pattern matching
			requires shopt extglob
			?(pattern-list)   zero or one of patterns
			*(pattern-list)   zero+ of patterns
			+(pattern-list)   one+ of patterns
			@(patternlist)    exactly one of patterns
			!(pattern-list)   none of patterns

	______________________________
	-0.5- shopt
		(shell options) optional shell behavior
		shopt [-pqsu] -o [optname...]
			-s        set
			-u        unset
			-q        quiet, use returncode to check status
			-p        print options
			-o        restrict to set -o values

		options:
			assoc_expand_once
			autocd                    use directories as cd
			cdable_vars
			cdspell                   allow minor mispelling for cd
			checkhash
			checkjobs
			checkwinsize
			cmdhist
			compat[31|32|40|41|42|43|44]      compatibility modes
			complete_fullquote
			direxpand
			dirspell
			dotglob                   include .files in globbing
			execfail
			expand_aliases
			extdebug
			extglob                   extended pattern matching
			extquote
			failglob                  unmatched patterns result in error
			force_fignore
			globasciiranges
			globstar
			gnuerrfmt
			histappend
			histreedit
			histverify
			hostcomplete
			huponexit
			inherit_errexit
			interactive_comments
			lastpipe
			lithist
			localvar_inherit
			localvar_unset
			login_shell
			mailwarn
			no_empty_cmd_completion   do not do completion on empty command
			                          This generally causes hanging for an excessive
			                          duration.
			nocaseglob
			nocasematch
			nullglob
			progcomp
			progcomp_alias
			promptvars
			restricted_shell
			shift_verbose
			sourcepath
			xpg_echo
	______________________________
	-0.6- brace expansion
		brace expansion generates sequences and is performed FIRST
		before anything else
		{a,b,...}:    repeat expression replacing with each a,b,...
		{a..b[..c]}:  iterate from a to b with step c if given, else 1
		              negative values work, step is abs-valued and direction
		              is determined by a to b.  {0..-10..2} will expand to
		              0, -2, -4 ... -10 bounds are inclusive.
		              prefixing with 0 will cause 0-padding for numbers
		ie:
		ls /some/dir/{a,*.x} -> ls /some/dir/a /some/dir/*.x
		and then /some/dir/*.x will be globbed

		nesting is allowed:
			{a{1..3},b{2..3}} -> a1 a2 a3 b2 b3
	______________________________
	-0.7- configuration files
		LOGIN shell: login from somewhere else
			/etc/profile
			first of:
				~/.bash_profile
				~/.bash_login
				~/.profile

		else if NON-LOGIN interactive shell: takes user input
			reads the .bashrc

		ONLY 1 file is sourced.
		the login files generally should set up the environment.
		interactive (.bashrc) should set up interaction:
			color
			aliases
		Because only 1 is sourced, login shells do not automatically
		source .bashrc even if they are also interactive.  This is why
		.profile/.bash_profile by default usually source .bashrc.

		summary:
			in .bashrc: check if interactive, return otherwise:
				[ -z "${PS1}" ] && return
					or
				[[ "$-" = *i* ]] || return
			in .profile, set your environment vars and add:
				if [ "$BASH" ] && [ -f ~/.bashrc ]; then . ~/.bashrc; fi
			In .bash_profile you can just source .profile, add any
				bash-unique settings or whatever.  Otherwise, you could also
				just delete this since .profile will be used in that case.
	______________________________
	-0.8- inputs
		read varname
			useful options:
				-u(fd)  read from filedescriptor instead (needs to end with
				        delimeter (default newline))
		readarray arrayname
			read items into an array
			useful options:
				-t  trim the delimiter

		heredocs
			someCommand << FILE_DELIMITER_OF_YOUR_CHOICE
			text etc
			can also use variables:
			$var1
			FILE_DELIMITER_OF_YOUR_CHOICE

			NOTE:
				if vars are in quotes, will not expand
		herestring
			someCommand <<< stringvalue_or_dereference
			*NOTE:
			    herestring causes a new-line to be appended to the end
			    use echo -n if you don't want that

		command substitution
			`command`
			$(command)

		process substitution
			<(bash script)   treat output of command as a file/stream
			example:
				code:
					cat <( echo hello
					echo goodbye
					)
				result:
					hello
					goodbye
				code:
					cat <( echo hello \
					echo goodbye
					)
				result:
					hello echo goodbye

	______________________________
	-0.9- redirection
		syntax:
			[dst][direction] [src]
				dst:
					blank:        defaults to stdin if reading, stdout if writing
					fd
					{varname}     if opening: allocate an fd>10 and assign to varname
					              if closing: close the fd named by varname
					              redirection persists past command
					              (must manually manage)
				direction:
				    <           read
				    >           write
				    >|          clobber write
				    &>          both stderr and stdout
				    >>          append data
				    &>>         append both stderr and stdout
				    <>          both input/output (use > to close)
				    <<[-]word   heredoc, word is delimiter. If with -, ignore leading TABS
				    <<<         herestring

				src:
					${varname}    value of var
					filename
					&fd
					&${var}     value of var as fd
					&-    (closes the dst)
					&fd-  move the file descriptor
						NOTE: spaces are allowed between & and the following value
						    but not before.
					special filenames:
						/dev/stdin
						/dev/stdout
						/dev/stderr
						/dev/fd/<fd>
						/dev/tcp/host/port
						/dev/udp/host/port
		examples:
			{fd}<>myfile      open myfile for reading and save to variable "fd"
			>&"${fd}"         use fd as stdout
			{fd}<&-           close fd

		Create redirection in the current shell:
			exec <redirection expression>
		NOTE: while, for, if, until blocks can also have redirection
		      just add the redirection after the closing line of the block


		______________________________
		output
			SRC>DEST
				SRC:
					& : stdout and stderr
					FD: a filedescriptor (0-9)
					empty : defaults to 1 (stdout)
				DEST:
					FNAME : a file name
					&FD   : to file descriptor
		______________________________
		input
			DEST<SRC
				DEST:
					FD : a file descriptor (0-9) for the file
				SRC:
					FNAME: a file name
		______________________________
		pipe
			CMD1 | CMD2   redirects cmd1 stdout to cmd2 stdin
			CMD1 |& CMD2  redirects cmd1 stdout+stderr to cmd2 stdin
		______________________________
		input/output redirection is NOT recursive.
			1>2 2>something
				1 is stdout, 2 is stderr
				1 redirects to 2 (which is currently stderr)
				2 redirects to something (a file)
				processes' stdout goes to stderr and stderr goes to something
			2>something 1>2
				1 is stdout, 2 is stderr
				2 redirects to something
				1 redirects to 2, (which is currently something)
				processes' stdout and stderr both go to something
		______________________________
		exec
			exec
				dst
					defaults to stdin if direction is <
					defaults to stdout if direction is >
				direction
					< for read
					> for write
					<> for both
				src
					a filename
					a process substitution
					&fd
					&-    close the fd (to close read+write fd, just use > instead of <>)

	______________________________
	-0.10- [$][[]|[[]]|()|(())]
		______________________________
		-0.10.1- [] test
			the same as the `test` command.
			Note: [ is usually a program.  As a result, the space after
			      [ is required. Also, the space before ] is required.
			check type of path: [ <opt> path ]
				-f: file
				-d: directory
				-e: existing
			Compare values:
				=: streq
				!=: not streq
				-eq: int eq
				-ne: not int eq
				-gt: greater than
				-ge: greater equal
				-lt: less than
				-le: less equal
				-z: empty str
				-n: non-empty str
			logical operators:
				-a: and
				-o: or
				NOTE: no parentheses, so cannot do:
					(x -o y ) -a b
					must call separate times:
					[ x -o y ] && [ b ]
		______________________________
		-0.10.2- $[] arithmetic expansion (old)
			arithmetic evaluation.
		______________________________
		-0.10.3- [[]] test (extended)
			like [] but builtin and more features.
			is a keyword, means parsing is a bit different from []
			spaces are still necessary as with []
			(no filename expansion/word splitting)
			differences:
				logical and: &&, -a DOES NOT WORK (syntax error)
				logical or : ||, -o DOES NOT WORK (syntax error)
				<>         : lexicographical sort order with current local
				             NOT less than/greater than
				-eq evaluates hex/octal, etc
					parens are ok for grouping
				= compares string using pattern matching.  Pattern must be on
					righthand side.  Using quotes (both double and single) removes
					any special pattern meanings.
					eg.
						a*: a followed by anylength anythings
						a?: maybe an a
						[asdf]: any of a, s, d, or f
						'*': a literal *
				=~ Use regex matching, pattern still needs to be on right.
					Like =, when placed in quotes, everything is literal
		______________________________
		-0.10.4- () subshell
			run commands in a subshell (does not affect current shell)
		______________________________
		-0.10.5- $()
			command substitution.  Uses the command's stdout as a string.
		______________________________
		-0.10.6- (()) nonzero arithmetic expansion test
			arithmetic evaluation (int only)
			variables are auto-expanded, do not need $
			does math, exit code is truthiness of result
		______________________________
		-0.10.7- $(()) arithmetic expansion
			Same as (()), except evalutes to a string equal to the
			result of the expression.
		______________________________
		-0.10.8- <() process substitution
			process substitution.  Substitute stdout of the command as
			a file name.
		______________________________
		-0.10.9- {} command grouping
			group commands (still runs in current shell)
			COMMANDS MUST TERMINATE WITH A SEMICOLON inside the {}
		______________________________
		-0.10.10- ${} paramater expansion
			see -0.2- variables
______________________________
-1-regexp
	______________________________
	basic
		char: itself
		*: sequence of 0 or more of previous expr

		.: anything
		^: beginning if at beginning, else a ^
		$: end of line (if at end)
		[list]: any char in list
		[^list]: anything not in list

		GNU extensions:
		\+ : same as * but 1 or more
		\? : 0 or 1
		\{n\}: match n repetitions
		\{n,m\}: match between n and m repetitions
		\{n,\}: n or more repetitions
		\(regexp\): group
		reg1\|reg2: or
		\number   : n = 1-9, match previous group
		\n        : newline
		\char     : if char is special, use char, else
		            use \char

	______________________________
	extended regexp
		?, +, {}, (), | have special meaning by default
		                (need to backslash if want it to be literal)
		                (basic: need to backslash for special meaning)

	______________________________
	special classes
		[[:special_class:]]
		classes:
			alnum: alphanumerics
			alpha: alphabetical
			blank: space/tab
			cntrl: control characters (ascii 000-037, 177 etc)
			digit: digits
			graph: graphical (alnum + punct)
			lower: lowercase
			pirnt: printable
			punct: ascii punctuation
			space: space (tabs, formfeed, newlines, etc)
			upper: uppercase
			xdigit: hexdigits

	______________________________
	extensions
		\w: word
		\W: non-word
		\b: word boundary
		\B: not word-boundary
		\s: whitespace
		\S: not whitespace
		\<: word start
		\>: word end
		\`: start of pattern space (multiline, only 1st line whereas ^ is all lines)

	______________________________
	escapes:
		\a: bell
		\f: form feed
		\n: newline
		\r: carriage return
		\t: tab
		\v: vertical tab
		\cx: control-x
		\dxxx: decimal value (binary)
		\o: octal value (binary)
		\b: backspace (but conflicts with above \b so excluded for sed)

______________________________
-2- completion
https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html
	code into ~/.bash_completion
	use command name to determine completion for arguments

	Note that command name can also be an alias to activate completions
	for same command under different situations by using an alias instead.

	completion priority order:
		1:
			if empty:
				use any with -E option
			if a path:
				use for corresponding path
				use any with -D option
		2: glob expansions
		3: -w options (split by IFS, expanded etc)
		4: functions with -F invoked
		5: functions with -C invoked
		6: filtered with -X option
		7: prefix/suffix from -P and -S added to candidates
		8: if no candidates, -o dirnames supplied to complete,
			directory completion attempted
	______________________________
	builtins:
	compgen [option] [word]
		print completions for word
	complete [-abcdefgjksuv (these are -A <action> shortcuts] [-o comp-option] [-DEI]
		[-A action] [-G globpat]
		[ -W wordlist ] [-F function] [-C command] [-X filterpat]
		[-P prefix] [-S suffix] -pr [-DEI] [name...]

	options:
		-o <comp-option>
			bashdefault: use default when no matches
			default: use readline's filename when no matches
			dirnames: use dirname when no matches
			filenames: specify completions are filenames (so process like filenames), used with -F
			           adds / to directories after completion (doesn't affect compgen...)
			noquote: don't quote if filenames
			nosort: don't sort
			nospace: don't append space to end of the completion
			         ie: | is the cursor
			            cmd arg[tab] -> cmd complete|
			            vs
			            cmd arg[tab] -> cmd complete |
			plusdirs: add dir completion
		-p: print to reuse as input
		-r: remove specification for each name
		-D: Set this specification as the default. (For words after a command.)
		-E: Set this specification for empty commandline
		    (Truly empty, whitespace does not count as empty)
		-I: First word of the line or after delim (;|etc)
		    (ie. completion on the command)
			-DEI is order of precedence, if have multiple of these flags,
			only the highest precedence will take effect.  If want to assign
			to all 3 of them must use separate calls to complete.
		-A action
			Some actions have short-flags that can be used instead

			alias (-a): alias names
			arrayvar: array variable names
			binding: key binding names
			builtin (-b): names of shell builtin commands
			command (-c): command names.
			              This will also complete dirnamesi, aliases, functions.
			directory(-d): directory names
			disabled: disabled shell builtins
			enabled: enabled shell builtins
			export(-e): exported shell vars
			file(-f): file names
			function: shell funcs
			group(-g): group names
			helptopic: topics to help
			hostname: hostname from file specified by HOSTFILE var
			job(-j): job names
			keyword(-k): shell keywords
			running: running jobs
			service(-s): service names
			setopt: valid args to set -o
			shopt: option names accepted by shopt
			signal: signal names
			stopped: stopped jobs
			user(-u): user names
			variable(-v): shell vars
		-C: command to execute in subshell, output = completions
		-F: bash func called as:
			[func] [cmd] [word] [preword]
			  func: the function that is registered
			  cmd: the name of the command or
			       -E "_EmptycmD_" if -E, or "_InitialWorD_" if -I
			  word: the current word
			  preword: the word before current word
			  ex:
			      python -m asdf[tab]
			      -> $1 = python
			      -> $2 = asdf
			      -> $3 = -m
			COMP_LINE: current commandline
			COMP_POINT: index of cursor relative to beginning
			COMP_KEY: key used to invoke completion
			COMP_TYPE: int that determines completion situation

				Remeber that COMP_TYPE is set before the completions are returned.

				COMP_TYPE char    ambiguous unmodified  desc
				9         TAB     off       off         normal completion (first tab)
				33        !       on        any         readline show-all-if-ambiguous is set initial tab
				37        %       any       any         Always given when menu-complete command.
				                                        ambiguous/unmodified change what is displayed on
				                                        the initial tab.  Subsequent tab always loops
				                                        through the given initial choices.
				63        ?       any       any         may follow after 9, 33, or 64, only after
				                                        no changes are made (no longer common prefix)
				64        @       off       on          show-all-if-unmodified is set.  initial tab.
				NOTE: after a delay, tab completion will "reset"

				settings:
					Bindings can be to `complete` or `menu-complete` to trigger the
					different completion mechanisms.

					show-all-if-ambiguous: on or off
														show-all-if-

					cases:
						m: multiple choices, extra completion up to common prefix
						p: multiple choices, already prefix completed
						o: one choice, has completion space
						s: one choice, no completion space(already complete)
						z: zero choices, no completions
					observations: on partial completion, tab is reset and must be pressed again
					to create the "same choice" condition, only afterwards would be COMP_TYPE 63

					method            ambiguous   unmodified  COMP_TYPE   case
					`complete`        on          any         33          m: prefix+display+reset
					                                                      p: display+reset
					                                                      o: prefix
					                                                      s: nothing
					                                                      z: nothing
					                                          63          m: n/a
					                                                      p: display+reset
					                                                      o: n/a
					                                                      s: display+reset
					                                                      z: nothing
					                  off         on          63          m: na/
					                                                      p: display+reset
					                                                      o: n/a
					                                                      s: display+reset
					                                                      z: nothing
					                                          64          m: prefix
					                                                      p: display+reset
					                                                      o: complete
					                                                      s: nothing
					                                                      z: nothing
					                              off         9           m: prefix
					                                                      p: nothing
					                                                      o: prefix
					                                                      s: nothing
					                                                      z: nothing
					                                          63          m: n/a
					                                                      p: display+reset
					                                                      o: n/a
					                                                      s: display+reset
					                                                      z: nothing
					`menu complete`   on          any         37          m: prefix+display+reset
					                                                      p: display+reset
					                                                      o: prefix
					                                                      s: nothing
					                                                      z: nothing
					                  off         any         37          m: prefix
					                                                      p: nothing
					                                                      o: prefix
					                                                      s: nothing
					                                                      z: nothing
				descriptions from:
				https://unix.stackexchange.com/questions/250262/how-to-use-bashs-complete-or-compgen-c-command-option
				TAB     normal completion
				!       listing alternatives on ambiguous completion
				%       menu completion
				?       tabbing between ambiguous completions
				@       list completions after partial completion

				https://unix.stackexchange.com/questions/614123/explanation-of-bash-completion-comp-type
				!       show-all-if-ambiguous
				@       show-all-if-unmodified
			functions only:
				COMP_WORDS: array of current commandline
				COMP_CWORD: index of current word in COMP_WORDS
				COMPREPLY : the completion candidates
				            An empty string will be completed as if it is the
				            same as the current word except when displayed,
				            for example, by show-all-if-ambiguous or multitab.
				            Any non-empty string will replace current word.
				            Duplicates will be merged into a single value.
				            The empty string shares a prefix with all other
				            strings(empty prefix).  As a result, no change in the
				            current word will happen if empty string is in
				            the list with some other non-empty string.
				            Thus, returning COMPREPLY=('' ' ') act like the 'p' case
				            in the above table and the displayed choices are all
				            blank/invisible.  The prompt will also be redrawn.

				            ex:
				            COMPREPLY=('')
				                current word is completed as is (adds a space if nospace is not set)
				                note that it DOES NOT replace the current word with nothing.
				            COMPREPLY=(' ')
				                current word is replaced with a single space
				            COMPREPLY=('' ' ')
				                current word is unchanged, may display an empty line printing out
				                the 2 choices: '' and ' '

			              ANSI keycodes in COMPREPLY are printed as visible chars
			              ex. escape ($'\e') will be printed as '^['

		-G pat expand for completions
		-P: prefix prepended to completion results
		-S: suffix to append to completion results
		-W 'wordlist' (split by IFS)
			list of words split by IFS to be used as completion
			"Shell quoting is honored within the string, in order to provide a
			mechanism for the words to contain shell metacharacters or characters
			in the value of IFS. Each word is then expanded using brace expansion,
			tilde expansion, parameter and variable expansion, command substitution,
			and arithmetic expansion, as described above (see Shell Expansions)."
			basically, can use variables to avoid IFS clashes

			a=$(printf 'hello\nworld')
			-W '"${a}" other words'-> 3 items
				1: hello
				world
				2: other
				3: words
			sidenote: IFS=\n ->
				IFS='
				'
				IFS=$'\n'
				IFS=$(printf '\n\b')
		-X: remove matches to pattern
			prepend with a ! to remove non-matches
			& is substituted with curword (escape with a \ for literal &)
	NOTE:
		pats (-G, -W, -X) should be quoted

	example using -F method:
		compfunc () {
		    do stuff
		}
		complete -o filenames -o nospace -o bashdefault -F compfunc cd
______________________________
-3- ps1 (prompt)
	escapes:
		\a          bell
		\d          date (weekday, month, date)
		\D{format}  date format (strftime)
		\e          escape (033)
		\h          hostename to first .
		\H          host name
		\j          current number of jobs
		\l          shell device name
		\n          new line
		\r          carriage return
		\s          name of shell
		\t          time HH:MM:SS (24hr)
		\T          \t, (12hr)
		\@          HH:MM (12hr)
		\A          HH:MM 24hr
		\u          username
		\v          bash version
		\w          working directory
		\W          basename of working dir
		\!          history number for this command
		\#          command number of command
		\$          # if uid 0 (root) else $
		\nnn        octal character code
		\\          backslash
		\[          begin non-printing characters
		\]          end non-printing characters
		\e[stuff    code for formating color, bold, underline, etc
			\033[stuff
			          stuff:
			            [code];[code]...m

			(use echo -e to check colors)
			note: \[ and \] should be used around the color code stuff

	format codes:
		\e codes
			0         full reset

			1         bold
			2         dim
			4         underlined
			5         blink
			7         reverse (foreground/background)
			8         hidden (passwords)

			2X        reset corresponding value 1-8

	color codes:
		XY          X: foreground/background, light/dark
		                            dark      light
		            foreground      3         9
		            background      4         10


		            Y: color
		            0   black
		            1   red
		            2   green
		            3   yellow
		            4   blue
		            5   magenta
		            6   cyan
		            7   white
		            9   default

		38;5;X      88/256 color for foreground, X = 1-256 (no leading 0)
		48;5;X      88/256 color for background, X = 1-256 (no leading 0)
______________________________
-4- various utilities
	______________________________
	-4.1- text manipulation
		______________________________
		-4.1.1- cut
			cut columns
			cut -d ''   use null as delimiter (can use $'\0' too if supported)
		______________________________
		-4.1.2- paste
			join files as columns

		______________________________
		-4.1.3- sed
			______________________________
			options:
				-n, --quiet, --silent
					suppress output

				-e
					script expression

				-f
					script file

				-i
					edit in-place

				-l N
					length for l command

				-b, --binary
					binary mode

				-E, -r, --regexp-extended
					extended regexps

			______________________________
			script:
				[addr]X[options]
				______________________________
				addr:
					optional
					indicate range in file to operate on (inclusive)
					format = START,STOP
						possible values:
						integer: line number n (start at 1)
					/exp/f      : exp = regexp (all lines that match),
					                NOTE:
					                / can also be any \char ie
					                \;regexp;
					              f: GNU extension
					                 I: case insensitive
					                 M: multiline

					!           : not in address space
					              ie:
					                1,5!p (don't print lines 1-5)
					n~step      : start at n, then take steps
				______________________________
				commands:
					q             : quit (only takes a single address)
					s/a/b/f       : substitute a with b, flags = flags
					                /: usually /, but can actually be any character
					                   (will need \ if want to use it in expression or replacement)
					                a: regexp expression
					                b: can contain \N: N=1-9 reference to previous \(\) match
					                               & : whole matched portion
					                               GNU sed extension:
					                               \L: lowercase until \U or \E
					                               \l: next into lowercase
					                               \U: upper until \L or \E
					                               \u: next to uppercase
					                               \E: stop case conversion
					                f: flags
					                   g      : globally
					                   n      : a number, replace the nth match
					                   P      : print new pattern space
					                   w fname: write to filename
					                   i/I    : case insensitive
					                   m      : GNU extension, multiline

					a text        : append text after line
					c text        : replace region with text
					i text        : insert text before line
					F             : print filename of current file
					w fname       : write patternspace to filename
					z             : empty pattern space
					{cmd1;cmd2...}: group of commands (use same address space)
					y/a/b/        : like tr (ab = string of chars)
					                if char == a[i], then replace with b[i]
					l n           : print unambiguously (blankspace print with escaped values), n = wrap length
					                n = GNU sed extension
					r fname       : insert file contents

					#pattern-space related
					d             : delete pattern space
					g             : replace patternspace with hold space
					h             : reploace hold with patternspace
					n             : replace patternspace with next line of input
					p             : print pattern space

					D             : delete patternspace up to first newline
					G             : appends line from hold space to pattern space with newline before it
					H             : appends line from patternspace to hold space with newline before it
					N             : appends next line from file with \nbefore it
					P             : prints line from patternspace til first newline

			______________________________
			execution
				2 data buffers: "pattern space", "hold space"
				steps:(in python)
				f = file(fname, 'r')
				pattern = ''
				hold = ''
				while more_lines():
				    l = f.readline()
				    pattern = l.strip()
				    execute_commands(pattern_space)
		______________________________
		-4.1.4- grep
			--color=auto
			see -4-regexp
			-A[n] print n lines after matches
			-B[n] print n lines before matches

			useful options:
				-v: inverted search (print things that don't match)
				-F: interpret pattern as list of literal string patterns
				-f: use file to get patterns
				-x: match entire line (automatically surround pattern with ^$)
				-i: ignore case
				-n: line number
				-r: recursive
				-m: max-matches
				-z: change entire file into a single line

			can also use with find to make it recursive and control depth:
			find . -maxdepth blah -mindepth 1 -type f -exec 'grep pattern {}'
			grep pattern $(find . -maxdepth blah -mindepth 1 -type f)
	______________________________
	-4.2- drives and devices
		______________________________
		-4.1.1- lsblk
			lsblk: list block devices
		______________________________
		-4.1.2- blkid
			blkid: list blkid (UUID, partition types etc
			   can use for editing /etc/fstab

			   fstab:
			       entry:
			           device   mountpoint   filesystemType   options  dump  pass
			               device (/dev/XXX or UUID=SOME_BLOCK_DEVICES_UUID_NO_QUOTES)
			               mountpoint a path in the file system (/media/myblkdevice)
			               filesystemType: like nfat, ntfs, ext4, vfat, auto, etc
			               options: see below
			               dump: enable/disable backups (0 is usual (disabled))
			               pass: fsck check partition for errors on boot?
			                     root device = 1, other = 2(if check) or 0 (don't check)

			           options:
			               defaults    : (rw, suid, dev, exec, auto, nouser, async
			               sync/async  : how IO to filesystem should be done
			               auto/noauto : fs is automatically mounted on boot
			               dev/nodev   : interp or don't interp block special devices on filesystem
			               suid/nosuid : permit/block suid and sgid bits operations
			               ro          : mount read-only
			               rw          : mount read-write
			               user        : any user can mount filesystem (implies noexec, nosuid, nodev)
			               nouser      : only root can mount

		______________________________
		-4.1.3- df
			df: show disk info
		______________________________
		-4.1.4- mount
			mount: (sudo only)
			       ex: mkdir mountpoint1
			           sudo mount device_from_lsblk mountpoint1
			       (can now access device_from_lsblk at mountpoint1,
			        such as usb etc)
		______________________________
		-4.1.5- umount
			umount

	______________________________
	-4.69- others
		______________________________
		-4.69.1- shuf
			shuf->shuffle lines in a file (ex training list)

		______________________________
		-4.69.2- tput
			ncurses tool for interacting with terminal

			tput <command>

				longname    print long name of terminal
				lines       number of lines
				cols        number of cols
				lines       number of lines
				colors      number of colors
		______________________________
		-4.69.3- stty
			Tool for changing terminal settings
				stty size   prints current size of terminal
				stty sane   sets some terminal settings to default values.


______________________________
-5- tips/tricks
	______________________________
	-5.1- reset
		sometimes if accidentally cat binary or something, terminal may become messed up.
		try these to reset the terminal:

			stty sane   sets some terminal settings to default values.
			reset       (tset)reset the entire terminal (as if reopened from scratch)
			tput reset  man says uses reset from tset

------------------------------
-6- builtins
	------------------------------
	-6.1- printf
	printf using a format and arguments.
	undocumented:
		Convert a character into an int/unicode code point
		Use the %d/%i, argument should be single quote followed
		by a character.  Only the first character is converted.
		Other characters are ignored.
		eg.
			printf '%d' "'c"
			99

			somevar='hello'
			printf '%i' "'${somevar}"
			104

			printf '%i' "'你"
			20320
