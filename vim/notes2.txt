https://www.linux.com/learn/vim-101-beginners-guide-vim
NOTE: cygwin vi uses .virc not .vimrc

# reorganized now that I have some more experience

###############################
# contents:
###############################
-1- normal mode
    -1.1- movement
    -1.2- viewports, tabs
    -1.3- changing modes
    -1.4- editing
    -1.5- searching
    -1.6- file manipulation
    -1.7- other
-2- insert mode
-3- visual mode
-4- command line (:)
    -4.1- search and replace
    -4.2- files
    -4.3- views, tabs
    -4.4- settings
    -4.5- other
-5- config files
-6- other
    -6.1- indentation
    -6.2- registers
    -6.3- marks
    -6.4- macros
    -6.5- jump list
    -6.6- functions
        -6.6.1- variables

##############################
-6- other
##############################
    ------------------------------
    -6.3- marks
    ------------------------------
        m[a-zA-Z]       set mark
        `[a-zA-Z]       go to mark (exact)
        '[a-zA-Z]       go to first non-whitespace character on same line
        :marks          list marks
        ______________________________
        special marks
            .       : last edit
            []      : beginning/end of yanked/pasted selection
            <>      : first/last line of visual selection
            '       : before last jump
            "       : last position before file was closed
            ^       : last positon insert mode (same as gi except don't enter insert mode)





    ------------------------------
    -6.4- macros
    ------------------------------
    ------------------------------
    -6.5- jump list
    ------------------------------
        commands:
            :jumps          show jump list
            :clearjumps     clear jump list

        see -1.1.1-

    ------------------------------
    -6.6- functions
    ------------------------------
    function Functionname(args)
    endfunction

    FUNCTION NAME MUST BE CAPITALIZED

    if
    elseif
    else
    endif

        ------------------------------
        -6.6.1- variables
          a:  arg of function
          g:  global
          l:  local to function
          b:  current buffer

        let var = val
        let b:var = buffer-local-value
        let [v1,v2,v3]=[v1,v2,v3]

        pseudovars:
          &var      get local OPTION if available else global
          &l:var    get local value of OPTION
          &g:var    get global value of OPTION
          @var      get register value
          $var      get environmentvar

        {var}rest: var gets evaluated and then the rest
                  example:
                  var = expand
                  {var}tab = expandtab as variable

                  does not seem to work with pseudovars

    exists("name"): checks if variable is defined

    call functions with :call
    use :<C-U>call FuncName(v:count) to pass prefix to function
        example:
            nnoremap <my><remapping> :<C-U>call MyFunctionName(v:count)
            v:count: prefix, default 0
            v:count1: prefix, default 1

        in strings, use \<escape seq> to represent the character
        example: append "hello world" to the end of the line
            execute "normal Ahello world\<esc>"

            use . to concatenate strings

        execute: run a string as a command
            example: add ${arg} spaces
                execute "normal " . arg . "a \<esc>"


        variable coercion:
            like integer promotion but applied to strings too
            int + float->float

            str + num -> num (even if str is a float str)

            str . num -> str
