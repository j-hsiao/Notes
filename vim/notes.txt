contents:
-0- general
  -0.1- starting vim
  -0.2- terminology
  -0.3- regex
-1- normal mode
  -1.1- movement
  -1.2- scrolling
  -1.3- editing
  -1.4- jumps
  -1.5- marks and registers/macros
  -1.6- folding
  -1.7- windows, viewports, tabs
  -1.8- searching
  -1.9- others
-2- insert mode
-3- visual mode
-4- command mode
  -4.1- :help
  -4.2- :set
    -4.2.1- indentation
    wmnu
    list and lcs
  -4.3- files/buffers
  -4.4- searching
  -4.5- windows/tabs
  -4.6- others
-5- vim scripts and config files
  -5.1- variables
  -5.2- functions
-6- useful topics
  -6.1- macros
  -6.2- registers
  -6.3- remapping/binding keys
  -6.4- viewports and tabs
  -6.5- file manipulation
  -6.6- indentation

Vim is a modal editor.  In general, vim has normal, insert, visual,
and command modes each with their own functionalities.

______________________________
-0- general
  ______________________________
  -0.1- starting vim
    vim/vi can be started by vim <file1> <file2>...
    useful commandline arguments:
      -u <file|NONE>        use <file> instead of ${HOME}/.vimrc for
                            initialization.  If NONE, no initialization.

  ______________________________
  -0.2- terminology
    buffer: A buffer of text, usually representing/backed by a file.
    window: The terminal window
    viewport:   A visual section of the window usually associated with a
                buffer.
    tab:    A set of viewports to be displayed.  Only 1 tab is visible
            at a time.
    cursor: The indicator for your current location.

  ______________________________
  -0.3- regex

    repeat specifiers for pattern-atoms
      *         0 or more greedy
      \+        1 or more greedy
      \=        0 or 1, as many as possible
      \?        same as = but cannot be used when using ? to search
                backwards
      \{n,m}    match n to m reps, greedy. n defaults to 0
                m defaults to infinite
      \{-n,m}   same as above but as few as possible

    :h pattern-atoms
    pattern-atoms of interest:
      groups:
        \(<pat>\)   store pat as a group, available for back-reference
                    via \<num>
      character classes
      invert letter case to invert match
      ie: \s = whitespace, \S = not whitespace
        \s      whitespace
        \d      digit
        \x      hex-digit
        \o      octal digit
        \w      word
        \h      head of word
        \l      lowercase
        \u      uppercase

      escapes:
        \e          <Esc>
        \t          <Tab>
        \r          <CR>
        \b          <BS>
        \n          end-of-line (search) or null byte (replace)
        \<          beginning of word
        \>          end of word
        \z<s|e>     start|end of replacement pattern.  Anything outside
                    of these will be matched but not replaced

      [<stuffs>]  any character in <stuffs>
      [^<stuffs>] any character NOT in <stuffs>

        character classes for use in []: ([:<class name>:])
          alnum     graph   upper   backspace
          alpha     lower   xdigit  ident
          blank     print   return  keyword
          cntrl     punct   tab
          digit     space   escape




______________________________
-1- normal mode
  Normal mode is generally the default mode when vim is opened.  It is
  used for seeking, deleting, copy/cut/paste, macros, viewports, etc.
  Escape can spammed repeatedly to reach normal mode.

  Commands can usually be prefixed with a number to act as an argument.
  Arguments will generally be interpreted as a repeat-count or a line
  number.
  ______________________________
  -1.1- movement
    hjkl            left, down, up, right 1 char respectively (same column)
    gj|gk           move down|up a visual line (when linewrapping)
    <space>         forward 1 char (linewraps)
    <backspace>     backward 1 char (linewraps)
    0               beginning of line
    $               end of current line
    w               beginning of next word
    e               end of next word
    b               beginning of previous word
    |               Go to Nth column, defaults to 0
    <f|F><char>     go to next/previous instance of <char> on current
                    line excluding current character.
    <t|T><char>     go to just before the next/previous instance of
                    <char> on current line.
    ;               repeat the last f/F/t/T movement
    ,               repeat the last f/F/t/T movement in opposite direction
    HML             go to first,mid,last line on screen respectively
    _               first non-whitespace char on current line
    -               first non-whitespace char on previous line
    +               first non-whitespace char on next line

  ______________________________
  -1.2- scrolling
    C-f|C-d|C-e     down 1-screen|half-screen|1-line
    C-b|C-u|C-y     up 1-screen|half-screen|1-line
    z<t|z|b>        scroll current line to top|middle|bottom of screen
    z[H|L]          scroll left|right half-screen
    z[h|l]          scroll left|right char
    z[s|e]          scroll current column to left|right of screen
  ______________________________
  -1.3- editing
    Entering insert mode for typing:
      These commands enter insert mode after possible doing something.
      i         on cursor
      I         at beginning of line
      a|A       after cursor | end of line
      o|O       Insert a line below|above cursor
      r|R       replace a|many char
      c<motion> delete traversed text
      S|cc      delete N lines
      C         delete from cursor to end
      s         delete N chars
      gi        go to last insert mode and enter insert mode

    cutting/pasting
      NOTE: deletion generally adds the text to special register "
      d<motion> delete traversed characters
      dd        delete current line
      D         delete to end of line
      X|x       remove N chars before|on cursor
      P|p       paste N times on|after cursor
      y{motion} yank traversed characters.  Forward includes cursor.
                Backward excludes cursor.
      yy        yank current line

    indenting
      >>|<<     indent right/left by shiftwidth

    history (undo/redo)
      u         undo, repeat = change undo direction
      C-r       continue undo
                NOTE: in vim, if :set cpoptions? does not show a u flag
                  (the default?), then u is always undo and C-r is always
                  redo.  Otherwise, it follows the vi behavior above.
      .         redo last change

    other:
      J         join current and next N>2 lines

  ______________________________
  -1.4- jumps
    Jumping will append to a jump list which can be traversed.
    NOTE: jumplist can span files (if you jump to another file by global
    mark for example)

    C-o     previous jump in jumplist
    C-i     next jump in jumplist
    gg      JUMP to Nth line, defaults to first.
    G       JUMP to Nth line, defaults to last.
    %       JUMP to matching character of the next [](){} (starts on cursor)
    {}      previous/next blank line
    ()      beginning/end of N sentences
    []      JUMP to a section (see :h [)
______________________________
  -1.5- marks and registers
    Marks are named a-z (local) or A-Z (global) and represent a
    position in the file.

    m       Store the current position to a mark register.
    `       JUMP to mark (exact)
    '       JUMP to mark (first non-whitespace char of same line)

    special marks:
      .     last edit
      []    first/last line of last yanked/edited/pasted selection
      <>    first/last line of visual selection
      '     before last jump
      "     last position before file was closed
      ^     last position where insert mode was stopped (used by gi)

    Registers/macros have same naming convention as marks.  They
    can be used for yank/put, or as a key sequence for a macro.
      "         select a register (for yank/delete/paste)
      q         begin/end recording a macro
      @<reg>    Run the text stored in register as a macro

  ______________________________
  -1.6- folding
    Folds temporarily hide sections of the current file and may contain
    other folds.

    adding folds
      zf<motion>      add a fold from current line to the destination line.
    deleteing folds
      z<d|D>        delete 1/all folds under cursor
      zE            delete all folds everywhere
    opening folds
      z<o|O>        open 1/all folds under cursor
      z<r|R>        open 1/all folds everywhere
    closing folds
      z<c|C>        close 1/all folds under cursor
      z<m|M>        close 1/all folds everywhere
    moving to folds
      z<j|k>        JUMP to next|previous fold.
  ______________________________
  -1.7- windows, viewports, tabs
    :h ctrl-w

    Window commands are prefixed with C-w

    creating viewports:
      v         vertical split viewport
      s         horizontal split viewport
      f         split and open filename under cursor
      d         split and jumpt to definition (#define line)
      i         jump to declaration of identifier (where variable declared)
      n         new viewport

    closing viewports:
      q         quit viewport (exit if last window)
      c         close viewport (but not last window)
      o         close all but the current one

    resizing viewports:
      =         equalize viewport sizes
      |         change viewport width to N, defaults to screen width
      _         change viewport height to N, defaults to screen height
      +|-       increase|decrease height by N rows, default to 1
      >|<       increase|decrease width by N chars, default to 1

    moving viewports within a tab:
      H|J|K|L   move current viewport to far left|bottom|top|right
      r|R       rotate viewports positions down|up
      x         swap with viewport N, default next... but how to get viewport number?

    moving between viewports:
      h|j|k|l   move to the viewport to the left|bottom|top|right
      P         preview window??
      p         previous viewport
      C-w|w|W   next/previous viewport
      t|b       to top|bottom viewport

    new tabs:
      :tabn	command mode to create new tab
      T         move viewport to a new tab

    change tabs:
      g<t|T>	go to Nth(default=next)/previous Nth tab

  ______________________________
  -1.8- searching
    /|?<pat>    initiate forward|backward regexp search for <pat>
    n|N         go to next/previous search match (retain search direction)
    [           show/search/jump
      i|I       show first|all lines containing word under cursor
      (|{       to unmatched (|{

      c/c++ related:
        #       go to previous unmatched #if, #else, #ifdef
        d|D     show first|all "#define" for word under cursor
                so #   define does not get matched even though it would work
    ]
      )|}       next unmatched )|}
      c/c++ related:
        #       next unmatched #endif/#else

    *|#         search for word under cursor forward|backward (whole word)
    g<*|#>      search for word under cursor forward|backward
                (includes subword)

  ______________________________
  -1.9- others
    K       look up word under cursor as a "keyword" in keywordprg (default man)
    ZZ      save and close
    ZQ      :q!
    C-z     suspend
    C-g     buffer info: file, lines, etc
    g C-g   cursor position (col, line, word, bytes)
    C-<a|x> increment|decrement number under cursor

______________________________
-2- insert mode
  :h i_ctrl-l

  C-t|C-d       indent right/left by shiftwidth
  C-p|C-n       autocomplete with words before/after cursor
                use C-p/C-n to scroll through
  C-w           delete word before cursor
  C-u           delete all entered characters(like undo current edit)
  C-o           normal mode for 1 command then go back to insert mode
  C-\ C-o       same as C-o but "don't move cursor"???
  C-i           tab
  C-<p|n>       autocompletion with words before/after cursor
  C-r <reg>     insert register
  C-v key       literal key
  C-[ | <Esc>   exit insert mode
______________________________
-3- visual mode
  This mode is generally for selecting text to perform a command over.

  From normal mode:
    v{motion}   set mark
    V{motion}   set mark(whole linne)
    C-v{motion} set mark(rectangle)

  in general, commands for normal mode will be prefixed with the
  selected range.
  eg:
    select text -> r.   change all chars in selection to .
    select text -> d    delete all selected text.

______________________________
-4- command mode
  Enter command mode with :

  Command mode runs vim commands/functions.  These can generally be
  prefixed with a range to run the command on given lines.

  line number formats:
    <N>         line N
    .           current line
    $           last line
    %           all lines
    't          line containing mark
    'T          line containing global mark (must be in same file)
    /pattern/   lines that match regexp (after cursor)
    ?pattern?   lines that match regexp (before cursor)
    <spec>+-[N] one of above specifications +- N lines, N=1 if omitted

  A range can be specified by specifying 2 line numbers separated by a
  ',' or ';'. ',' moves the cursor, ';' does not.

  sidenote:
    when entering commandmode from visual mode with a selection,
    the range is shown as '<,'> which means from the < mark to the > mark
    (-1.5- <> = first/last line of visual selection)

  ______________________________
  -4.1- :help
    :h <thing>
      prefixes for <thing>:
        i_      insert mode
        v_      visual mode
        c_      command mode
        '       :set option
    C-]         jump to link
    C-t         previous topic


  ______________________________
  -4.2- :set
    ______________________________
    -4.2.1- indentation
      syntax:
        :set <option>=value     set option to value
        :set <option>           set boolean option to True
        :set no<option>         set boolean option to False
        :set <option>!          toggle boolean option
        :set <option>?          echo current option value

      related options:
        long            short   description
        ------------------------------
        softtabstop     sts     target destinations of tab key
        tabstop         ts      size of a tab character
        shiftwidth      sw      size of indentation
        autoindent      ai      copy indent of previous line when new line
        expandtab       et      use spaces instead of tab chars.

        If applicable, spaces will be converted to tabs once they
        reach tabstop
    ______________________________
    -4.2.2- visual changes
      ruler             ru      show cursor position in infoline
      number            nu      number lines
      relativenumber    rnu     number lines relative to cursor (current
                                line gets the absolute line number)
      hlsearch          hls     highlight search matches
      visualbell        vb      flash instead of beep
      wrap                      wrap long lines
      listchars         lcs     list chars for displaying invisible chars
      list                      use lcs to display invisible chars
      cursorcolumn      cuc     highlight cursor column
      cursorline        cul     underline cursor line

    ______________________________
    others
      ------------------------------
      insearch          is      find search matches as you type
      autochdir         acd     automatically change to viewport's directory
      belloff <when>    bo      don't ring bell when
      paste                     paste mode (turns off autoindent etc)
      ignorecase        ic      case-insensitive searching
      smartcase         scs     case sensitive if have caps
      wildmenu          wmnu    tab completion in commandline mode
      wildmode          wim     tab completion method:
                                up to 4 comma-delimited items of:
                                full            next full match
                                longest         complete til longest
                                longest:full    longest and full together
                                list            list matches
                                list:full       list and complete to first match
                                list:longest    list and up to longest common string
                                C-<n|p> to cycle through options.

  ______________________________
  -4.3- files/buffers
    :w <filename>       write to file
    :up[date]           write to file (if changed)
    :q                  quit current viewport
    :x                  save and quit
    :qa                 quit all tabs/windows
    :e <filename>       edit a file
    :o <filename>       open filename
    :b <bufname>        change to buffer
    :b<n|N>             go to next/previous buffer in list
    :b#                 go to alternate buffer(last-edited buffer)
    :bd <bufname>       close the buffer
    :ls :files :buffers list current buffers
                        % symbol = current buffer
                        # symbol = the alternate buffer

  ______________________________
  -4.4- searching
    :s/text/replacement/[gciI]  run search/substitution
                                g: all matches per line
                                c: confirm
                                i: case insensitive
                                I: case sensitive
  ______________________________
  -4.5- windows/tabs

    :split <filename>   split view horizontally opens file fn,
                        or current file if fn is absent
    :vsplit <filename>  split vertically, as above
    :tabe <file>        edit file in new tab
    :tabs               list tabs and viewports
    :tabc               close tab
    :tabo               make this the only tab (close all others)

  ______________________________
  -4.6- others
    C-d         list potential completions.  Use tab to scroll.
    ______________________________
    abbreviations
      Abbreviations will be expanded to rhs when typed.
      :ab[breviate]             list abbreviations
      :ab[breviate] lhs rhs     abbreviate rhs as lhs
      :ab[breviate] lhs         list abbreviation
      :una[bbreviate] lhs       remove abbreviation

    ______________________________
    miscellaneous
      C-f       open command window for editing commands
      :noh      stop search highlighting
      :Ex       open file explorer
      :sy[ntax] <on|off>  turn syntax highlighting on/off
      :source   run a vimscript file
      :sh       open a new shell.  Exit to go back to vim
      ! <cmd>   run a shell command.
      :w ! cmd  write range to stdin of shell cmd
      :r ! cmd  read stdout of shell cmd and insert into buffer
      :norm[al] <keyseq>        run keyseq as if in normal mode
      :g/pat/cmd        run cmd globally on lines matching pat
      :cd               change current working dir
                        %:h     current file's directory
                        -       previous dir



______________________________
-5- vim scripts and config files
  ______________________________
  -5.1- variables
  ______________________________
  -5.2- functions
    :h :key-notation
    no notes on casing for <C-key> notation

    :<C-u>call Function(v:count)
    <CR>: carriage return = return key
    <BS>: backspace = backspace key

  ______________________________
  -5.3- notable commands
    -5.3.1- let
      let var = ...
      let @<reg> = "register value"
______________________________
-6- useful topics
  ______________________________
  -6.1- macros
  ______________________________
  -6.2- registers
  ______________________________
  -6.3- remapping/binding keys

    list default bindings:
      :h index

    list mapped keybindings:
      :map list mappings
      :im[ap]
      :vm[ap]
      :nm[ap]
      :xm[ap]

  ______________________________
  -6.4- viewports and tabs
  ______________________________
  -6.5- file manipulation
  ______________________________
  -6.6- indentation




# ------------------------------
# contents
# ------------------------------
# -1- normal mode
#   -1.1- movement
#     -1.1.1- jumps
#     -1.1.1.1- marks
#   -1.2- editing
#   -1.3- viewports, tabs, folds
#   -1.4- search/replace
#   -1.5- file manipulation
#   -1.6- other
# -2- insert mode
#   -2.1- indentation
# -3- visual mode
# -4- command mode (:)
#   -4.1- ranges
#   -4.2- files
#   -4.3- viewports & tabs
#   -4.4- sed substitution
#   -4.5- set
#   -4.6- other
# -5- config files
# -6- other
#   -6.1- macros
#   -6.2- registers
#   -6.3- remapping keys
#   ------------------------------
#   -4.4- sed substitution
#   ------------------------------
#     s/pattern/replace/opt
# 
#       pattern: regex
#         . * \ [ ^ $ are meta characters
#         + ? | & {()} must be escaped to use meanings
# 
#         escapes:
#           \<                word start
#           \>                word end
#           \zs               match start NOT THE SAME AS  \(
#           \ze               match stop
#           \t                tab
#           \s                whitespace
#           \n                newline
#           \r                carriage return
#           \c / \C           ignore / match case (appear anywhere, applies to all)
# 
#       replace:
#         metachars:
#           &                 the match
# 
#         escapes:
#           \r                newline
#           \n                null byte
#           \0                entire pattern
#           \1...             back references
# 
#       opts:
#         g                   globally (all within a line, not just first occurrence)
#         c                   confirm
#         i                   case insensitive
#         I                   case sensitive
#   ------------------------------
#   -4.5- set
#   ------------------------------
#     set vim settings
#     :h option-summary
# 
#     add no to beginning to turn boolean setting off
#       useful settings
#         wic                   wildcard ignore case when opening file
#         wmnu                  file picking menu
#         wim                   wildmode
#         bo                    bell off
#         expandtab             expand tab to spaces
#         tabstop               width of tab
#         softtabstop           width when press tab
#         shiftwidth            indentation >> << iC-d iC-t
#         autoindent            match previous line indentation when starting new line
#         paste                 paste mode (no autoindent etc)
#         wrap                  wrap long lines
#         hls                   highlight matches
#         ignorecase            ignore case when searching
#         smartcase             adding caps causes case-sensitive searching
#         incsearch             incremental search (search as you type)
#         cul                   underline current line
#         cuc                   highlight current column
#         vb                    visual bell
#         so                    scroll offset, keep cursor N away from top/bottom
#         nu                    line numbers
#         rnu                   relative line numbers
#         fo                    format options
#                               ro: automatically continue comments after \r or o
# 
#     setl[ocal]: set only for current window (if has locality) otherwise all
#       scratch buffers (not saved etc)
#         buftype=nofile
#         bufhidden=hide
#         noswapfile
# 
#   ------------------------------
#   -4.6- other
#   ------------------------------
#     :noh                      stop highlighting search matches
#     :ab alias value           when typing alias, replace it with value
#     :una alias                unalias
# 
#     :ex                       file explorer
#     :syntax                   syntax highlighting
#     :source                   source a vimrc
#     :sh                       open a subshell (similar to C-z to access shell)
#                               but exit to get back to vim instead of fg
#     :!                        run command line with text as input
#                               display result
#                               (replace text range specified)
#     :w ! cmd                  write selection to cmd, display output
#     :r ! cmd                  insert data from cmd
#     :norm[al]                 run command as if in normal mode
#                               cursor starts at beginning of line
#                               ex:
#                                 :norm ihello world<esc>
#                                 will insert hello world
#     :g/pat/cmd                run command on lines matching pat globally
#     :jumps                    list jumps
#     :clearjumps               clear jumplist
# ------------------------------
# -5- config files
# ------------------------------
#   ~/.vimrc
#   loaded at startup
#   basically command-line mode without the :
# 
#   see also -4.5-
# 
#   let @[a-z]=macro: load macro into the register
#     (protip: record macro normally then paste macro "[key]p into vimrc)
# 
#   ftplugin:
#     filetype plugin on
# 
#     put filetype vim files in ~/.vim/after/ftplugin
#       example:
#         cpp.vim
#         text.vim
#         cmake.vim
#         ...
# ------------------------------
# -6- other
# ------------------------------
#   notes:
#     escape and C-[ are the same (type C-v esc and then C-v C-[ to see)
# 
#   ------------------------------
#   -6.1- macros
#   ------------------------------
#     q [a-z]           begin recording macro into register (see -6.2- registers)
#       q               end recording macro
# 
#     @ [a-z]           run the macro
# 
#   ------------------------------
#   -6.2- registers
#   ------------------------------
#     "[a-z]            select a register
#       y               yank to selected register
#       p / P           paste from selected register
#   ------------------------------
#   -6.3- remapping keys
#   ------------------------------
#     cmd atr lhs rhs
# 
#     cmd:
#       map           make default map, recursive
#       remap         same as above?
#       noremap       no recursive maps, all things literal
#       unmap         remove map
#       mapclear      clear all maps
# 
#       add appropriate modification (see :h key-mapping) for desired mode
# 
#     atr:
#       <buffer>      mapping only in current buffer
#       <nowait>      do not wait to see if more characters will be typed
#       <silent>      don't echo to command line
#       <special>
#       <script>
#       <expr>
#       <unique>
# 
# 
# 
# TODO:
#   :highlight
#   :match
#   :lcs
#   :list
# 
# 
# vimscript:
#   . concatenate strings
#   functions:
#     function Funcname(arg1, arg2,...)
#       body
#     endfunction
# 
#   strings:
#     . concatenation
# 
#   variables:
#     :h :let
#     let varname = expr          set/create the variable
#     let varname .= expr         append if str-like
#     let varname += expr         add
#     let varname -= expr         subtract
#     let [v1, v2, v3...] = {expr} unpacking
# 
#     let <varname> = <expr>
#     a:<name> function args
#     &l:<name> local option (for :set)
#     &<name> global option (for :set, includes local)
#     @<name> a register (ie "<name>P to paste the register)
# 
# 
# 
#   execute
