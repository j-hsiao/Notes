contents:
-0- general
  -0.1- starting vim
  -0.2- terminology
  -0.3- regex
-1- normal mode
  -1.1- movement
  -1.2- scrolling
  -1.3- editing
  -1.4- jumps
  -1.5- marks and registers/macros
  -1.6- folding
  -1.7- windows, viewports, tabs
  -1.8- searching
  -1.9- others
-2- insert mode
-3- visual mode
-4- command mode
  -4.1- :help
  -4.2- :set
    -4.2.1- indentation
    -4.2.2- visual changes
  -4.3- files/buffers
  -4.4- search/replace
  -4.5- windows/tabs
  -4.6- autocmd
  -4.7- map
  -4.8- others
-5- vim scripts and config files
  -5.1- variables
    -5.1.1- types
    -5.1.2- namespaces
    -5.1.3- curly-braces-names
    -5.1.4- operations
    -5.1.5- special variables:
  -5.2- loops
  -5.3- operator precedence
  -5.4- user defined functions

quick topics:
  registers, macros             -1.5-
  remapping/binding keys        -4.7-
  viewports/tabs                -1.7-
  file manipulation             -1.3-, -4.3-
  indentation                   -4.2.1-

Vim is a modal editor.  In general, vim has normal, insert, visual,
and command modes each with their own functionalities.

______________________________
-0- general
  ______________________________
  -0.1- starting vim
    vim/vi can be started by vim <file1> <file2>...
    useful commandline arguments:
      -u <file|NONE>        use <file> instead of ${HOME}/.vimrc for
                            initialization.  If NONE, no initialization.

  ______________________________
  -0.2- terminology
    buffer: A buffer of text, usually representing/backed by a file.
    window: The terminal window
    viewport:   A visual section of the window usually associated with a
                buffer.
    tab:    A set of viewports to be displayed.  Only 1 tab is visible
            at a time.
    cursor: The indicator for your current location.

  ______________________________
  -0.3- regex
    :h regex
    terminology:
      pattern: 1 or more branches joined by \|
      branch: 1 or more concats joined by \&
      concat: one or more pieces concatenated together
      piece: atom[multi] OR a pattern in \(\)

    multis: (with magic)
      *         0 or more greedy
      \+        1 or more greedy
      \=        0 or 1, as many as possible
      \?        same as = but cannot be used when using ? to search
                backwards
      \{n,m}    match n to m reps, greedy. n defaults to 0
                m defaults to infinite
      \{-n,m}   same as above but as few as possible

    magic atoms
      ^     beginning of line
      $     end of line
      .     any character
      \<    beginning of word
      \>    end of word
      &     the pattern (in replacement area)
      \z<s|e>     start|end of pattern to be considered for replacement.
                  Anything outside of these will be matched but not replaced.
      \<c|C>      ignore|match case
      \<m|M|v|V>  set|unset (very)magic :h /magic. Determines if escaping
                  causes literal character or regex meaning
                  (magic = .->any char, nomagic = \.->any char)


    character classes
      invert letter case to invert match
      ie: \s = whitespace, \S = not whitespace
        \s      whitespace
        \d      digit
        \x      hex-digit
        \o      octal digit
        \w      word
        \h      head of word
        \l      lowercase
        \u      uppercase

      escapes:
        \e          <Esc>
        \t          <Tab>
        \r          <CR>
        \b          <BS>
        \n          end-of-line (search) or null byte (replace)

      groups:
        \(<pat>\)   store pat as a group, available for back-reference
                    via \<num>
        \%(<pat>\)  like above but don't count it as a group
        [<stuffs>]  any character in <stuffs>
        [^<stuffs>] any character NOT in <stuffs>

        character classes for use in []: ([:<class name>:])
          alnum     graph   upper   backspace
          alpha     lower   xdigit  ident
          blank     print   return  keyword
          cntrl     punct   tab
          digit     space   escape




______________________________
-1- normal mode
  Normal mode is generally the default mode when vim is opened.  It is
  used for seeking, deleting, copy/cut/paste, macros, viewports, etc.
  Escape can spammed repeatedly to reach normal mode.

  Commands can usually be prefixed with a number to act as an argument.
  Arguments will generally be interpreted as a repeat-count or a line
  number.
  ______________________________
  -1.1- movement
    hjkl            left, down, up, right 1 char respectively (same column)
    gj|gk           move down|up a visual line (when linewrapping)
    <space>         forward 1 char (linewraps)
    <backspace>     backward 1 char (linewraps)
    0               beginning of line
    $               end of current line
    w               beginning of next word
    e               end of next word
    b               beginning of previous word
    |               Go to Nth column, defaults to 0
    <f|F><char>     go to next/previous instance of <char> on current
                    line excluding current character.
    <t|T><char>     go to just before the next/previous instance of
                    <char> on current line.
    ;               repeat the last f/F/t/T movement
    ,               repeat the last f/F/t/T movement in opposite direction
    HML             go to first,mid,last line on screen respectively
    _               first non-whitespace char on current line
    -               first non-whitespace char on previous line
    +               first non-whitespace char on next line

  ______________________________
  -1.2- scrolling
    C-f|C-d|C-e     down 1-screen|half-screen|1-line
    C-b|C-u|C-y     up 1-screen|half-screen|1-line
    z<t|z|b>        scroll current line to top|middle|bottom of screen
    z[H|L]          scroll left|right half-screen
    z[h|l]          scroll left|right char
    z[s|e]          scroll current column to left|right of screen
  ______________________________
  -1.3- editing
    Entering insert mode for typing:
      These commands enter insert mode after possible doing something.
      i         on cursor
      I         at beginning of line
      a|A       after cursor | end of line
      o|O       Insert a line below|above cursor
      r|R       replace a|many char
      c<motion> delete traversed text
      S|cc      delete N lines
      C         delete from cursor to end
      s         delete N chars
      gi        go to last insert mode and enter insert mode

    cutting/pasting
      NOTE: deletion generally adds the text to special register "
      d<motion> delete traversed characters
      dd        delete current line
      D         delete to end of line
      X|x       remove N chars before|on cursor
      P|p       paste N times on|after cursor
      y{motion} yank traversed characters.  Forward includes cursor.
                Backward excludes cursor.
      yy        yank current line

    indenting
      >>|<<     indent right/left by shiftwidth

    history (undo/redo)
      u         undo, repeat = change undo direction
      C-r       continue undo
                NOTE: in vim, if :set cpoptions? does not show a u flag
                  (the default?), then u is always undo and C-r is always
                  redo.  Otherwise, it follows the vi behavior above.
      .         redo last change

    other:
      J         join current and next N>2 lines

  ______________________________
  -1.4- jumps
    Jumping will append to a jump list which can be traversed.
    NOTE: jumplist can span files (if you jump to another file by global
    mark for example)

    C-o     previous jump in jumplist
    C-i     next jump in jumplist
    gg      JUMP to Nth line, defaults to first.
    G       JUMP to Nth line, defaults to last.
    %       JUMP to matching character of the next [](){} (starts on cursor)
    {}      previous/next blank line
    ()      beginning/end of N sentences
    []      JUMP to a section (see :h [)
______________________________
  -1.5- marks and registers
    ______________________________
    marks
      Marks are named a-z (local) or A-Z (global) and represent a
      position in the file.
        m       Store the current position to a mark register.
        `       JUMP to mark (exact)
        '       JUMP to mark (first non-whitespace char of same line)

      use :marks to list marks
      mark names begin with a ', eg :call col("'^")
      ______________________________
      special marks:
        .     last edit
        []    first/last line of last yanked/edited/pasted selection
        <>    first/last line of visual selection
        '     before last jump
        "     last position before file was closed
        ^     last position where insert mode was stopped (used by gi)
    ______________________________
    registers
      Registers/macros have same naming convention as marks.  They
      can be used for yank/put, or as a key sequence for a macro.
        "         select a register (for yank/delete/paste)
        q         begin/end recording a macro
        @<reg>    Run the text stored in register as a macro

      use :reg to list register contents
      Register names begin with a ", eg "a
      ______________________________
      register types:
        ""        unnamed: yanked/deleted text (d, c, s, x, y) (if
                  another register was specified, " is still used as well
                  so the text is stored in both "" and whatever was used.
        0-9       numbered: 0 = yanked, 1-9 = MRU queue of deleted text
        "-        small delete (deletes < 1 line)
        a-zA-Z    named
        : . %     readonly:
                    .     last-inserted text (always insert, never put)
                          NOTE: that . pasting this register causes keystrokes
                          as is rather than pasting each character.  Thus it
                          cannot be used directly to recover from accidental
                          i_Ctrl-W.  But you can :let @a=@. and then paste "a.
                          This will paste characters as is
                    %     current file name (relative to cwd)
                    :     most recent command-line
        #         alternate buffer: name of alternate window
        =         expression register: read a string expr from commandline
        * + ~     selection/drop registers (clipboard/copy-paste registers)
                  x11, * and + are different.  Windows, they are the same.
                  ~ = dragndrop text
        _         blackhole register
        /         last search pattern register



    Macros can be set via commandmode with let (-5.1-)


  ______________________________
  -1.6- folding
    Folds temporarily hide sections of the current file and may contain
    other folds.

    adding folds
      zf<motion>      add a fold from current line to the destination line.
    deleteing folds
      z<d|D>        delete 1/all folds under cursor
      zE            delete all folds everywhere
    opening folds
      z<o|O>        open 1/all folds under cursor
      z<r|R>        open 1/all folds everywhere
    closing folds
      z<c|C>        close 1/all folds under cursor
      z<m|M>        close 1/all folds everywhere
    moving to folds
      z<j|k>        JUMP to next|previous fold.
  ______________________________
  -1.7- windows, viewports, tabs
    :h ctrl-w

    Window commands are prefixed with C-w

    creating viewports:
      v         vertical split viewport
      s         horizontal split viewport
      f         split and open filename under cursor
      d         split and jumpt to definition (#define line)
      i         jump to declaration of identifier (where variable declared)
      n         new viewport

    closing viewports:
      q         quit viewport (exit if last window)
      c         close viewport (but not last window)
      o         close all but the current one

    resizing viewports:
      =         equalize viewport sizes
      |         change viewport width to N, defaults to screen width
      _         change viewport height to N, defaults to screen height
      +|-       increase|decrease height by N rows, default to 1
      >|<       increase|decrease width by N chars, default to 1

    moving viewports within a tab:
      H|J|K|L   move current viewport to far left|bottom|top|right
      r|R       rotate viewports positions down|up
      x         swap with viewport N, default next... but how to get viewport number?

    moving between viewports:
      h|j|k|l   move to the viewport to the left|bottom|top|right
      P         preview window??
      p         previous viewport
      C-w|w|W   next/previous viewport
      t|b       to top|bottom viewport

    new tabs:
      :tabn	command mode to create new tab
      T         move viewport to a new tab

    change tabs:
      g<t|T>	go to Nth(default=next)/previous Nth tab

  ______________________________
  -1.8- searching
    (see also -0.3- regex)
    /|?<pat>    initiate forward|backward regexp search for <pat>
    n|N         go to next/previous search match (retain search direction)
    [           show/search/jump
      i|I       show first|all lines containing word under cursor
      (|{       to unmatched (|{

      c/c++ related:
        #       go to previous unmatched #if, #else, #ifdef
        d|D     show first|all "#define" for word under cursor
                so #   define does not get matched even though it would work
    ]
      )|}       next unmatched )|}
      c/c++ related:
        #       next unmatched #endif/#else

    *|#         search for word under cursor forward|backward (whole word)
    g<*|#>      search for word under cursor forward|backward
                (includes subword)

  ______________________________
  -1.9- others
    K       look up word under cursor as a "keyword" in keywordprg (default man)
    ZZ      save and close
    ZQ      :q!
    C-z     suspend
    C-g     buffer info: file, lines, etc
    g C-g   cursor position (col, line, word, bytes)
    C-<a|x> increment|decrement number under cursor

______________________________
-2- insert mode
  :h i_ctrl-l

  C-t|C-d       indent right/left by shiftwidth
  C-p|C-n       autocomplete with words before/after cursor
                use C-p/C-n to scroll through
  C-w           delete word before cursor
  C-u           delete all entered characters(like undo current edit)
  C-o           normal mode for 1 command then go back to insert mode
  C-\ C-o       same as C-o but "don't move cursor"???
  C-i           tab
  C-<p|n>       autocompletion with words before/after cursor
  C-r <reg>     insert register
  C-v key       literal key
  C-[ | <Esc>   exit insert mode
______________________________
-3- visual mode
  This mode is generally for selecting text to perform a command over.

  From normal mode:
    v{motion}   set mark
    V{motion}   set mark(whole line)
    <C-V>{motion} set mark(rectangle)

  In visual mode:
    ______________________________
    motion
      o     Move to other end of selection
      O     Same as o except in visual-block mode.
            In visual block mode, move to other corner of same line
    ______________________________
    editiing
      ~     swap case
      d|x   delete
      X     delete all lines
      D     delete all lines, in block-mode, only delete block->eol
      y     yank
      c|s   delete selection and insert-mode (insert text on all lines)
      C     delete selected lines and insert (in block mode, to end of line)
      S|R   delete entire selected lines and insert (insert text only on first)
      <|>   shift left|right
      u|U   make lower|upper case
      p|P   replace selection with register contents
______________________________
-4- command mode
  Enter command mode with :.  This only allows 1 command.  Ex-mode
  allows multiple consecutive commands.  (press Q in normal mode)

  Pressing <C-f> will open a buffer for editing command lines.
  Pressing <C-d> will list potential completions.  Use tab to scroll.

  Command mode runs vim commands/functions.  These can generally be
  prefixed with a range to run the command on given lines.

  line number formats:
    <N>         line N
    .           current line
    $           last line
    %           all lines
    't          line containing mark
    'T          line containing global mark (must be in same file)
    /pattern/   lines that match regexp (after cursor)
    ?pattern?   lines that match regexp (before cursor)
    <spec>+-[N] one of above specifications +- N lines, N=1 if omitted

  A range can be specified by specifying 2 line numbers separated by a
  ',' or ';'. ',' moves the cursor, ';' does not.

  sidenote:
    when entering commandmode from visual mode with a selection,
    the range is shown as '<,'> which means from the < mark to the > mark
    (-1.5- <> = first/last line of visual selection)
  ______________________________
  -4.1- :help
    :h <thing>
      prefixes for <thing>:
        i_      insert mode
        v_      visual mode
        c_      command mode
        '       :set option
        :       command
      postfixes
        ()      builtin function
    C-]         jump to link
    C-t         previous topic
  ______________________________
  -4.2- :set
    syntax:
      :set <option>=value   set option to value
      :set <option>         set boolean option to True
      :set no<option>       set boolean option to False
      :set <option>!        toggle boolean option
      :set <option>?        echo current option value
      :set <option>&        set to default value
      :set <option>&vi      set to default value for vi
      :set <option>&vim     set to default value for vim

    Use setlocal for a buffer-local version
    (not all variables can be buffer local though)
    ______________________________
    -4.2.1- indentation
      softtabstop     sts     target destinations of tab key
      tabstop         ts      size of a tab character
      shiftwidth      sw      size of indentation
      autoindent      ai      copy indent of previous line when new line
      expandtab       et      use spaces instead of tab chars.

      If applicable, spaces will be converted to tabs once they
      reach tabstop
    ______________________________
    -4.2.2- visual changes
      ruler             ru      show cursor position in statusline
      number            nu      number lines
      relativenumber    rnu     number lines relative to cursor (current
                                line gets the absolute line number)
      visualbell        vb      flash instead of beep
      wrap                      wrap long lines
      listchars         lcs     list chars for displaying invisible chars
      list                      use lcs to display invisible chars
      cursorcolumn      cuc     highlight cursor column
      cursorline        cul     underline cursor line
      scrolloff         so      when scrolling, keep N lines from top/bottom
                                of screen relative to cursor.
      laststatus        ls      last window will have status line
                                0: never
                                1: if at least 2 windows
                                2: always
    ______________________________
    -4.2.3- statusline
      the bar at the bottom of viewports.
      Set laststatus=2 to always have the bar.
      statusline        stl     str:
        fields:
          %[-][0][minwid][.maxwid]<item>
            -       left-justify
            0       0pad if number
            item: single-letter code
              strings
                f   file (as typed)
                F   file full path
                t   file basename
                P   percentage
              flags (lowercase = [<val>], caps = ,<val>
                m   modified? +|-
                r   RO
                h   help
                w   preview
                y   file type
              numbers
                n   buffer number
                b   char under cursor
                B   hex char under cursor
                o   byte number in file
                O   hex byte number in file
                l   line number
                L   total lines
                c   col number (by char)
                v   virtual col number
                V   -{num} (on-screen column)
                p   percentage through file (lines)
              others
                <   truncate if too long
                =   separate left/right aligned
                #   highlight group
                *   set highlight group to User{N}??
          %!<expr>
            value of expr
          %{expr}   cannot contain } since that's the ending delim
          %(...%)   item-group ( can set align, widths etc of a group
                    of items)
    ______________________________
    scratch files:  this will not be saved to files and will not prevent
                    closing when modified
      buftype=nofile
      bufhidden=hide
      noswapfile
    ______________________________
    searching
      hlsearch          hls     highlight search matches
      insearch          is      find search matches as you type
      ignorecase        ic      case-insensitive searching
      smartcase         scs     case sensitive if have caps
    ______________________________
    others
      autochdir         acd     automatically change to viewport's directory
      belloff <when>    bo      don't ring bell when
      paste                     paste mode (turns off autoindent etc)
      wildmenu          wmnu    tab completion in commandline mode
      wildmode          wim     tab completion method:
                                up to 4 comma-delimited items of:
                                full            next full match
                                longest         complete til longest
                                longest:full    longest and full together
                                list            list matches
                                list:full       list and complete to first match
                                list:longest    list and up to longest common string
                                C-<n|p> to cycle through options.
      title                     set window title?
      titlestring               name of title, statusline syntax
      statusline        stl     content of status line
      formatoptions     fo      some options like continue comments on next line.
  ______________________________
  -4.3- files/buffers
    write       w       write to file
    update      up      write to file if modified
    quit        q       close viewport
    close       c       close viewport if NOT last
    xit         x       save (if modified) and quit
    qall        qa      quit all tabs/windows
    xall        xa      save all (if modified) and quit
    edit        e       edit a file (reload)
    next        n       edit multiple files (wildcard matching okay)
    buffer<N>   b<N>    change to buffer N.  N can be:
                          A number: (buffer number from :ls)
                          n: the next buffer
                          N|p: the previuos buffer
                          #: the alternate buffer
                          %: current buffer
    bdelete<N>  bd<N>   close the buffer.  N is as above.
    buffers     ls      list current buffers.
  ______________________________
  -4.4- search/replace
    (see also -0.3- regex)
    :s/text/replacement/[gciI]  run search/substitution
                                g: all matches per line
                                c: confirm
                                i: case insensitive
                                I: case sensitive
  ______________________________
  -4.5- windows/tabs
    :split <filename>   split view horizontally opens file fn,
                        or current file if fn is absent
    :vsplit <filename>  split vertically, as above
    :tabe <file>        edit file in new tab
    :tabs               list tabs and viewports
    :tabc               close tab
    :tabo               make this the only tab (close all others)
  ______________________________
  -4.6- autocmd
    Run commands on events like open file or file type etc.
    Commands are added in order.  They are always added regardless
    of whether they're already defined.  Use groups to manage.

    au[tocmd] <group> <events> <pattern>                list commands
    au[tocmd] <group> <events> <pattern> <command>      add command
    au[tocmd]! <group> <events> <pattern> <command>     clear commands and add command
    au[tocmd]! <group> <events> <pattern>               clear commands
    do[autocmd] [group] <event> [fname]                 run the commands on fname (default current fname)

    augroup <group>     add an autocmd group
      autocmd

    group: group of autocommands for easier management
      (sourcing .vimrc would add twice so clear and set so only
      ever has 1 copy). Groups are case-sensitive

    events: comma-delimited list of events and case is ignored
      pre = before event, post = after
      *                 all events
      reading
        bufnewfile              new file
        bufread[pre|post]       existing file
        filterread[pre|post]    temp file with filter output
        fileread[pre|post]      read with :read command
      writing
        bufwrite[pre|post]      write whole buffer to file
        filewrite[pre|post]     write part of buffer to a file??
        fileappend[pre|post]    append to a file
      Buffers
        buf<add|create>     add a buffer to bufferlist
        bufnew              new buffer
        bufdelete           b4 deleting a buffer
        buffile[pre|post]   changing buffer filename
        buf[enter|leave]    move to different buffer
        bufwin[enter|leave] after buffer is displayed/removed from window
        bufunload           unload buffer
        bufhidden           hide buffer
    pattern: comma-delimited filename pattern matching
      *: any sequence
      ?: any single char
      \?: literal ?
      \,: literal ,
      ,: pattern delimiter
      [ch]      normal regex meaning
      [^ch]     normal regex meaning

      Paths always use / as path separator.  If the pattern deos not
      have any path separators(/), only the basename is matched.
      Otherwise, check both relative and absolute.
      ex:
        *.c,*.cpp:      run command for c/cpp files
        */doc/*.cpp     all cpp files under a doc dir

    ex:
      augroup mygroup
        " delete mygroup in case it was already defined so only 1 copy of commands
        au! mygroup
        au mygroup BufEnter * echo hello
      augroup END

  ______________________________
  -4.7- map
    :h :key-notation
    no notes on casing for <C-key> notation, but generally use caps.

    :<C-U>call Function(v:count)
    (C-u = remove everything from cursor to beginning of line, which
    removes the auto-linerange added when <prefix number>:

    commands:
    [mode][no][re]map
    re = recursive map (use other mappings)
    nore = no recursive map (don't need to worry if other mappings
      would affect what the mapping does)

    mode:
      n         normal
      i         insert
      c         command
      v         visual and select
      s         select mode (replacement mode)
      x         visual only
      o         operator-pending
      l         Insert + Command-line + Lang-Arg (lowercase L)
      !         suffix, Insert and Command-line mode
    syntax:
      :h index                  see default mappings
      :[mode]map                list mappings
      :[prefix]map lhs rhs      map rhs to lhs where rhs is a
                                key-sequence
      :unmap lhs                unmap a sequence

      map can also take special arguments:
        <buffer>        current buffer only
        <nowait>        don't wait for more characters to be typed
        <silent>        don't echo to command line
        <special>       ??
        <script>        ??
        <expr>          evaluate rhs to get the rhs to use for mapping
        <unique>        fail if already exists

    key sequences:
      a         the key as is
      <C-...>   hold Control + some key
      <S-...>   shift + some key
      <M-...>   alt/meta + some key
      <D-...>   command + some key (mac only)
      <Nul>     zero
      <BS>      backspace
      <Tab>     tab
      <NL>      line feed
      <FF>      formfeed
      <Esc>     escape
      <CR>      return
      <Space>   space
      <lt>      less-than (because < is used for <C-key>)
      <Bslash>  \
      <Bar>     |
      <Del>     delete
      <Up>      arrow keys
      <Down>    "
      <Left>    "
      <Right>   "
      <S-key>   shift+key
      <F[1-12]> function keys
      <Help>    help key??
      <Undo>    undo key??
      <Home>    home
      <End>     end
      <PageUp>          pageup
      <PageDown>        pagedown
      <kHome>           keypad
      <kEnd>            keypad
      <kPageUp>         keypad
      <kPageDown>       keypad
      <kPlus>           keypad
      <kMinus>          keypad
      <kMultiply>       keypad
      <kDivide>         keypad
      <kEnter>          keypad
      <kPoint>          keypad decimal
      <k[0-9]>          keypad

    helpers:
      C-v key           insert key literally
      C-k key key       special keys?? (i_Ctrl-k shift-space)


    NOTE:
      C-/ and C-_ are treated as the same (C-v C-/ inserts ^_)
      if you want to use C-/, you need to bind to <C-_>

    free keys:
      (:h index, search for "not used")
      normal mode:
        \
        C-\ <NOT a-z>
        C-_             (this can also be activated via C-/)
        C-K
        C-@

      insert mode:
        C-\ <NOT a-z>
        C-B
        C-F

      Command mode
        C-\ <NOT a-z>
        C-@
        C-G
        C-O
        C-T

      in general <C-Bslash> seems to be safe to use as as an opener
      as long as the second key is not a-z

  ______________________________
  -4.8- others
    ______________________________
    abbreviations
      Abbreviations will be expanded to rhs when typed.
      :ab[breviate]             list abbreviations
      :ab[breviate] lhs rhs     abbreviate rhs as lhs
      :ab[breviate] lhs         list abbreviation
      :una[bbreviate] lhs       remove abbreviation

    ______________________________
    redirection
      :redi[r] => <var> redirect output to variable
      :redi[r] END      stop redirection

    ______________________________
    visual
      highlight     hi      define highlighting group (capitalized name)
                            hi {group} key=arg
                              attrlist: [bold,underline,undercurl,reverse,inverse,
                                italic,standout,NONE]
                              term=attrlist
                              cterm=attrlist
                              ctermfg=num
                              ctermbg=num
                                16  8   name
                                0   0   Black
                                1   4   DarkBlue
                                2   2   DarkGreen
                                3   6   DarkCyan
                                4   1   DarkRed
                                5   5   DarkMagenta
                                6   3   Brown, DarkYellow
                                7   7   LightGray, LightGrey, Gray, Grey
                                8   0*  DarkGray, DarkGrey
                                9   4*  Blue, LightBlue
                                10  2*  Green, LightGreen
                                11  6*  Cyan, LightCyan
                                12  1*  Red, LightRed
                                13  5*  Magenta, LightMagenta
                                14  3*  Yellow, LightYellow
                                15  7*  White

                                16 = 't_Co' >= 16
                                8: 't_Co' < 16
                                  * = cterm=...bold,...

                              gui=attrlist
                              font=font
                                NONE for default
                              guifg=color
                              guibg=color
                              guisp=color
                                NONE: transparent
                                bg/background = default bg
                                fg/foreground = default fg

                                colors:
                                  capitalized name
                                  "#rrggbb" (hex)
      match         mat     define a match pattern
                            mat {group} /pattern/
      colorscheme   
    ______________________________
    miscellaneous
      nohlsearch    noh     stop search highlighting
      Explore       Ex      open file explorer
      syntax on|off         turn syntax highlighting on|off
      source        so      run a vimscript
      shell         sh      start a shell
      normal        norm    run a keysequence string in normal mode
      cd                    change current working dir
                            %:h     current file's directory
                            -       previous dir
      jumps        ju       show jumplist
      g/pat/cmd             run cmd globally on lines matching pat

______________________________
-5- vim scripts and config files
  Vim scripts are basically lines of command-mode commands and the
  default path is ~/.vimrc.  It can be specified with the -u argument.
  Comments begin with "

  command-line commands are functions are different.
  functions are usually called with the command-line command :call.
  Scripts are assumed to be command-line mode so the : is unnecessary.
  long lines can be wrapped by prefixing continuation lines with a
  backslash

  ______________________________
  -5.1- variables
    variables are generally created with :let.  Removed with :unlet.
    (unlet also works with list idxs/dict keys)
    type(var) -> type of variable

    Setting variables:
      :h :let
      let varname = expr
      let @<reg> = "register value"

      let [v1,v2,v3]=[v1,v2,v3]

      (Note that these are literal text, so <Esc> will be 5 characters.
      Use C-v to use Esc in a macro.)

    checking vars:
      exists(varname)

    ______________________________
    -5.1.1- types
      ______________________________
      number
        boolean = number: false=0, True=!0
      ______________________________
      float
        xxx.yyy
        or <xxx>.<yyy>e[exp]
      ______________________________
      string
        strings are null-terminated.
        quotes used is similar to bash:
          '' = literal, no expansions/escapes
          "" = allow escapes etc.
        special characters:
          \NNN          up to 3-digit octal number
          \x...         up to 2-digit hex num
          \uxxxx        4-digit hex numberk
          \Uxxxxxxxx    up to 8-digit hex number
          \b            <BS>
          \e            <Esc>
          \f            <FF>
          \n            <NL>
          \r            <CR>
          \t            <Tab>
          \\            <Bslash>
          \"            literal quote
          \<key-notation>       some key notation like <C-b>
      ______________________________
      list
        creation                :let listvar = [item, item, [item, item],...]
                                split()
                                getline()
        indexing                :let first_item = listvar[0]
                                :let last_item = listvar[-1]
                                :let thing = get(listvar, idx, val_if_idx_not_in_list)
        concatenation           :let total = list1 + list2
                                :let list1 += list2
        add/remove              insert, add, extend, remove, filter
        sublists                :let sublist = listvar[first:last]      (inclusive!)
                                WARNING
                                  single-letter followed by : gets converted to
                                  a "namespace" variable separate the : with
                                  spaces. (for i in ... listvar[i:i+1] -> NOT a
                                  slice (i:i) = a variable
        copying                 copy()
                                deepcopy()
        comparing               == -> value
                                is/isnot -> id
        unpacking               :let [v1,v2] = listvar
                                :let [v1, v2; rest] = listvar
        assignment              :let listvar[idx] = value
                                :let listvar[start:stop] = [v1,v2,v3...]
        ordering                sort() reverse() uniq()
        other functions         call(func, listvar), empty, len, max, min, count, index,
                                append, join, map
      ______________________________
      dictionary
        key-value mappings. keys are always strs (nums will be coerced)
        creation                {k:v, ...}
        indexing                mydict["key"]
                                :let mydict.key = val
                                :let val = mydict.key
        iteration               :let list_of_keys = keys(mydict)
                                :let list_of_values = values(mydict)
                                :let kv_list = items(mydict)
        copying                 copy(), deepcopy()
        add/remove              :unlet
                                remove(mydict, key)
                                extend()
                                filter()
        dict funcs              function Funcname() dict
                                  "self = the containing dict
                                endfunction
                                :let mydict = {"memberfunc": function("Funcname")}
                                mydict.memberfunc()

                                :function mydict.newmemberfunc()
                                  ...
                                :endfunction
                                mydict.newmemberfunc()
        other functions         has_key, empty, len, min/max, count, string, map
      ______________________________
      funcref
        let Myvar = function("FuncName")
        :echo Myvar()
        :call Myvar()
        funcvariables must start with a capital
        function_name = string(Fn)
        :call(Fn, list_of_args)
      ______________________________
      special
      ______________________________
      job
      ______________________________
      channel
      ______________________________
      blob
        like a binary string, list of 0-255 numbers
        creation:
          let b = 0z<HEX_CHARS>
          let b = readfile('filename', 'B')
          ch_readblob()


      ______________________________
      type conversions:
        implicit:
          ONLY str/number (ints) are converted.
          str->number: take the prefix
                        "hello" -> number, prefix = "" -> 0
                        "69apples" -> prefix = "69" = 69
          number->str: take the decimal ascii rep.

          number prefixes: 0x (hex), 0(octal), 0b(binary)
        explicit:
          empty("str")
          str2nr()
          str2float()
          printf()
          float2nr()

    ______________________________
    -5.1.2- namespaces
      a:    function argument
      b:    buffer-local
            has special variable: changedtick
            counts any changes, monotonic increasing.
      g:    global variable
      l:    function-local
      s:    source'ed script-local
      t:    tab-local
      v:    predefined vim var
            :h v:var
              v:count       count for last normal mode command
                            <C-U> removes linerange after a count
                            caused by : (last = most recent = the one just done)
              v:count1      same as count but defaults to 1
              v:prevcount   last-last normal mode count
              v:val         value of iterating dict/list
      w:    window-local

      namespaces can be used as dicts
      ie:
        for k in keys(l:)
          ...
        endfor

    ______________________________
    -5.1.3- curly-braces-names
      :h curly-braces-names
      place an expr in {}. It will be evaluated
      and the result will be a variable name.
        do_{expr that resolves to "something"}() -> do_something()

      (alternative = str concatenation + :execute)

    ______________________________
    -5.1.4- operations
      =  assignment
      +  add
      .  str concatenate
      -  subtract
      !  not
      == != < <= > >= usual comparison
      =~ !~  regexp matching (left (!not) matches right regexp expression?)
      ==?   ignore case strcmp
      ==#   match case strcmp
      is isnot  compare identity
      += .= -=
      NOTE: *= and /= are NOT valid

    ______________________________
    -5.1.5- special variables:
      &var      local OPTION if available else global
      &l:var    local value of OPTION
      &g:var    global value of OPTION
      @var      register value
      $var      environmentvar
                can also use getenv(), setenv(), environ()

  ______________________________
  -5.2- loops
    for [varexpr] in [expr]
        ...
    endfor

    while [bool expr]
        ...
    endwhile

  ______________________________
  -5.3- operator precedence
    1. literals, &option, @register, func(...),  va{ri}able_expansion
    2. list/dict/str indexing/slicing, number is converted to str, expr->method(...), funcref()
    3. !/-/+ unary
    4. * / %
    5. +, -, .
    6. comparators
      typical comparators: ==/!=, <=>
      regex: =~/!~
      var id: is/isnot
      comparators can have a postfix: # = match case, ? = ignore case
    7. &&
    8. ||
    9. numexpr ? truexpr : falseexpr

  ______________________________
  -5.4- user defined functions
    :h user-functions
    function names MUST be capitalized
    script-local begin with s: or <SID>
    ONLY script-local or non-local

    definition syntax:
      function[!] Funcname(args,...) [abort] [range] [dict]
      endfunction

      use ! to overwrite existing definition
      abort: auto-abort on error
      range: will handle range arguments itself, otherwise called on
             each line
      dict: must be called through dict funcref. 
      ... = var args
            a:1, a:2... = extra args
            a:0 = num extra args
            a:000 = list containing extra args

    max of 20 arguments

    lambdas:
      {args... -> expr}
      arguments do not use the a: namespace
      closures work.

    use function {funcname} to find the definition.

    ______________________________
    useful commands:
      startinsert star  start insert mode after executing this command
      function  fu      list specified function (default all) or
                        /pattern for function names matching pattern.
      return    retu    return an expr
      normal    norm    execute normal-mode commands.
      execute   exe     execute string as a command (allows building a
                        command to execute.
      try               begin try block
      catch     cat     catch exception pattern (/pat/)
      finally   fina    always run code
      endtry    endt    end try/catch
      throw     th      throw a string as an exception

      call {name}([arguments])  ranges only apply to first function
      echo      ec      echo an expression with trailing newline
      echon             echo w/o newline
      let               creat variable/assignment
      unlet     unl     remove var name
      lockvar   lockv   lock variable value until unlocked.  Specify
                        depth for list/dict
      unlockvar unlo    opposite of above
      if
      else      el
      elseif    elsei
      endif     en
      while     wh
      endwhile  endw
      for {} in {}
      endfor    endfo
      continue  con
      break     brea


  ______________________________
  -5.5- builtin functions
    :h functions
    notable functions:
      winwidth(0)     current window width
      winheight(0)    current window height
      repeat("str", count)    return repeated string
      getbufline(buf, start, [stop])
      getline(start, [stop])            get text of line
      line({expr})                      get line number
                                          .: cursor
                                          $: last line
                                          'x: mark or 0 if unset
                                          w0: first visible line
                                          w$: last visible line
                                          v: visual area start
      getcurpos()                       getpos('.') but add 5th item: curswant
                                        (the prefered column on vertical move)
      getpos({expr})                    get position [bufnum, line, col, off]
      setpos({expr}, {lst})             move cursor('.') or mark ('x) to
                                        position

  ______________________________
  -... plugins
    filetype plugin on
      place file_extension.vim in .vim/after/ftplugin
