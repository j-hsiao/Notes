Contents
-1- general
  -1.0- Terms
  -1.1- Widgets
    -1.1.1- Callbacks
    -1.1.2- Validation
    -1.1.3- focus
    -1.1.4- scrolling
  -1.2- Grid
  -1.3- Variables
  -1.4- Colors
  -1.5- fonts
  -1.6- helpers
    -1.6.1- filedialog
    -1.6.2- messagebox
  -1.7- clipboard
-2- Bindings
  -2.1- Event Sequences
    -2.1.1- Modifiers
    -2.1.2- Event type
  -2.2- Event Objects
  -2.3- Generation
  -2.4- Other Notes
-3- Widgets
  -3.1- Button
  -3.2- Canvas
  -3.3- Checkbutton
  -3.4- Entry
  -3.5- Frame
  -3.6- Label
  -3.7- Listbox
  -3.8- Menu
  -3.9- Menubutton
  -3.10- Radiobutton
  -3.11- Scale
  -3.12- Scrollbar
  -3.13- Spinbox
  -3.14- Text
______________________________
-1- general
  tk is a wrapper over tcl.
  tcl can be accessed directly via widget.tk.call which invokes
  tcl commands.  (Everything is a string, user must handle type conversions)

  ______________________________
  -1.0- Terms
    active: mouse is over the item/interacting with item
      (if click+drag away from item, it is still active until released)

    stipple: use something like pointilism to display.  Kind of like
      alpha but not quite.
      always available:
        error
        gray75
        gray50
        gray25
        gray12
        hourglass
        info
        questhead
        question
        warning
      Macintosh only
        document
        stationery
        edition
        application
        accessory
        folder
        pfolder
        trash
        floppy
        ramdisk
        cdrom
        preferences
        querydoc
        stop
        note
        caution


  ______________________________
  -1.1- Widgets
    Widgets are tk classes.  They take a parent and kwargs.
    kwargs are usually also able to be passed after creation via
    widget.configure().  widget.cget('property') retrieves property
    value.

    attributes:
      master: first argument to __init__

    useful methods:
      configure(...):
        If no args: return dict of all configs
          Values are a 4-tuple:
            (kwarg, dbname, dbclass, value)
        If a name is given then return the corresponding value in the returned dict.
        If kwargs/dict: set the corresponding config values
      cget(config)
        get value for config
      nametowidget(name)
        convert name (str) to a widget

    configs:
      state:
        State generally has 'normal', 'disabled' and maybe others depending
        on widget.

      General configure() options:
        cursor:
          X_cursor
          arrow
          based_arrow_down
          based_arrow_up
          boat
          bogosity
          bottom_left_corner
          bottom_right_corner
          bottom_side
          bottom_tee
          box_spiral
          center_ptr
          circle
          clock
          coffee_mug
          cross
          cross_reverse
          crosshair
          diamond_cross
          dot
          dotbox
          double_arrow
          draft_large
          draft_small
          draped_box
          exchange
          fleur
          gobbler
          gumby
          hand1
          hand2
          heart
          icon
          iron_cross
          left_ptr
          left_side
          left_tee
          leftbutton
          ll_angle
          lr_angle
          man
          middlebutton
          mouse
          none
          pencil
          pirate
          plus
          question_arrow
          right_ptr
          right_side
          right_tee
          rightbutton
          rtl_logo
          sailboat
          sb_down_arrow
          sb_h_double_arrow
          sb_left_arrow
          sb_right_arrow
          sb_up_arrow
          sb_v_double_arrow
          shuttle
          sizing
          spider
          spraycan
          star
          target
          tcross
          top_left_arrow
          top_left_corner
          top_right_corner
          top_side
          top_tee
          trek
          ul_angle
          umbrella
          ur_angle
          watch
          xterm
    ______________________________
    -1.1.1- Callbacks
      callbacks in tk are "scripts"
      In general, it would be a commandname followed by arguments like
        'commandname arg1 arg2 ...'.  In some cases, a tuple can be
        used as well. (though prefer str)
      Existence of a command can be checked with info command (TCL only):
        widget.tk.call('info', 'command', 'nameofcommand')->
          ('nameofcommand',) #it exists
          '' # does not exist

      base commands (widget.tk):
        createcommand(name, f):
          This maps a function f to name where f is a python function
          and name is a tcl name.
        deletecommand(name):
          This deletes the mapping between name and f.
      related (widget) commands:
        register(func, subst, needcleanup=1):
          func: the func to register
          subst: a conversion function for args: tuple->tuple
          needcleanup: call deletecommand if widget deleted.

          Return name of Wrapped func(*(args if subst is None else subst(*args)))

        bind(seq, function, add=None):
          seq: event sequence
          function: function to bind
          add: add or overwrite

          Calls register with needcleanup=1, subst=widget._substitute etc
            _substitute takes list of "all" bind % substitutions and merges
            into an Event object.

        bind_class(tag, seq, func, add=None):
          same as widget.bind but use tag
          registered with needcleanup=0 so the bound class is intact
          even if this widget is destroyed

      ex 1: validation
        def validate(proposed_string):
          dostuff

        method 1: register
          r = tk.Tk()
          e = tk.Entry(r, validate='key')
          e.configure(validatecommand=(e.register(validate), '%P'))

        method 2: base calls
          r = tk.Tk()
          r.tk.createcommand('validateTCLname', validate)
          e = tk.Entry(r, validate='key', validatecommand=('validateTCLname', '%P'))
          OR
          e = tk.Entry(r, validate='key', validatecommand='validateTCLname %P')

        On validation, myvalidatefunction(%P) will be called.
        In this case, because validation has special handling for %P
        and %W, the %P and %W will be converted to the corresponding
        values and then passed to the function (all as strings)

      ex 2: binding
        def raw(root, widget, keysym):
          e = Event()
          e.widget = root.nametowidget(widget)
          e.keysym = keysym
          callbackfunc(e)
        def callbackfunc(e):
          dostuff(e)
        r = tk.Tk()

        method 1: bind
          r.bind_class('all', '<KeyPress>', callbackfunc)

        method 2: direct calls
          r.tk.createcommand('mycallback', raw)
          r.tk.call(('bind', 'all', '<KeyPress>', 'mycallback %W %K'))

    ______________________________
    -1.1.2- Validation
      validate=[none|focus|focusin|focusout|key|all]
      validatecommand=(widget.register(func), <code args>...)
        %d: action type:  1: insert, 0: delete, -1: focus, forced, validation
        %i: idx of char to be inserted/deleted, else -1
        %P: pending value
        %s: current value
        %S: text to be inserted/deleted
        %v: type of validation currently set (validate property)
        %V: type of validation that triggered cb (validate property)
        %W: widget

      invalidcommand=func

    ______________________________
    -1.1.3- focus
      focus indicates which widget will receive keyboard events.
      methods(no args):
        focus/focus_set set keyboard focus next time user focuses on the
                        window, keyboard events will be sent to the
                        widget.
        focus_force     set keyboard focus AND make corresponding
                        toplevel window focused.
        focus_get       get name of currently focused widget
        tk_focusNext    move focus to next item
        tk_focusPrev    move focus to previous item
    ______________________________
    -1.1.4- scrolling
      tk.Scrollbar
        orient='horizontal'|'vertical'
        command=widget.[x|y]view

      widget.configure([x|y]scrollcommand=scrollbar.set)

  ______________________________
  -1.2- Grid
    grid splits widgets up into a grid of space.
    grid(row=, col=, columnspan=, rowspan=, sticky=)
      Put current widget into parent's grid.
      sticky: a string of flags: nsew for north/south/east/west
      row/col are 0-indexed so 0,0 is topleft
      negative values might work? but idk...
      row/columnspan let widget take up multiple rows/columns in parent
      gridspace

    grid_rowconfigure(idx, props)
    grid_columnconfigure(idx, props)
      properties:
        weight: weighting for space distribution of this row/col on
          resizing
        minsize: minimum pixel value of this row/col


  ______________________________
  -1.3- Variables
    IntVar, StringVar, BooleanVar, DoubleVar
    methods:
      set(val)
      get()
      name = trace('r|w|u', func)
      trace_vdelete('r|w|u', name)
      trace_vinfo()

    Some tk widgets can take a variable as an config argument
    (variable, textvariable, listvariable, etc).  The variable will be
    auto-updated with the widget's contents.
    Callback take 3 arguments: callback(varname, ??, modestr)

  ______________________________
  -1.4- Colors
    #rrggbb (hex values, 0-255)
    name    (string name of color like 'black')

    winfo_rgb(color)
      Return the R,G,B color tuple. Values are 0-65535

  ______________________________
  -1.5- fonts

  ______________________________
  -1.6- helpers
    ______________________________
    -1.6.1- filedialog
      popups for opening/saving filenames/directories
      options:
        defaultextension        default extension to use on filename if missing
        filetypes               tuple of tuples:
                                (('filetype name', '*.ext1 *.ext2 ...')...)
                                (pattern=space-delimited patterns)
        initialdir
        initialfile
        parent
        title
        multiple                boolean, select multiple items?
      directory only:
        mustexist               boolean

      methods:
        askopenfilename(s)
        asksaveasfilename
        askdirectory

      NOTE:
        These methods generally give empty string on cancel instead of
        None.

    ______________________________
    -1.6.2- messagebox
      display a message, simple response buttons

      options:
        default         default button (name of reply)
                        ABORT RETRY IGNORE OK CANCEL YES NO
        icon
        message
        parent
        title
        type

      methods
        askokcancel
        askquestion
        askretrycancel
        askyesno
        askyesnocancel
        showerror
        showinfo
        showwarning


  ______________________________
  -1.7- clipboard
    clipboard_get()
      type: same as below
    clipboard_append()
      type: STRING | FILE_NAME?? | UTF8_STRING??
      format: STRING: 8-bit ascii characters
              ATOM: 4 bytes??
              anything else: string of 32-bit ints??
    clipboard_clear()

______________________________
-2- Bindings
  Bindings bind callbacks to certain event sequences.

  Bindings are bound to "bindtags", basically names.  Widgets have a
  list of bindtags via widget.bindtags()
    bindtags() = return a tuple of bind tags
    bindtags((tag1,...)) = set the bindtags

  The bind callback can be a str or a function (no tuples allowed).
  If str, then all other arguments are completely ignored (add,
  needcleanup, etc).  As a result, adding to an event sequence rather
  than overwriting it can only work with functions as is.  In tcl, to
  add to an event sequence, the script should be prepended with a '+'
  so if func is a str, it should be prepended with a '+' before passing
  it to bind() to add rather than overwrite.

  If callback is a function, then the corresponding registered id is
  returned.  If it is a str, the returnvalue is None.

  NOTE:
    more specifically:
      tcl binds a script to a bindtag and event sequence specifier.
      the script is a string, and if prefixed with + will be appended
      to any existing scripts.
      tkinter wraps any bindings by:
        1. wrap a function in a CallWrapper.  CallWrapper combines a
          function with a substitute function and widget.  The substitute
          function takes args and converts them.  (default is widget._substitute
          which takes the default %<char> args and converts to particular
          types)
        2. Register the resulting CallWrapper under id(wrapper)+func.__name__
          by using tk.createcommand(name, func) (delete by tk.deletecommand(name))
        3. Bind a script using the registered function in step 2:
          'if {"[2235275164928callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n\n
           if {"[2235301124864callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n'

      In otherwords, for more control (not sure if parsing the extra 
      arguments may also reduce performance by any significant amount)
        method 1: use register and the callwrapper mechanism:
          def substitute(raw '%char' return values as strs):
            return (converted, arguments,...)
          def somecallback(args, that, match, substitute):
            ...
          funcid = widget.register(somecallback, substitute, needcleanup=0/1)
            (needcleanup will add to widget._tclCommands, contents of which will be
            tk.deletecommand()ed on __del__)
          widget.bind('{funcid} %<char> ...'), add the %<char> values you are interested in
        method 2:
          use tk.createcommand directly:
          def func(someargs):
            ...
          tk.createcommand(name, func)
          widget.bind(seq, '{name} %char %char ...')
  Canvas items:
    Fuse canvas.[tag_bind|gettags|addtag] instead of bind/bindtags.
    Note that for canvas items there is no way to set multiple tags.
    To reorder tags, you must remove tags and then add them again.

  When an event is created on a widget, each tag in widget.bindtags is
  considered.  If there is a binding for the event on that tag, then the
  corresponding callback will be called.
  eg. In tkinter, widgets by default have bindtags: ('path', 'class', '.', 'all')
  This means bindings to the particular instance, the class bindings, then the
  owning Tk() instance, and finally the 'all' tag.

  tkwidget.bind(): bind to current widget's path
  tkwidget.bind_class(path, ...): bind to the given path
  Note that tkwidiget.bind() is basically tkwidget.bind_class(str(tkwidget), ...)

  In tkinter, callbacks that are functions will be .register()ed.
  The callback can also be a str in which case it is used directly
  (example, a single space would cause it to become a noop)

  ______________________________
  -2.1- Event Sequences
    '<modifier-...-event>': An event sequence corresponding directly to
      some keyboard/mouse input.
    'key': same as '<key>'
    '<<eventname>>': a virtual event.

    ______________________________
    -2.1.1- Modifiers
      key/button          bindseq   state (%s substitution)
      Control             Mod1, M1, Command(num lock)
      Alt                 Mod2, M2, Option(alt)
      Shift               Mod3, M3, (scroll lock)
      Lock                Mod4, M4
      Extended            Mod5, M5
      Button1, B1         Meta, M
      Button2, B2         Double
      Button3, B3         Triple
      Button4, B4         Quadruple
      Button5, B5
    ______________________________
    -2.1.2- Event type
      Activate                 FocusOut
      ButtonPress, Button      Gravity
      ButtonRelease            KeyPress, Key
      Circulate                KeyRelease
      CirculateRequest         Leave
      Colormap                 Map
      Configure                MapRequest
      ConfigureRequest         Motion
      Create                   MouseWheel
      Deactivate               Property
      Destroy                  Reparent
      Enter                    ResizeRequest
      Expose                   Unmap
      FocusIn                  Visibility

    NOTE: MouseWheel is usually only on mac/windows.
      Use button4(up) and button5(down) otherwise.

    Keypress names:
      a-zA-Z0-9
      space
      grave               `
      asciitilde          ~
      exclam              !
      at                  @
      numbersign          #
      dollar              $
      percent             %
      asciicircum         ^
      ampersand           &
      asterisk            *
      paren[left|right]   ()
      minus               -
      underscore          _
      equal               =
      plus                +
      bracket[left|right] []
      brace[left|right]   {}
      backslash           \
      bar                 |
      semicolon           ;
      colon               :
      apostrophe          '
      quotedbl            "
      comma               ,
      less                <
      period              .
      greater             >
      slash               /
      question            ?

      F1-12
      Escape
      BackSpace
      Return
      Insert
      Home
      Prior
      Delete
      End
      Next
      Tab
      [Caps|Scroll|Num]_Lock
      Pause
      [Super|Alt|Shift|Control]_[L|R]
      Menu

      Up
      Left
      Down
      Right

    OBSERVATION:
      printable = all lowercase?
      non-printable = capitalized?
      exceptions:
        Tab
        Return


  ______________________________
  -2.2- Event objects
    Callbacks take a single event as argument.
    properties:
      above       %a: a window
      borderwidth %B: a size (screen dist)
      button      %b: mouse button number -> num
      char        %A: printable ascii character
      count       %c: int, ??
      data        %d: string, user data (virtual events)
      delta       %D: int, scroll amount, +=up, -=down (MouseWheel event on windows)
      detail      %d: Notify[Ancestor|DetailNone|Inferior|Nonlinear|
                             NonlinearVirtual|Pointer|PointerRoot|Virtual]
      focus       %f: bool, if window has focus
      height      %h: int, screendist
      keycode     %k: int (the actual keyboard key identifier)
      keysym      %K: string, key name (as would be used for bind)
      keysym_num  %N: int representing the (virtual)key that was pressed
                      eg.
                        <Shift-m>, keycode = 77, and keysym_num = 77, chr(77) = 'M')
                        <m>, keycode = 77, keysym_num = 109, chr(109) = 'm')
      mode        %m: Notify[Normal|Grab|Ungrab|WhileGrabbed]
      override    %o: bool
      place       %p: Place[OnTop|OnBottom]
      root        %R: str, window path??
      rootx       %X: int, screendist (on screen) -> x_root
      rooty       %Y: int, screendist (on screen) -> y_root
                      NOTE:
                        rootx and rooty  when event_generate will become x/y instead of rootx/rooty
      sendevent   %E: bool, 0 = "normal", 1 = "synthetic" ???
      serial      %#: int, nth event
      state       %s: int or Visibility[Unobscured|PartiallyObscured|FullyObscured]
                      state int values (looking at tkinter/__init__.py Event.__repr__)
                        bit meaning
                        0   Shift
                        1   Caps_Lock
                        2   Control
                        3   Mod1
                        4   Mod2
                        5   Mod3
                        6   Mod4
                        7   Mod5
                        8   B1
                        9   B2
                        10  B3
                        11  B4
                        12  B5
                        17  Alt
      subwindow   %S: string (path name) or int (window id)
      time        %t: int, timestamp
      type        %T: type field from event: (tk.EventType(strint) for py3)
                      KeyPress = '2'
                      Key = KeyPress,
                      KeyRelease = '3'
                      ButtonPress = '4'
                      Button = ButtonPress,
                      ButtonRelease = '5'
                      Motion = '6'
                      Enter = '7'
                      Leave = '8'
                      FocusIn = '9'
                      FocusOut = '10'
                      Keymap = '11'           # undocumented
                      Expose = '12'
                      GraphicsExpose = '13'   # undocumented
                      NoExpose = '14'         # undocumented
                      Visibility = '15'
                      Create = '16'
                      Destroy = '17'
                      Unmap = '18'
                      Map = '19'
                      MapRequest = '20'
                      Reparent = '21'
                      Configure = '22'
                      ConfigureRequest = '23'
                      Gravity = '24'
                      ResizeRequest = '25'
                      Circulate = '26'
                      CirculateRequest = '27'
                      Property = '28'
                      SelectionClear = '29'   # undocumented
                      SelectionRequest = '30' # undocumented
                      Selection = '31'        # undocumented
                      Colormap = '32'
                      ClientMessage = '33'    # undocumented
                      Mapping = '34'          # undocumented
                      VirtualEvent = '35',    # undocumented
                      Activate = '36',
                      Deactivate = '37',
                      MouseWheel = '38',
      warp          : event_generate argument: bool, "whether screen pointer should be warped as well"
                      this allows you to move the mouse
      widget      %W: widget name
      width       %w: size, screendist
      when          : event_generate argument: [now|tail|head|mark]
                      now: handle before return
                      tail: put at end of queue
                      head: beginning of queue
                      mark: at beginning of queue but after any other
                        when=mark events.
      x           %x: int, x coord (for widget)
      y           %y: int, y coord (for widget)

    Note: some tcl properties are not available as a tk.Event property
      like subwindow.  If these are necessary, then you'd probably need to
      manually register and bind the callback.

    tk only properties (not in tcl):
      widget        : widget that got the event

    Event properties vary by event type:
      all                 sendevent serial
      <Configure>         above borderwidth height override width x y
      <ButtonPress>       button num root rootx rooty state subwindow time warp x y
      <ButtonRelease>     button num root rootx rooty state subwindow time warp x y
      <Circulate>         place
      <Enter>             detail focus root rootx rooty state subwindow time x y
      <Expose>            count mode x y
      <FocusIn>           detail mode
      <FocusOut>          detail mode
      <Gravity>           x y
      <KeyPress>          keycode keysym root rootx rooty state subwindow time warp x y
      <KeyRelease>        keycode keysym root rootx rooty state subwindow time warp x y
      <Leave>             detail focus mode root rootx rooty state subwindow time x y
      <Map>               override
      <Motion>            root rootx rooty state subwindow time warp x y
      <MouseWheel>        delta
      <Property>          time
      <Reparent>          override x y
      <<Virtual events>>  data
      <Visibility>        state

  ______________________________
  -2.3- Generation
    Events can be generated via widget.event_generate()
    Generated events act just like normal events.
    Arg is a sequence (-2.1- Event Sequences) and any properties as
    keyword arguments (-2.2- Event Objects).  The state property seems to be
    automatically set based on seq.  eg. event_generate('<B1-Motion>')
    has state == 256

    The state flag values can be calculated by binding and generating events
    to see what the state value is.

    This can be used to create virtual events as well
    (event_generate is threadsafe)

    NOTE 1
      event_generate uses 'now' as when by default which causes "immediate"
      processing (within event_generate()) of the generated event.  'now' blocks
      until all handlers for that event have completed.  (This can cause deadlock
      depending on what callbacks do)  'head', 'tail', and 'mark'? can prevent
      this since they ?just add events to a queue? and then exit immediately
      without further processing.
    NOTE 2
      Regarding Motion events, generation at 'tail' causes all motion events
      to be merged into 1... (the last motion event)
      'head' causes them to remain separate though...
    NOTE 3
      Regarding Shift and Lock modifiers, generated events if lowercase
      key press will be converted to the appropriate value.
      eg: event_generate('<Shift-b>') will be queued as '<Shift-B>'
        Binding to '<Shift-b>' will not see this event since it'll be
        seen as '<Shift-B>'
  ______________________________
  -2.4- Other Notes
    Enter/Leave:
      Leave is always called on previous widget before enter is
      called on the next widget.  If any mouse buttons are held, then
      enter will never be called on another widget until buttons are
      released (button is held so the original widget still has focus
      even if <Leave> is fired because dragged mouse out of widget)

    Breaking:
      Return 'break' to stop the callback chain
      (see _bind() implementation for details (cmd=...)

    Names:
      bound function names are generated by register()
      which tries to use repr(id(func)) + func.__name__

    Caps Lock/shift:
      Be careful with the case of the key when caps lock/shift
      <Control-Shift-O> will fire when no capslock, but fails if
      caps lock

    bind(add=True/False):
      tk _bind completely ignores add when the bind function is a str.
      h/-2-

______________________________
-3- Widgets
  ______________________________
  -3.2- Canvas
    tk.Canvas: window = put widget and allow scrolling
    draw/manage shapes with callbacks on shapes

    Items: Items are drawn on the canvas
      options:
        prefixed with [|active|disabled]:
          dash            dash outline
          fill            fill color
          outline         outline color
          outlinestipple  outline stipple
          stipple         fill stipple
          width           width of outline
        dashoffset        stipple offset for outlinestipple
        offset            stipple offset for stipple
        state             [normal|disabled|hidden]
                          disabled = displayed but effectively nonexistent
                          ie if A is over B but A is disabled, then when
                          the cursor is over A, callbacks see the cursor
                          as over B instead.
        tags              like bindtags() for widgets except is canvas item

    tagOrId can usually be given as an expression:
      &&(and), ||(or), ^(xor), !(not).
      eg. a&&b = tag a and b
    (NOTE: these expressions only work with tags, NOT IDS)

    For commands that act on single items at a time, only the first item
    matched will be affected (?in display list?)

    binding:
      Bindings for canvas items are done via Canvas.tag_bind.
      Canvas items bindings are always handled before bindings on the
      canvas itself.
      When a binding returns 'break', only the item-bound callbacks are broken.
      The widget bindings still fire.

    Canvas callbacks are called AFTER item callbacks, no exceptions.
    Reordering canvas bindtags does not affect this.

    Canvas methods generally have a widget and item version:
      widget        item
      bind          tag_bind
      focus_set     focus           * NOTE: only text can be focused, other items cannot take focus

    other notes:
      oval items in canvas cannot have a stipple
      they can, however, have an outline stipple.
      width is centered on the outline so if you want a
      circle of diameter D, you can do x,y,x,y, width=D
      it's approximately correct. Then you can stipple by using outlinestipple
      (THIS ONLY WORKS ON LINUX, windows pukes)

      Enter/Leave issues:
        if B1-Motion causes cursor to leave item:
          if callback calls canvas.coords:
            Leave is not fired until something else happens
          But if, for example, canvas.move:
            Leave is fired right after with state=0 (as if no button was pressed)

        Enter/Leave caused by change in fill all say state=0, weirdness
        enter/leave, state is unreliable, better to just
        bind something (or empty script) to all B1-Motion events etc.

______________________________
-4- Menus
  Menus are top-level widgets (can't be gridded)
  There are 3 menu types:
  configs:
    postcommand
      called before post()
    selectcolor
    tearoff
      bool, add a tearoff entry at 0 (default True)
    tearoffcommand
      called just before tearoff 
    title:
      torn off window's title
    type
      tearoff: a new window that acts as a menu
      normal : a right-click menu
      menubar: A menubar on the window

    For tearoff and normal, you do menu.post() to make it show
    for menubar, you do toplevel.config(menu=menu) to "grid" it.

    Menubars have a "tearoff" config value which basically means they have an extra
    tearoff item added at the top which converts it into a window.


  add: add an item
    types:
      command           like a button
      separator         a dividing line (appearance only)
      checkbutton       toggle option
                        onvalue, offvalue, variable, selectcolor, command
      radiobutton       mutually exclusive choices
                        value, variable, selectcolor, command
      cascade           create cascading menus
                        post/unpost (does what??)
                        command (unavailable to windows)
      tearoff           cause torn-off copy of (sub)menus
      menubar           a menu bar...
    common item properties:
      label/bitmap/image        the displayed text/image
      accelerator               shortcut key combo desc, only displayed
                                if not menubar top-level item
      indicator                 indicate state (for radio/check only)



sources:
https://tkdocs.com/tutorial/tree.html

from tkinter import *
from tkinter import ttk

*NOTE: import tkinter does not really give all the stuff
also cannot import tkinter.thing
example:
from tkinter import StringVar           ok
import tkinter.StringVar                ERROR
import tkinter;tkinter.StringVar        ERROR



##############################
contents
##############################
:1: general
:1.5:general configurations:
:1.6: general functions

:2: classes
  :2a: tkinter.Tk
  :2b: Vars
    :2b1:tkinter.StringVar
    :2b2:tkinter.BooleanVar
    :2b3: tkinter.DoubleVar()
    :2b4: tkinter.IntVar()
    :2b5: tkinter.Variable()
  :2c: ttk.Frame
  :2d: ttk.Entry
  :2e: ttk.Label
  :2f: ttk.Button
  :2g: ttk.Checkbutton
  :2h: ttk.Radiobutton
  :2i: ttk.Combobox
  :2j: tkinter.Listbox
  :2k: ttk.Scrollbar
  :2l: ttk.Sizegrip
  :2m: tkinter.Text
  :2n: ttk.Progressbar
  :2o: ttk.Scale
  :2p: tkinter.Spinbox
  :2q: ttk.Separator
  :2r: ttk.Labelframe
  :2s: ttk.Panedwindow
  :2t: ttk.Notebook
  :2u: ttk.Treeview
  :2v:
  :2w: 
  :2x: 
  :2y: 
  :2z: 


:3: geometry manager
  :3a: grid
:4: menus
:5: windows
:6: dialogs
:7: fonts
:8: colors
:9: images
:10: canvas

##############################
:1: general
##############################
  ------------------------------
  example:
  ------------------------------
    from tkinter import *
    from tkinter import ttk
    
    def calculate(*args):
        try:
            value = float(feet.get())
            meters.set((0.3048 * value * 10000.0 + 0.5)/10000.0)
        except ValueError:
            pass
        
    root = Tk()
    root.title("Feet to Meters")
    
    mainframe = ttk.Frame(root, padding="3 3 12 12")
    mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
    mainframe.columnconfigure(0, weight=1)
    mainframe.rowconfigure(0, weight=1)
    
    feet = StringVar()
    meters = StringVar()
    
    feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
    feet_entry.grid(column=2, row=1, sticky=(W, E))
    
    ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))
    ttk.Button(mainframe, text="Calculate", command=calculate).grid(column=3, row=3, sticky=W)
    
    ttk.Label(mainframe, text="feet").grid(column=3, row=1, sticky=W)
    ttk.Label(mainframe, text="is equivalent to").grid(column=1, row=2, sticky=E)
    ttk.Label(mainframe, text="meters").grid(column=3, row=2, sticky=W)
    
    for child in mainframe.winfo_children(): child.grid_configure(padx=5, pady=5)
    
    feet_entry.focus()
    root.bind('<Return>', calculate)
    
    root.mainloop()

root: Tk()
handle on the root window



##############################
:1.5:general configurations:
##############################
    anchor          : n, ne, e, se, s, sw, w, nw, center
                      if item has more space than needed
                      in the grid, anchor to these positions
    background      : name ('red'), hex (#ff340a)
    borderwidth     : border width
    class           : 
    compound        : str:
                      text, image (only text or image)
                      center, top, left, bottom, right
                          (put text at position on image)
    cursor          : 
    default         : active: default, normal: normal (for appearance, like Button)
    elide           : tag config for tk.Text
    font            : TkDefaultFont
                      TkTextFont
                      TkFixedFont
                      TkMenuFont
                      TkHeadingFont
                      TkCaptionFont
                      TkSmallCaptionFont
                      TkIconFont
                      TkTooltipFont
    foreground      : name ('red'), hex (#ff340a)
    from(from_)     : (need _ because from = reserved)
                      lower bound (ie of ttk.Scale)
    image           : PhotoImage(file = 'path2file.gif') (only gif or ppm or whatever weird thing)
                      otherwise use PIL (pip install pillow
                          from PIL import ImageTk
                          ImageTk.PhotoImage(file = 'path2file')
                          Image.fromarray(pixels)
    justify         : left, center, right
    length          : len (pixels)
    maximum         : (ttk.Progressbar)
    mode            : 'determinate', 'indeterminate' (ttk.Progressbar)
    offvalue        : value for off(like checkbutton)
    onvalue         : value for on  (like checkbutton)
    orient          : 'vertical', 'horizontal' (scrollbars, )
    padding         : like html padding,
                      all: 1 number
                      horz, vert: 2 numbers
                      left top right bottom: 4 numbers
    relief          : border style (flat, raised, sunken, solid, ridge, groove)
    selectmode      : ex for Listbox, 'browse' (single), 'extended' (multi)
    show            : example: Entry->show a different character (ie type a password)
    state           : for tkinter widgets (not ttk), 'normal', 'disabled'
    style           : themes
    takefocus       : 
    text            : 'TEXTSTRING'
    textvariable    : StringVar()
    to              : to value
    undo            : allow undo (tk.Text)
    value           : value (ie for radio button)
    values          : for multiple values (like Combobox), a list of values
    width/height    : (ex: 5, 5c, 5i, 5p) (cm, inches, printer's points)
    wrap            : 'none', 'char', 'word' (Text)
                    : True/False (tk.Spinbox) (get to end of list, wrap around?)
    wraplength      : pixel length of text to wrap (Entry)

##############################
:1.6: general functions
##############################
general functions:
    grid(column = M, row = N, sticky = (N, W, E, S...))
        row/column: where to place the item
        sticky    : alignment (north, south, east, west)
        

    columnconfigure(X, weight=_, padx = _, pady = _)
    rowconfigure(Y, weight=Y, padx = _, pady = _)
        these two affect window resize behavior (expand to fill space)
        these indicate the row/column to expand/resize

    winfo_children()

    focus()
    
    configure(*args, **kwargs)
        args: name of a property to describe
        kwargs: set the property
        no args or kwargs: describe everything(properties, valid values, etc)

    destroy()
        destroys object and all descendents


##############################
:1.6: general functions
##############################
state(['disabled'])            disable the widget
state(['!disabled'])           enablethe widget

instate(['disabled'])          True if disabled
instate(['!disabled'])         True if not disabled
instate(['!disabled'], cmd)    if not disabled, do cmd

flags:
    active        disabled        focus
    pressed       selected        background
    readonly      alternate       invalid

bind('key description', callback)
    patterns:
        keydescs separated by white space
            
        1: 'k'
            k = a key
            (any non-space not '<'
             single-printing ascii character)
        2: <modifier-modifier-type-detail>
            must have at least one type and one detail

        3: <<name>>
            a "virtual event"???
            no modifiers allowed

    callback takes 1 arg: an "event" (e has params, often x, and y)
    description syntax:
        <modifier-modifier-...moremodifiers...-type-detail>
        modifiers:
            Control
            Alt, (Alt_L, Alt_R)
            Shift
            Lock
            Extended
            Button1/B1
            Button2/B2
            Button3/B3
            Button4/B4
            Button5/B5
            Mod1, M1, Command
            Mod2, M2, Option
            Mod3, M3
            Mod4, M4
            Mod5, M5
            Meta, M
            Double
            Triple
            Quadruple
        types:
            FocusOut            Activate
            Gravity             ButtonPress, Button
            KeyPress, Key       ButtonRelease
            KeyRelease,         Circulate
            Leave,              CirculateRequest
            Map,                Colormap
            MapRequest          Configure
            Motion              ConfigureRequest
            MouseWheel          Create
            Property            Deactivate
            Reparent            Destroy
            ResizeRequest       Enter
            Unmap               Expose
            Visibility          Focusin
            Tab                 <<ComboboxSelected>> (for comboboxes)
            
        example Double-Button-1

    http://www.tcl.tk/man/tcl8.5/TkCmd/bind.htm





##############################
:2:classes
##############################

NOTE: for each
just do:
    from tkinter import ttk
    ttk.CLASSNAME().configure().keys() to see fields
    or 
    ttk.CLASSNAME().configure()[field] to see explanations


:2a: tkinter.Tk()
    the root window
    methods:
        title(titlestring)
        mainloop()
    notes:
        not "themed"=>background may be different


:2b: vars
    :2b1:tkinter.StringVar()
        a string variable for linking to widget
    :2b2:tkinter.BooleanVar()
        a boolean variable for linking to widget
    :2b3: tkinter.DoubleVar()
    :2b4: tkinter.IntVar()
    :2b5: tkinter.Variable()

    vars have a trace method:
    trace(mode, callback)
        mode: 'w', 'r', 'u' (write, read, unset)
        callback: a callback function taking some args
        
    



:2c: ttk.Frame(parentWindow, padding="3 3 12 12")
    an empty frame (rectangle)
    
:2d: ttk.Entry(parent, width, textvariable)
    text entrybox
    textvariable: where to store the text input
    width->characters
    methods:
        get(): get value
        delete(start, stop):
            'end' = last index
        insert(0, 'somestring'):
            insert new text at index
    states:
        invalid
        readonly (can't type but can highlight/copy)
    validate:
        'none'
        'key' (on each keystroke)
        focus/focusin/focusout,
        all
        2 callbacks:
            validate: return 0 or 1 (True or False)
            invalidcommand: runs when invalid
        


:2e: ttk.Label(parent)

:2f: ttk.Button(parent, text=TEXT, command=FUNC)
    a button,
    methods:
    invoke: invoke the callback
    
:2g: ttk.CheckButton(parent, configs)
    a checkbutton
    methods:
        invoke (see above)
    instate:
        alternate = 3rd value, (ie when you see some checklists
        and check some but not all)

:2h: ttk.Radiobutton
    instate:
        alternate

:2i: ttk.Combobox
    for choosing from a list or enter own value maybe
    selectionclear()
    get()
    set(val)
    current():      return selected index
    current(index): select the index

:2j: tkinter.Listbox
    list of boxes, allow multi-selection
    listvariable: just a python list... isn't working...
    use tkinter.StringVar()
    'item1 {item 2} item3'
    has 3 items
    virtual event: <ListboxSelect>
    alternatively:
        .insert(ind, *items)
        .delete(start, stop = None)
            single item at index start if stop is None
            else from start to stop inclusive
        .get(start, stop = None)
            single item at index start if stop is None
            else from start to stop inclusive
        .size()
    others:
        .curselection()
        .selection_includes(index)
        .selection_clear(start, stop = None)
        .selection_set(start, stop = None)
        .see(index)

    :2k: ttk.Scrollbar    
        command:
            pair with a scrollable widget:
                use targetWidget.yview or targetWidget.xview

            on targetWidget:
                xscrollcommand
                yscrollcommand
                    use corresponding scrollbar's set command
    :2l: ttk.Sizegrip
    :2m: tkinter.Text
        wrap, undo
        methods:
            .see(index)
                index: (lineNumber.charNumber)
                line = 1-based, charNumber = 0-based
                (1.0 = first line 0th char)
                tagname.first
                tagname.last
                markname
            .get(start, stop)
                start, stop = index format (see .see(index))
                special values:
                    chars: unit for get
                    lines
                    linestart
                    wordstart
                    lineend
                    wordend
                always ends with '\n'
            .insert(index, strval, tags = ())
                index: see .see(index)
                last index is non-inclusive
                tags: associated tags
            .delete(start, stop)
                see .get
            .tag_add(tagname, start, stop)
            .tag_configure(tagname, **kwargs)
                overstrike        background
                relief            bgstipple
                rmargin           borderwidth
                spacing1          elide (hide text)
                spacing2          fgstipple
                spacing3          font
                tabs              foreground
                tabstyle          justify
                underline         lmargin1
                wrap              lmargin2
                                  offset
            .tag_cget(tagname)
                queries configuration values
            tag_raise
            tag_lower
                change priorities
                default: more recent = higher priority
                (clashes = use higher priority to resolve)
            tag_delete(tag)
            tag_remove(tagname, start, stop)
            tag_ranges(tagname)
                list of ranges with tagname
            tag_nextrange
            tag_prevrange
                search tagged range
            tag_names(index = None)
                None: all tags
                index: all tags applied to index
            tag_bind(tagname, 'binddescr', callback)
            mark_set(name, ind)
                mark = just before char at ind
            mark_unset(name)
            mark_next()
            mark_previous()
            mark_names()
            mark_gravity(markname, 'left/right')
                which char does the mark stick to?
                (when text inserted at mark)
            image_create(ind, image=PhotoImage())
            window_create(ind, window=thing)
            search...
            edit_modified
                query if text changed
            edit_undo
            edit_redo
                (for these, undo config should be true)
            peer:
                share text data b/w widgets...
                (like multiwindow in emacs?)
    Other:
        virtual events:
            <<Selection>>
            <<Modified>>

        'sel' tag: selected text

        Marks
            marks: spot between text
            'insert': insert point for new txt when type
            'current': mouse position
        images/widgets
            make sure added im/widget is
            descendent of the text widget they are
            added to
    :2n: ttk.Progressbar
        orient, length (pixels), mode
            mode: determinate
                can give approximate % completion
                change value to between 0 and maximum
                use configure(value = val)
                or configure(variable = tkinter.DoubleVar())
                or progbar.step(amt)
            mode: indeterminate
                bar.start()
                bar.stop()

    :2o: ttk.Scale
        orient, from(_), to, length, variable(float), value,
        command (value appended to args),
        methods:
            state/instate
    :2p: tkinter.Spinbox
        to, from_, textvariable, increment,
        values, command, state
        methods:
            set, get
    :2q: ttk.Separator
        orient
        weird... i don't see anything when I add a separator...

    :2r: ttk.Labelframe
        text
        see Frame

    :2s: ttk.Panedwindow
        resize between adjacent widgets

        orient, height, width
        method:
            add(widget)
            insert(position widget)
            forget(position)

    :2t: ttk.Notebook
        tabbed frames
        methods:
            add(widget, text=tabDescription)
            state(disabled, normal, hidden)
            insert(position, widget, **kwargs)
            forget(position)
            tabs()
            select(arg = None)
                None = currently selected
                else index or widget to select it
            tab(tabindex, **kwargs)
    :2u: ttk.Treeview
        view object and attributes
        scrollable
        





##############################
:3: gemoetry manager
##############################
:3a: grid
    
    idea: columns and rows (put on graph paper)
    ------------------------------
    widget.grid
        column     :
        row        : 
        columnspan :
        rowspan    :
        sticky     : any of 'nswe' (any combination, stretch to be stuck to corresponding spot)
        padx       : 'v1 v2' (if v2 omited, same as v2)(pad within grid) (borderline in master)
        pady       : 'v1 v2'(if v2 omited, same as v1)(pad within grid)(borderline in master)
        ipadx      : same as aboves but
        ipady      : as if borderline is 0 (if frame is 20x20, pad = 10, allocated a 30x30 grid, ipad = stretch
                     pad = don't)
        NOTE:
            this is for putting widget into parent's row/column spot

    ------------------------------
    widget.{row, column}configure
        weight  (growth rate for resizing window)
        minsize (column/row should not shrink beyond that
        pad     (padding values, 'v1, v2, v3, v4' etc
        NOTE:
            this is used for splitting up the widget into row/col


    ------------------------------
    padding
        master.configure(padding = 'values')(pad within grid)
        (padding at edges of master so can wrap a widget in Frame and use Frame's padding

    ------------------------------
    grid_slaves()    : returns map of gridded slaves
    grid_info()      : gives gridinfo on the widget
    grid_configure() : change grid configuration values
    ------------------------------
    grid_forget([list of widgets]): removes them, forgets grid settings
    grid_remove([list of widgets]): removed them, remembers grid settings

##############################
:4: menus
##############################
    root = tkinter.Tk()
    root.tk.call('tk', 'windowingsystem')->'x11', 'win32', 'aqua'

    root.option_add('*tearOff', tk.FALSE)
        allows removal of menu from window to own window

    win = Toplevel(root)
    menubar = tk.Menu(win)
    win['menu'] = menubar

    ex:
        menubar = tk.Menu(parent)
        menu_file = Menu(menubar)
        menu_edit = Menu(menubar)
        menubar.add_cascade(menu = menu_file, label = 'File')
        menubar.add_cascade(menu = menu_edit, label = 'Edit')
        menu_file.add_command(label = 'New', command = func)
        menu_file.add_command(label = 'Open...', command = func)
        menu_file.add_command(label = 'Close', command = func)

    summary:
        add_cascade(menu, label)
            add a submenu
        add_command(command, label, accelerator):
            a menu item
        add_separator()
            ...???
        add_checkbutton(label, variable, onvalue, offvalue, command, accelerator)
        add_radiobuttn(label, variable, value, command, accelerator)
            display indicator
        accelerators: just an indication of associated shortcut keys
            (still have to manually create the bindings though)

    other configs:
        underline = index_of_letter_to_underline
        image = tk.PhotoImage
                PIL.ImageTk.PhotoImage
        compound = l,t,rb, center, none

    
    ##############################
    context menus (right click)
        create menu,
        menu.post(x,y)

##############################
:5: windows
##############################
newWindow = tk.Toplevel(parent)

window methods:
    geometry(arg = None)
        if None:
            return current geometry
        else:
            '[width]x[height][+/-][posx][+/-][posy]'
            (+ => distance from top/left,
             - => distance from bottom/right)
        example:
            make window 500x500, move top left to 0,0
                root.geometry('500x500+/-0+/-0')
                (can omit one of size or position)
            move to top right
                '-0+0'
    title(arg = None)
        if None:
            return current title
        else:
            set the title, return ''

    after(milliseconds, lambda):
        call lambda (no args) after milliseconds


    lift(otherWindow = None)
    lower(otherWindow = None)
        move to the extremes if None
        else:
            to just above/below the other window

        NOTE:
            above 2 are for stack order
            root.tk.eval('wm stackorder '+str(root))
            returns a str with str(window)
            as order of windows from bottom to top
            can use str.index EXCEPT:
                observation: root is '.'
                tops are '.[some number]'
                implies str.index(root) is always 0
                may need to use regexp
                or... seems to be space delimited
                add space to ends and do .index(
                ' ' + str(desiredWindow) + ' ')
        NOTE2:
            the stackorder is only aware of things
            under the same root
            make another root, it is not seen
        NOTE3:
            root seems like it is always '.'
            might be able to just do
            window.tk.eval('wm stackorder .')
        NOTE4:
            wm stackorder {}
            works with "sibling widgets" too (widgets in same plane?)
    resizable(xok, yok)
        T/F if x/y resizable or not
    minsize(x,y)
    maxsize(x,y)

    iconify()
    deiconify()
    withdraw()
    state(state)
        'normal'
        'iconic'
        'withdrawn'
        NOTE:
            on ubuntu, deiconify works after withdraw()
            but not after iconify()
##############################
:6:dialogs
##############################
files:
    from tkinter import filedialog
    filedialog.askopenfilename()
    filedialog.asksaveasfilename()
        kwargs:
            confirmoverwrite = T/F, default=True
            defaultextension: adds extension if user doesn't add one
            filetypes: ['name {extensions...}']
                       ex:
                           ['txt {.txt}',
                           'jpg {.jpg .JPEG .jpeg}',
                           'all {*}']
            initialdir: path_to_initial_dir
            initialfile: path_to_initial_file
            multiple: T/F, can choose multiple files when opening?
            parent: window: makes dialog appear on top of parent
            title: title of dialogbox
    filedialog.askdirectory()
        kwargs:
            initialdir
            mustexist
            parent
            title
    return values:
        success = return FULL PATH
        fail(canceled) = ''
colors:
    from tkinter import colorchooser
    colorchooser.askcolor(initialcolor = '#FF0000')
messages:
    from tkinter import messagebox
        askokcancel
        askquestion
        askretrycancel
        askyesno
        askyesnocancel
        showerror
        showinfo
        showwarning
    args:
        title    : title
        message  : message
        detail   : extra stuff
        icon     : 'info', 'error', 'question', 'warning'
        default  : 'ok', 'cancel', 'retry', etc...
                   (which button to have initial focus)
        parent   : parent window
##############################
:7: fonts
##############################
should create a style and use style
instead of directly using the font option
  
    ------------------------------
    default fonts
    ------------------------------
    TkDefaultFont         : for everything else
    TkTextFont            : text entry widgets
    TkFixedFont           : fixed-width
    TkMenuFont            : menu
    TkHeadingFont         : column headings
    TkCaptionFont         : for dialog caption bars
    TkSmallCaptionFont    : smaller form of above
    TkIconFont            : icon captions
    TkTooltipFont         : tooltips
    
  
    from tkinter import font
    font.Font(family = 'fontFamily', size = size, weight = weight)
  
    weight:          'bold', 'normal'
    slant:           'roman', 'italic'
    underline:       bool
    overstrike:      bool
    
    NOTE:
        guaranteed:
            Courier, Times, Helvetica
            Monospaced, serif, sans-serif
        font.families() to get all families
        NOTE:
            must call tkinter.Tk() before font.families()
    alternative: font descriptions
        ex: 'Helvetica 12 bold italic'


##############################
:8: colors
##############################
system specific color names
rgb "#[hexvalue]"
x11 (mostly just use very common basic colors)

colors reference:
http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm

##############################
:9: images
##############################
tk.PhotoImage(file = 'file.gif')
default allowable formats:
    gif
    PPM/PNM

pip install pillow
from PIL import ImageTk, Image
ImageTk.PhotoImage(file = 'fname')
ImageTk.PhotoImage(Image.fromarray(
    numpy_array_image(RGB)))


    more image formats available


##############################
:10: canvas
##############################
Tk.Canvas(parent)
    represents a canvas to draw stuff on
width, height: space in UI
scrollregion: actual size, ex("0 0 1000 1000")???

create_window((x,y), window = widget, anchor = 'nsew')
NOTE: canvas is scrollable





______________________________
item options:
    use canvas.itemconfigure(value, **options)
    to change options, or set when
    creating it

    acitvedash          : 
    activefill          : 
    activestipple       : 
    activewidth         : 
    arrow               : 
    arrowshape          : 
    capstyle            : 
    dash                : 
    dashoffset          : 
    disableddash        : 
    disabledfill        : 
    disabledstipple     : 
    disabledwidth       : 
    fill                : color
    joinstyle           : 
    offset              : 
    smooth              : 
    splinesteps         : 
    state               : 
    stipple             : 
    tags                : tags: extra group ids
    width               : pixel width

______________________________
adding items:
    call a function, returns a value
    item can be modified by

    canvas.create_line(x0,y0,x1,y1)
    canvas.create_rectangle
    canvas.create_oval
    canvas.create_arc
    canvas.create_polygon
    canvas.create_image
    canvas.create_bitmap
    canvas.create_text
    canvas.create_window
        (other widgets in a frame)
    


        
______________________________
binding:
    canvas.tag_bind(
        itemID, 'bindingDescr', callback)

______________________________
tagging:
    canvas.addtag(tag, modifier, identifier):
        tag: tag to add
        modifier: 'withtag'
    canvas.gettags()
        return list of tags for an item
    canvas.find_withtag(desiredTag)
        returns list of corresponding ids
    canvas.dtag(identifier, tag)
        removes tag from identified

______________________________
others
    canvas.delete(identifier)
    canvas.move(identifier, amt)
    canvas.coords(identifier, coords)
    canvas.raise(identifier)
    canvas.lower(identifier)

    canvas.canvasx(val)
    canvas.canvasy(val)
        translates event.x event.y to
        actual canvas coordinates
