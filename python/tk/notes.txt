Contents
-0- tcl
	-0.0- call vs eval
		-0.0.1- call
		-0.0.2- eval
	-0.1- syntax
	-0.2- tcl commands
-1- general
	-1.0- Terms
	-1.1- Widgets
		-1.1.1- Callbacks
		-1.1.2- Validation
		-1.1.3- focus
		-1.1.4- scrolling
		-1.1.5- winfo
	-1.2- Grid
	-1.3- Variables
	-1.4- Colors
	-1.5- fonts
	-1.6- helpers
		-1.6.1- filedialog
		-1.6.2- messagebox
		-1.6.3- colorchooser
		-1.6.4- simpledialog
	-1.7- clipboard
	-1.8- window manager
	-1.9- images
	-1.10- threads
-2- Bindings
	-2.1- Event Sequences
		-2.1.1- Modifiers
		-2.1.2- Event type
		-2.1.3- Keypress names
	-2.2- Event Objects
	-2.3- Generation
	-2.4- Other Notes
-3- Widgets
	-3.1- Button
	-3.2- Canvas
	-3.3- Checkbutton
	-3.4- Entry
	-3.5- Frame
	-3.6- Label
	-3.7- Listbox
	-3.8- Menu
	-3.9- Menubutton
	-3.10- Radiobutton
	-3.11- Scale
	-3.12- Scrollbar
	-3.13- Spinbox
	-3.14- Text

------------------------------
miscellaneous observations
1. different platforms (windows, wsl, x-wayland)
   (?tk seems to not support wayland? so only x-wayland)
   seem to have slightly different behaviors:
   1. only windows seems to allow mouse warping
   2. Upon deiconify and full screen, windows only has <Enter> (which gives proper mouse position)
      wsl, x-wayland follows <Enter> with <Motion>.
      However, <Enter> has old mouse position and <Motion> has correct mouse position.
      attempting to detech which is which seems to fail...
      ex: update() does not wait for the triggered <Motion>, sometimes, not even the triggered <Enter>
      to complete...
      Tested on arch, the <motion> event only fires if fullscreen
      is turned on after deiconify
      on wsl, if geometry to full screen, then toggle fullscreen
      on deiconify/withdraw, then events are fired twice
   3. after deiconify/fullscreen, update() only seems to wait for <Configure>
      sometimes <Enter> is before or after.  On windows, <Enter> seems to always
      be after... <Motion> is only after multiple update() calls.
   4. Seems like to detect whether <Motion> will be fired after deiconify+fullscreen
      must just wait some time after deiconify+fullscreen, and then see if it
      was fired or not, assuming the wait time is long enough and user did not move mouse



______________________________
-0- tcl
	Tcl is the interpreter (handles parsing and running commands).
	Tk is the gui (handles displaying gui, events, etc).
	Tkinter is a wrapper over Tcl/Tk.

	The tcl interpreter can be accessed from the Tk.tk.call() method.

	ex:
		import tkinter as tk
		r = tk.Tk()
		r.tk.call('bind', r, '<Escape>', 'destroy {}'.format(r))
		r.wait_window()

	______________________________
	-0.0- call vs eval

	Tkinter has 2 methods for interacting directly with the tcl interpreter.
	The first is call() (tkinter.Tk.tk.call).
	The second is eval() (tkinter.Tk.tk.eval).

	tkinter.Tk seems to forward call and eval to tkinter.Tk.tk

		______________________________
		-0.0.1- call
			Each argument to call() will be converted to str and properly escaped.
			This means that call is unsuitable for any more complex expression than
			single literal strings.
			Call will however, attempt to interpret the return results of the expression.
			ex:
				r = tk.Tk()
				r.call('expr', '3 + 2') -> int(5)


		______________________________
		-0.0.2- eval
			eval() takes a single string argument that is an expression/script for tcl to
			interpret.  This means that the full tcl syntax is allowed.  However, it does
			not attempt to interpret the output, so it always returns a str.

			ex increment a variable:
				r = tk.Tk()
				x = tk.IntVar(r, 2)
				r.eval(f'set {x} [expr ${x} + 1]') -> str(3)

				NOTE: this is not possible with call() because the [] expr would
				be changed to a literal string.

	______________________________
	-0.1- syntax
	cmd arg arg arg
		words separated by whitespace.
		The first word is the command.
		The remaining words are arguments.

	$foo
		Dereference a variable

	[clock seconds]
		like bash command substitution.
		Run the command with given args.
		Evaluate to the output

	"some stuff"
		Group words into a single argument.
		[] and $ are available inside string.

	{some stuff}
		Like single quotes in bash.
		Group words into a single word, but 0 interpretation.

	\
		escape the next character.

	Steps in parsing are:
		grouping
		substitution
		command dispatch

	______________________________
	-0.2- tcl commands

	______________________________
	set variable value
		Sets a variable to a value.
		The variable can be dereferenced with $variable

	______________________________
	expr expression
		Evaluate an expression.  This could be a mathematical expression.
		It could be a str.

			-+~!        (unary) negative, positive, bit-wise not, logical not
			**          exponent
			*/%         multiply/divide/remainder(pos)
			+-          add/subtract
			<<>>        left/right (signed)bitshift
			<> <= >=    comparison, strings or nums ok
			== !=       equality, all types ok
			eq ne       str comparison
			in ni       contained, negated contains (ni = not in)
			&^|         bitwise operators
			&&||        logical [and|or], numeric only
			x?y:z       ternary, x must be bool or numeric

		examples:
			set a 32
			puts $a       # prints '$a'
			expr $a       # prints 32
			expr $a + 5   # prints 37
			expr "$a + 5" # prints the string "32 + 5"
	______________________________
	puts args
		print arguments
		THIS IS LITERAL, so there is no variable expansion etc.
		use expr instead for variable expansion.

	______________________________
	loops
		loops are just like any other command.

		example:
			while {$i < 10} {
				puts "$i squared = [expr {$i*$i}]"
				incr i
			}

			2 arguments are given: an unevaluated str literal $i < 10
			and the str literal {puts ... }


	sidenote... this being the case, it would be possible to just write:
		commands = {}
		def callpy(command, *args):
			return commands[command](*args)
		r = tk.Tk()
		r.createcommand('callpy', callpy)

	Then any scripts/binding
	can just call the 'callpy' command and it will
	call any function stored by the commands dict.
	In tk, instead, it calls createcommand for every new binding/after, etc
	idk if that would affect performance in any way.

	example 2:
		whenever tk bind is called, it creates script like:
		'if {"[2235275164928callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n\n
		 if {"[2235301124864callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n'

		the script is 1 command per line
		if, the expression, and then break.

	Directly using tcl scripts and Tk.call() give much more flexibility and control
	over just using the Tkinter defaults.

______________________________
-1- general

	General usage is create a Tk instance
		import tkinter as tk
		r = tk.Tk()
		...
		r.mainloop(N)

	NOTE:
		mainloop runs until N tk interpreters remain.  N defaults to 0.
		examples:
			Must close both to exit mainloop()
				r1 = tk.Tk(); r2 = tk.Tk(); r2.mainloop()

			Close one root to exit mainloop(), either one works...
				r1 = tk.Tk(); r2 = tk.Tk(); r3 = tk.Toplevel(r1); r3.title('toplevel1'); r4 = tk.Toplevel(r2); r4.title('toplevel2'); r2.mainloop(1)

		wait_window() on root window might be the better choice compared to mainloop()
		if there is a possibility of multiple tkinter instances.

	tk is a wrapper over tcl.
	tcl can be accessed directly via widget.tk.call which invokes
	tcl commands.  (Everything is a string, user must handle type conversions)

	______________________________
	-1.0- Terms
		active: mouse is over the item/interacting with item
			(if click+drag away from item, it is still active until released)

		stipple: use something like pointilism to display.  Kind of like
			alpha but not quite.
			always available:
				error
				gray75
				gray50
				gray25
				gray12
				hourglass
				info
				questhead
				question
				warning
			Macintosh only
				document
				stationery
				edition
				application
				accessory
				folder
				pfolder
				trash
				floppy
				ramdisk
				cdrom
				preferences
				querydoc
				stop
				note
				caution


	______________________________
	-1.1- Widgets
		Widgets are tk classes.  They take a parent and kwargs.
		kwargs are usually also able to be passed after creation via
		widget.configure().  widget.cget('property') retrieves property
		value.

		attributes:
			master: first argument to __init__

		useful methods:
			configure(...):
				If no args: return dict of all configs
					Values are a 4-tuple:
						(kwarg, dbname, dbclass, value)
				If a name is given then return the corresponding value in the returned dict.
				If kwargs/dict: set the corresponding config values
			cget(config)
				get value for config
			nametowidget(name)
				convert name (str) to a widget

		configs:
			state:
				State generally has 'normal', 'disabled' and maybe others depending
				on widget.

			General configure() options:
				cursor:
					X_cursor
					arrow
					based_arrow_down
					based_arrow_up
					boat
					bogosity
					bottom_left_corner
					bottom_right_corner
					bottom_side
					bottom_tee
					box_spiral
					center_ptr
					circle
					clock
					coffee_mug
					cross
					cross_reverse
					crosshair
					diamond_cross
					dot
					dotbox
					double_arrow
					draft_large
					draft_small
					draped_box
					exchange
					fleur
					gobbler
					gumby
					hand1
					hand2
					heart
					icon
					iron_cross
					left_ptr
					left_side
					left_tee
					leftbutton
					ll_angle
					lr_angle
					man
					middlebutton
					mouse
					none
					pencil
					pirate
					plus
					question_arrow
					right_ptr
					right_side
					right_tee
					rightbutton
					rtl_logo
					sailboat
					sb_down_arrow
					sb_h_double_arrow
					sb_left_arrow
					sb_right_arrow
					sb_up_arrow
					sb_v_double_arrow
					shuttle
					sizing
					spider
					spraycan
					star
					target
					tcross
					top_left_arrow
					top_left_corner
					top_right_corner
					top_side
					top_tee
					trek
					ul_angle
					umbrella
					ur_angle
					watch
					xterm
		______________________________
		-1.1.1- Callbacks
			callbacks in tk are "scripts"
			In general, it would be a commandname followed by arguments like
				'commandname arg1 arg2 ...'.  In some cases, a tuple can be
				used as well. (though prefer str)
			Existence of a command can be checked with info command (TCL only):
				widget.tk.call('info', 'command', 'nameofcommand')->
					('nameofcommand',) #it exists
					'' # does not exist

			base commands (widget.tk):
				createcommand(name, f):
					This maps a function f to name where f is a python function
					and name is a tcl name.
				deletecommand(name):
					This deletes the mapping between name and f.
			related (widget) commands:
				register(func, subst, needcleanup=1):
					func: the func to register
					subst: a conversion function for args: tuple->tuple
					needcleanup: call deletecommand if widget deleted.

					Return name of Wrapped func(*(args if subst is None else subst(*args)))

				bind(seq, function, add=None):
					seq: event sequence
					function: function to bind
					add: add or overwrite

					Calls register with needcleanup=1, subst=widget._substitute etc
						_substitute takes list of "all" bind % substitutions and merges
						into an Event object.

				bind_class(tag, seq, func, add=None):
					same as widget.bind but use tag
					registered with needcleanup=0 so the bound class is intact
					even if this widget is destroyed

			ex 1: validation
				def validate(proposed_string):
				    dostuff

				method 1: register
					r = tk.Tk()
					e = tk.Entry(r, validate='key')
					e.configure(validatecommand=(e.register(validate), '%P'))

				method 2: base calls
					r = tk.Tk()
					r.tk.createcommand('validateTCLname', validate)
					e = tk.Entry(r, validate='key', validatecommand=('validateTCLname', '%P'))
					OR
					e = tk.Entry(r, validate='key', validatecommand='validateTCLname %P')

				On validation, myvalidatefunction(%P) will be called.
				In this case, because validation has special handling for %P
				and %W, the %P and %W will be converted to the corresponding
				values and then passed to the function (all as strings)

			ex 2: binding
				def raw(root, widget, keysym):
				    e = Event()
				    e.widget = root.nametowidget(widget)
				    e.keysym = keysym
				    callbackfunc(e)
				def callbackfunc(e):
				    dostuff(e)
				r = tk.Tk()

				method 1: bind
					r.bind_class('all', '<KeyPress>', callbackfunc)

				method 2: direct calls
					r.tk.createcommand('mycallback', raw)
					r.tk.call(('bind', 'all', '<KeyPress>', 'mycallback %W %K'))

		______________________________
		-1.1.2- Validation
			validate=[none|focus|focusin|focusout|key|all]
			validatecommand=(widget.register(func), <code args>...)
				%d: action type:  1: insert, 0: delete, -1: focus, forced, validation
				%i: idx of char to be inserted/deleted, else -1
				%P: pending value
				%s: current value
				%S: text to be inserted/deleted
				%v: type of validation currently set (validate property)
				%V: type of validation that triggered cb (validate property)
				%W: widget

			invalidcommand=func

		______________________________
		-1.1.3- focus
			focus indicates which widget will receive keyboard events.
			methods(no args):
				focus/focus_set set keyboard focus next time user focuses on the
				                window, keyboard events will be sent to the
				                widget.
				focus_force     set keyboard focus AND make corresponding
				                toplevel window focused.
				focus_get       get name of currently focused widget
				tk_focusNext    move focus to next item
				tk_focusPrev    move focus to previous item
		______________________________
		-1.1.4- scrolling
			tk.Scrollbar
				orient='horizontal'|'vertical'
				command=widget.[x|y]view

			widget.configure([x|y]scrollcommand=scrollbar.set)

		______________________________
		-1.1.5- winfo
			geometry: window shape and position
				<width>x<height>+<x>+<y>
			height(): pixel height
			width(): pixel width
			pointer[x|xy|y]: returns pointer screen coordinates
			reqheight(): requested height
			reqwidth(): requested width
			screen[height|width]: dimensions of screen
			toplevel(): name of toplevel widget(combine with nametowidget)
			root[x|y]: screen coordinates of top-left of widget itself
			[x|y]:
				for toplevel: xy of top-left window manager window: the
					top window bar+outline.  May be farther left than the visual
					window top-left(on windows 10, it seems to be shifted 8px to
					the right, ie. x=-8 to put window on left edge of the screen.
					(seems to match geometry() +x+y coordinates)
				for widget: xy in parent widget

	______________________________
	-1.2- Grid
		grid splits widgets up into a grid of space and places widgets accordingly.
		Note that widgets can only be gridded into

		grid(**args...):
		grid_configure(**args...):
			row: the row
			column: the column,
			[row|column]span: width in terms of grid.
			sticky: string of flags 'nsew' to stick to top,bottom,right,left
			[i]pad[x|y]: padding i=internal (inside widget, ie make widget
				bigger, add to its wifno_req[width|height]()),
				otherwise external (between grid rows/cols)
				x, y = the direction
				ipad* must be int
				pad* can be int(same value for both sides) or pair(left/right, or top/bottom)
			[in|in_]: 'in' if dict, or in_ because in is a python keyword.
				Place the widget in to the specified container widget.
				NOTE: container must be a parent or descended from parent.

		grid_bbox(x1=None,y1=None,x2=None,y2=None):
			get bounding box (screen coordinates) of grid
			if x1,y1 given: get bbox of that grid
			if x2,y2 given, get bbox of slice from x1,y1 to x2,y2

		grid_rowconfigure(idx, props)
		grid_columnconfigure(idx, props)
			idx: a col/row idx or list of idxs, 'all' or widget name
			properties:
				weight: weighting for space distribution of this row/col on
					resizing
				minsize: minimum pixel value of this row/col
				pad: padding within row/column, ignored if sticky='nsew'?
					padding added to largest col/row
				uniform: columns in same uniform group (same uniform value)
					have space strictly proportional to weight value???
					(isn't this already the case?)


		grid_info():
			return dict of grid() command arguments

		grid_location(x, y):
			return grid row/column of x,y widget coordinates.
			eg. get x,y from mouse event, use grid_location to calc which
			row/col

		grid_slaves(row=None, column=None):
			Return widgets in the container.
			row/column = only return the ones in specified row/col
		grid_size():
			return size of grid (largest column/row occupied/configured)

		grid_remove
		grid_forget
			remove the widget, for remove, also remember settings
			so grid() will place it as it was before removal



	______________________________
	-1.3- Variables
		IntVar, StringVar, BooleanVar, DoubleVar
		methods:
			set(val)
			get()
			name = trace('r|w|u', func)
			trace_vdelete('r|w|u', name)
			trace_vinfo()

		NOTE:
			textvariable/listvariable: variable containing value to be displayed
				(variable like text in entry widget or displayed, (configure(text=variable.get()))
			variable: variable whose value is changed/managed by the widget
				(like checkbutton or radiobutton)

		Some tk widgets can take a variable as an config argument
		(variable, textvariable, listvariable, etc).  The variable will be
		auto-updated with the widget's contents.
		Callback take 3 arguments: callback(varname, ??, modestr)

	______________________________
	-1.4- Colors
		#rrggbb (hex values, 0-255)
		name    (string name of color like 'black')

		winfo_rgb(color)
			Return the R,G,B color tuple. Values are 0-65535

	______________________________
	-1.5- fonts
		py2: from Tkinter tkFont
		py3: from tkinter import font

		Fonts are strings
			* name of a created font:
				A named font (maybe created or default)
					font create ?name? options
					ex: copy the default font
					eval font create [font actual TkDefaultFont]
			* String of name and settings:
				A string of the form:
					family ?size? ?options...?
						options:
							normal bold roman italic underline overstrike
			* A string of options same as with font create
				-family (from [font families])
				        guaranteed font families: Courier, Times, Helvetica
				-size positive: points
				      negative: pixels
				-weight *normal bold
				-slant  *roman italic
				-underline  *false true
				-overstrike *false true


		font.Font(
		    family: Courier, Times, Helvetica (mono, serif, sans-serif)
		            guaranteed, others optional.
		    size: font size
		    weight: bold/normal
		    slant: roman/italic
		    underline: true/false
		    overstrike: true/false
		    name: name of font (used by tk.nametofont)
			)
		font.families()
			list available families
		methods:
			metrics([key]): get metric or dict
				ascent: space above line (like size of an A)
				descent: space below line (like bottom of p or g)
				linespace: line height
				fixed: True/False
			configure(): set properties
			measure(text):
				get width of text


	______________________________
	-1.6- helpers
		______________________________
		-1.6.1- filedialog
			popups for opening/saving filenames/directories
			options:
				defaultextension        default extension to use on filename if missing
				filetypes               tuple of tuples:
				                        (('filetype name', '*.ext1 *.ext2 ...')...)
				                        (pattern=space-delimited patterns)
				initialdir
				initialfile
				parent
				title
				multiple                boolean, select multiple items?
			directory only:
				mustexist               boolean

			methods:
				askopenfilename(s)
				asksaveasfilename
				askdirectory

			NOTE:
				These methods generally give empty string on cancel instead of
				None.

		______________________________
		-1.6.2- messagebox
			display a message, simple response buttons

			options:
				default         default button (name of reply)
				                ABORT RETRY IGNORE OK CANCEL YES NO
				icon
				message
				parent
				title
				type

			methods
				askokcancel
				askquestion
				askretrycancel
				askyesno
				askyesnocancel
				showerror
				showinfo
				showwarning


	______________________________
	-1.7- clipboard
		clipboard_get()
			type: same as below
		clipboard_append()
			type: STRING | FILE_NAME?? | UTF8_STRING??
			format: STRING: 8-bit ascii characters
			        ATOM: 4 bytes??
			        anything else: string of 32-bit ints??
		clipboard_clear()
			Clear before append to set value.
			Otherwise, it'll just keep concatenating values.

	______________________________
	-1.8- window manager
		The window manager manages windows...
		On Windows 10?, window manager pushes windows a few pixels to the right.
		tk.Tk().geometry('+0+0') does not place the window at topleft.
		in tkinter, wm commands don't have the wm prefix:
			ie: to do wm attributes, just do tk.Tk().attributes(...)

		attributes: set/get various attributes:
			use no args to find valid attributes (flattened Nx2 array)
			Options vary by OS
			unix (tested on wsl ubuntu):
				-alpha (??)
				-topmost (bool)
				-zoomed (?bool?)
				-fullscreen (?bool?)
				-type (??)
			options on windows
				-fullscreen (bool)
				-topmost (bool)
				-toolwindow (bool) "toolwindow style window", like a popup can alt tab to it
				                   but it will not show up in bottom bar.
				-disabled (bool)
				-alpha (0-1)
				-transparentcolor (index)
		deiconify()
		geometry: similar to winfo_geometry, but allows setting geometry
			<width>x<height>+x+y, can ommit width/height or x/y
		iconbitmap: specify a bitmap for window icon
		iconify()
		maxsize(width, height)
		minsize(width, height)
		resizable(dowidth, doheight): allow width/height to be resizeable
		state(state): normal, iconic, withdrawn, icon, or zoomed(win/macos)
		title(title): set window title

		overrideredirect: ignore window manager->no top ribbon, doesn't show
			up in list of windows, etc, attributes are invalid.
	______________________________
	-1.9- images
		use pillow:
			from PIL import Image, ImageTk
			images:
				ImageTk.PhotoImage(
					Image.open(file path)
					Image.fromarray(numpy array))
				ImageTk.BitmapImage(
					Image.open(file path).convert('1')
					Image.fromarray(numpy array).convert('1'))
					('1' = number 1 not lower L)
		NOTE:
			a reference to ImageTk.PhotoImage must be retained
			or else the image will be freed.
	______________________________
	-1.10- threads
	In general, tk is threadsafe (because python is threadsafe)
	However, there are some things to note:
	1. The tcl interpreter is single threaded.  This means that
	   you cannot call any tk interpreter methods until it is idle.
	2. event_generate() is generally what you would use to signal the tk interpreter
	   from a different thread.  This way, all the tk methods etc would be running
	   in the main thread.
______________________________
-2- Bindings
	Bindings associate some event sequence with a script.
	They are associated with a bindtag.  Every widget has a bindtag
	available with widget.bindtags().  (tcl: bindtags widgetname)
	Bindtags can be set with widget.bindtags((tag1, tag2, tag3...))
	(tcl: 'bindtags widgetname {tag1 tag2 "tag3 with space" tag4...}')

	Whenever an event is fired on a widget, its bind tags will be walked
	through in order.  Any matching bindings associated with that bind
	tag will be run.

	In Tkinter, widget.bind(seq, func) performs this sequence of actions:
	1. wrap func to pass it arguments.
	2. Tk.createcommand('generatedname', wrapped_func)
	3. Tk.call('bind', widgetname, evseq, 'generatedname %...')

	The Tk.createcommand creates a mapping between a tcl command 'generatedname'
	and the python function wrapped_func.  In tcl, whenever 'generatedname'
	is used as a command, any given arguments will then be passed on to wrapped_func
	in order, as str.  The wrapping accepts these str values, converts them, and
	then adds them to an Tkinter Event object.

	In Tkinter, the returning 'break' to stop event propagation is handled through the script
	which is actually in the form of if {"[generatedname args...]" == "break"} break\n
	Appending to a binding is just generating a new script and appending it to the
	original script.  Blank lines are ignored.



	If callback is a function, then the corresponding registered id is
	returned.  If it is a str, the returnvalue is None.

	NOTE:
		more specifically:
			tcl binds a script to a bindtag and event sequence specifier.
			the script is a string, and if prefixed with + will be appended
			to any existing scripts.
			tkinter wraps any bindings by:
				1. wrap a function in a CallWrapper.  CallWrapper combines a
					function with a substitute function and widget.  The substitute
					function takes args and converts them.  (default is widget._substitute
					which takes the default %<char> args and converts to particular
					types)
				2. Register the resulting CallWrapper under id(wrapper)+func.__name__
					by using tk.createcommand(name, func) (delete by tk.deletecommand(name))
				3. Bind a script using the registered function in step 2:
					'if {"[2235275164928callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n\n
					 if {"[2235301124864callback %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y %D]" == "break"} break\n'

			In otherwords, for more control (not sure if parsing the extra
			arguments may also reduce performance by any significant amount)
				method 1: use register and the callwrapper mechanism:
					def substitute(raw '%char' return values as strs):
					    return (converted, arguments,...)
					def somecallback(args, that, match, substitute):
					    ...
					funcid = widget.register(somecallback, substitute, needcleanup=0/1)
						(needcleanup will add to widget._tclCommands, contents of which will be
						tk.deletecommand()ed on __del__)
					widget.bind('{funcid} %<char> ...'), add the %<char> values you are interested in
				method 2:
					use tk.createcommand directly:
					def func(someargs):
					    ...
					tk.createcommand(name, func)
					widget.bind(seq, '{name} %char %char ...')
	Canvas items:
		Fuse canvas.[tag_bind|gettags|addtag] instead of bind/bindtags.
		Note that for canvas items there is no way to set multiple tags.
		To reorder tags, you must remove tags and then add them again.

	When an event is created on a widget, each tag in widget.bindtags is
	considered.  If there is a binding for the event on that tag, then the
	corresponding callback will be called.
	eg. In tkinter, widgets by default have bindtags: ('path', 'class', '.', 'all')
	This means bindings to the particular instance, the class bindings, then the
	owning Tk() instance, and finally the 'all' tag.

	tkwidget.bind(): bind to current widget's path
	tkwidget.bind_class(path, ...): bind to the given path
	Note that tkwidiget.bind() is basically tkwidget.bind_class(str(tkwidget), ...)

	In tkinter, callbacks that are functions will be .register()ed.
	The callback can also be a str in which case it is used directly
	(example, a single space would cause it to become a noop)

	______________________________
	-2.1- Event Sequences
		'<modifier-...-event>': An event sequence corresponding directly to
			some keyboard/mouse input.
		'key': same as '<key>'
		'<<eventname>>': a virtual event.

		______________________________
		-2.1.1- Modifiers
			key/button          bindseq   state (%s substitution)
			Control             Mod1, M1, Command(num lock)
			Alt                 Mod2, M2, Option(alt)
			Shift               Mod3, M3, (scroll lock)
			Lock                Mod4, M4
			Extended            Mod5, M5
			Button1, B1         Meta, M
			Button2, B2         Double
			Button3, B3         Triple
			Button4, B4         Quadruple
			Button5, B5
		______________________________
		-2.1.2- Event type
			Activate                 FocusOut
			ButtonPress, Button      Gravity
			ButtonRelease            KeyPress, Key
			Circulate                KeyRelease
			CirculateRequest         Leave
			Colormap                 Map
			Configure                MapRequest
			ConfigureRequest         Motion
			Create                   MouseWheel
			Deactivate               Property
			Destroy                  Reparent
			Enter                    ResizeRequest
			Expose                   Unmap
			FocusIn                  Visibility

		NOTE: MouseWheel is usually only on mac/windows.
			Use button4(up) and button5(down) otherwise.

		Observations about Motion events:
			Documentation says if several motion events occur in a row,
			only the last is used for bind matching purposes.  However, it is
			unclear how this is done.  When using warp, a new Motion event is
			only generated if the mouse is not already at the coordinate.
			The event from event_generate and the motion from warp are
			considered separate things.  The warp happens at time of event
			generation.  The callbacks happen in queue order.  The merging
			of Motion events also seems to happen at enqueueing time.
			(If enqueue at end, check last items to see if merge)

			generate warp <Motion> events from x=y=0 to x=y=10
			1. final mouse position is always 10 regardles of 'when'
			2. if when ==
				'tail': only 1 <Motion> callback is called (and maybe a generated one too)
				'head': all <Motion> callbacks are called
				'mark': all <Motion> callbacks are called
				'now': all <Motion> callbacks are called immediately
			3. Motion events are only created naturally if the cursor is
				already within the application window.  (otherwise is <Enter>
				when first enterring the window from outside)

			As an example, if you are trying to lock mouse position.
			if tail:
				the newly generated <Motion> events will be enqueued at tail
				and may be overwritten by actual mouse movements.  As a result,
				the generated event will warp, but might not be processed (merged
				with actual mouse motions).  To ensure processing, must event_generate
				with head, mark or now.  If event_generate with now, then it may
				also result in incorrect behavior with sequence of events:
					<Motion>(bindtag1)
					event generate when=now!
					generated<Motion>(bindtag1)
					generated<Motion>(bindtag2)
					return from <Motion>(bindtag1)
					<Motion>(bindtag2)


		______________________________
		-2.1.3- Keypress names
			a-zA-Z0-9
			space
			grave               `
			asciitilde          ~
			exclam              !
			at                  @
			numbersign          #
			dollar              $
			percent             %
			asciicircum         ^
			ampersand           &
			asterisk            *
			paren[left|right]   ()
			minus               -
			underscore          _
			equal               =
			plus                +
			bracket[left|right] []
			brace[left|right]   {}
			backslash           \
			bar                 |
			semicolon           ;
			colon               :
			apostrophe          '
			quotedbl            "
			comma               ,
			less                <
			period              .
			greater             >
			slash               /
			question            ?

			F1-12
			Escape
			BackSpace
			Return
			Insert
			Home
			Prior     (page up)
			Delete
			End
			Next      (page down)
			Tab
			[Caps|Scroll|Num]_Lock
			Pause
			[Super|Alt|Shift|Control]_[L|R]
			Menu

			Up
			Left
			Down
			Right

		OBSERVATION:
			printable = all lowercase?
			non-printable = capitalized?
			exceptions:
				Tab
				Return


	______________________________
	-2.2- Event objects
		Callbacks take a single event as argument.
		properties:
			above       %a: a window
			borderwidth %B: a size (screen dist)
			button      %b: mouse button number -> num
			char        %A: printable ascii character
			count       %c: int, ??
			data        %d: string, user data (virtual events)
			delta       %D: int, scroll amount, +=up, -=down (MouseWheel event on windows)
			detail      %d: Notify[Ancestor|DetailNone|Inferior|Nonlinear|
			                       NonlinearVirtual|Pointer|PointerRoot|Virtual]
			focus       %f: bool, if window has focus
			height      %h: int, screendist
			keycode     %k: int (the actual keyboard key identifier)
			keysym      %K: string, key name (as would be used for bind)
			keysym_num  %N: int representing the (virtual)key that was pressed
			                eg.
			                  <Shift-m>, keycode = 77, and keysym_num = 77, chr(77) = 'M')
			                  <m>, keycode = 77, keysym_num = 109, chr(109) = 'm')
			mode        %m: Notify[Normal|Grab|Ungrab|WhileGrabbed]
			override    %o: bool
			place       %p: Place[OnTop|OnBottom]
			root        %R: str, window path??
			rootx       %X: int, screendist (on screen) -> x_root
			rooty       %Y: int, screendist (on screen) -> y_root
			                NOTE:
			                  rootx and rooty  when event_generate will become x/y instead of rootx/rooty
			sendevent   %E: bool, 0 = "normal", 1 = "synthetic" ???
			serial      %#: int, nth event
			state       %s: int or Visibility[Unobscured|PartiallyObscured|FullyObscured]
			                state int values (looking at tkinter/__init__.py Event.__repr__)
			                  bit meaning
			                  0   Shift
			                  1   Caps_Lock
			                  2   Control
			                  3   Mod1
			                  4   Mod2
			                  5   Mod3
			                  6   Mod4
			                  7   Mod5
			                  8   B1
			                  9   B2
			                  10  B3
			                  11  B4
			                  12  B5
			                  17  Alt
			subwindow   %S: string (path name) or int (window id)
			time        %t: int, timestamp
			type        %T: type field from event: (tk.EventType(strint) for py3)
			                KeyPress = '2'
			                Key = KeyPress,
			                KeyRelease = '3'
			                ButtonPress = '4'
			                Button = ButtonPress,
			                ButtonRelease = '5'
			                Motion = '6'
			                Enter = '7'
			                Leave = '8'
			                FocusIn = '9'
			                FocusOut = '10'
			                Keymap = '11'           # undocumented
			                Expose = '12'
			                GraphicsExpose = '13'   # undocumented
			                NoExpose = '14'         # undocumented
			                Visibility = '15'
			                Create = '16'
			                Destroy = '17'
			                Unmap = '18'
			                Map = '19'
			                MapRequest = '20'
			                Reparent = '21'
			                Configure = '22'
			                ConfigureRequest = '23'
			                Gravity = '24'
			                ResizeRequest = '25'
			                Circulate = '26'
			                CirculateRequest = '27'
			                Property = '28'
			                SelectionClear = '29'   # undocumented
			                SelectionRequest = '30' # undocumented
			                Selection = '31'        # undocumented
			                Colormap = '32'
			                ClientMessage = '33'    # undocumented
			                Mapping = '34'          # undocumented
			                VirtualEvent = '35',    # undocumented
			                Activate = '36',
			                Deactivate = '37',
			                MouseWheel = '38',
			warp          : event_generate argument: bool, "whether screen pointer should be warped as well"
			                this allows you to move the mouse
			widget      %W: widget name
			width       %w: size, screendist
			when          : event_generate argument: [now|tail|head|mark]
			                now: handle before return
			                tail: put at end of queue
			                head: beginning of queue
			                mark: at beginning of queue but after any other
			                  when=mark events.
			x           %x: int, x coord (for widget)
			y           %y: int, y coord (for widget)

		Note: some tcl properties are not available as a tk.Event property
			like subwindow.  If these are necessary, then you'd probably need to
			manually register and bind the callback.

		tk only properties (not in tcl):
			widget        : widget that got the event

		Event properties vary by event type:
			all                 sendevent serial
			<Configure>         above borderwidth height override width x y
			<ButtonPress>       button num root rootx rooty state subwindow time warp x y
			<ButtonRelease>     button num root rootx rooty state subwindow time warp x y
			<Circulate>         place
			<Enter>             detail focus root rootx rooty state subwindow time x y
			<Expose>            count mode x y
			<FocusIn>           detail mode
			<FocusOut>          detail mode
			<Gravity>           x y
			<KeyPress>          keycode keysym root rootx rooty state subwindow time warp x y
			<KeyRelease>        keycode keysym root rootx rooty state subwindow time warp x y
			<Leave>             detail focus mode root rootx rooty state subwindow time x y
			<Map>               override
			<Motion>            root rootx rooty state subwindow time warp x y
			<MouseWheel>        delta
			<Property>          time
			<Reparent>          override x y
			<<Virtual events>>  data
			<Visibility>        state

	______________________________
	-2.3- Generation
		Events can be generated via widget.event_generate()
		Generated events act just like normal events.
		Arg is a sequence (-2.1- Event Sequences) and any properties as
		keyword arguments (-2.2- Event Objects).  The state property seems to be
		automatically set based on seq.  eg. event_generate('<B1-Motion>')
		has state == 256

		The state flag values can be calculated by binding and generating events
		to see what the state value is.

		This can be used to create virtual events as well
		(event_generate is threadsafe)

		NOTE 1
			event_generate uses 'now' as when by default which causes "immediate"
			processing (within event_generate()) of the generated event.  'now' blocks
			until all handlers for that event have completed.  (This can cause deadlock
			depending on what callbacks do)  'head', 'tail', and 'mark'? can prevent
			this since they ?just add events to a queue? and then exit immediately
			without further processing.
		NOTE 2
			Regarding Motion events, generation at 'tail' causes all motion events
			to be merged into 1... (the last motion event)
			'head' causes them to remain separate though...
		NOTE 3
			Regarding Shift and Lock modifiers, generated events if lowercase
			key press will be converted to the appropriate value.
			eg: event_generate('<Shift-b>') will be queued as '<Shift-B>'
				Binding to '<Shift-b>' will not see this event since it'll be
				seen as '<Shift-B>'
	______________________________
	-2.4- Other Notes
		Enter/Leave:
			Leave is always called on previous widget before enter is
			called on the next widget.  If any mouse buttons are held, then
			enter will never be called on another widget until buttons are
			released (button is held so the original widget still has focus
			even if <Leave> is fired because dragged mouse out of widget)

		Breaking:
			Return 'break' to stop the callback chain
			(see _bind() implementation for details (cmd=...)

		Names:
			bound function names are generated by register()
			which tries to use repr(id(func)) + func.__name__

		Caps Lock/shift:
			Be careful with the case of the key when caps lock/shift
			<Control-Shift-O> will fire when no capslock, but fails if
			caps lock

		bind(add=True/False):
			tk _bind completely ignores add when the bind function is a str.
			h/-2-

______________________________
-3- Widgets
	______________________________
	-3.2- Canvas
		tk.Canvas: window = put widget and allow scrolling
		draw/manage shapes with callbacks on shapes

		Items: Items are drawn on the canvas
			options:
				prefixed with [|active|disabled]:
					dash            dash outline
					fill            fill color
					outline         outline color
					outlinestipple  outline stipple
					stipple         fill stipple
					width           width of outline
				dashoffset        stipple offset for outlinestipple
				offset            stipple offset for stipple
				state             [normal|disabled|hidden]
				                  disabled = displayed but effectively nonexistent
				                  ie if A is over B but A is disabled, then when
				                  the cursor is over A, callbacks see the cursor
				                  as over B instead.
				tags              like bindtags() for widgets except is canvas item

		tagOrId can usually be given as an expression:
			&&(and), ||(or), ^(xor), !(not).
			eg. a&&b = tag a and b
		(NOTE: these expressions only work with tags, NOT IDS)

		For commands that act on single items at a time, only the first item
		matched will be affected (?in display list?)

		binding:
			Bindings for canvas items are done via Canvas.tag_bind.
			Canvas items bindings are always handled before bindings on the
			canvas itself.
			When a binding returns 'break', only the item-bound callbacks are broken.
			The widget bindings still fire.

		Canvas callbacks are called AFTER item callbacks, no exceptions.
		Reordering canvas bindtags does not affect this.

		Canvas methods generally have a widget and item version:
			widget        item
			bind          tag_bind
			focus_set     focus           * NOTE: only text can be focused, other items cannot take focus

		other notes:
			oval items in canvas cannot have a stipple
			they can, however, have an outline stipple.
			width is centered on the outline so if you want a
			circle of diameter D, you can do x,y,x,y, width=D
			it's approximately correct. Then you can stipple by using outlinestipple
			(THIS ONLY WORKS ON LINUX, windows pukes)

			Enter/Leave issues:
				if B1-Motion causes cursor to leave item:
					if callback calls canvas.coords:
						Leave is not fired until something else happens
					But if, for example, canvas.move:
						Leave is fired right after with state=0 (as if no button was pressed)

				Enter/Leave caused by change in fill all say state=0, weirdness
				enter/leave, state is unreliable, better to just
				bind something (or empty script) to all B1-Motion events etc.

	______________________________
	-3.7- Listbox
		a sequence of choices to choose from.
		note:
			exportselection defaults to True which means
			clicking/highlighting anywhere else will cause the selection
			to be removed.

	______________________________
	-3.8- Menu
		Menus are top-level widgets (can't be gridded).  It also does not
		take any widgets.  Entries are created by the menu widget itself.
		Menu entries generally have one of: label, image, bitmap.  This is
		the description of the menu item. eg. file, edit, help, etc...
		They can also take an optional accelerator which just describes a
		keyboard shortcut.  (used as is, but does not do any binding, purely
		visual).  Use a Menu as the 'menu' value in toplevel config to add
		a menu bar.  Otherwise, use post() to place the menu somewhere.

		<<MenuSelect>> is fired when the active entry changes.

		entry types:
			command: like a button widget
				command
			separator: a line separator
			checkbutton:
				command, onvalue, offvalue, variable, selectcolor
			radiobutton:
				command, value, variable, selectcolor
			cascade: open a submenu
				menu, command(not on windows)
				call postcascade to post submenu
				unpost to close submenu
			tearoff: like a command entry that causes the menu to become, its
				own Toplevel. (has window etc) cannot be created via Menu.add

		Entries are refered to via index:
			'active', 'end', 'last', 'none',
			@pixelnum, num, labelpattern

		special menus:
			windows: System (alt+space)
			Mac: Application, Window, Help
			X Windows??:  Help

		clones:
			whenever posted or set as a menubar, a clone is used (child of
			original menu)

		menu entry config options:
			activebackground
			activeforeground
			accelerator: general key-combo (ex. added to 'all' bindtag) to
				perform same function without opening the menu.
			background
			bitmap
			columnbreak: 0/1, start a new column? (ignored on mac)
			command
			compound
			font
			foreground
			hidemargin
			image
			label
			state: normal, active, disabled
			underline: underline a character at given index in 'label' value
				for quick-key traversal/selection.  (This is shortcut key to
				select an item in the menu, binding auto-added)
			cascade only
				menu
			checkbutton only
				[off|on]value:
				indicatoron
				selectcolor
				selectimage
				variable
			radiobutton only
				indicatoron
				selectcolor
				selectimage
				value(defaults to value for label)
				variable

			postcommand
				called before post()
			selectcolor
			tearoff
				bool, add a tearoff entry at 0 (default True)
			tearoffcommand
				called just before tearoff
			title:
				torn off window's title
			type
				tearoff: a new window that acts as a menu
				normal : a right-click menu
				menubar: A menubar on the window

		methods:
			activate(idx): activate specified entry (or 'none')
			add(type, **options): add an entry
			delete(*idxs): delete the entries
			entrycget(idx, option): get entry value
			entryconfigure(idx, **options): configure entry
			index(idx): return int index
			insert(idx, type, ...): add, but specify where
			invoke(idx): call its command
			post(x, y, idx=0): Display menu entry at idx at x,y screen-coords
			postcascade(idx):post the cascade menu, idx should be a cascade
				entry item
			type(idx): type of entry at idx
			unpost(): hide menu (ignored by windows/mac)
			[x|y]position(idx): basically winfo_[x|y], if menu entries were a
				widget.
	______________________________
	-3.9- Menubutton
		stand-alone cascade menu item that is a widget.
		can also take a variable
		ex: option menu: when click, open up cascade menu
			select an item->update the variable

sources:
https://tkdocs.com/tutorial/tree.html

from tkinter import *
from tkinter import ttk

*NOTE: import tkinter does not really give all the stuff
also cannot import tkinter.thing
example:
from tkinter import StringVar           ok
import tkinter.StringVar                ERROR
import tkinter;tkinter.StringVar        ERROR



##############################
contents
##############################
:1: general
:1.5:general configurations:
:1.6: general functions

:2: classes
	:2a: tkinter.Tk
	:2b: Vars
		:2b1:tkinter.StringVar
		:2b2:tkinter.BooleanVar
		:2b3: tkinter.DoubleVar()
		:2b4: tkinter.IntVar()
		:2b5: tkinter.Variable()
	:2c: ttk.Frame
	:2d: ttk.Entry
	:2e: ttk.Label
	:2f: ttk.Button
	:2g: ttk.Checkbutton
	:2h: ttk.Radiobutton
	:2i: ttk.Combobox
	:2j: tkinter.Listbox
	:2k: ttk.Scrollbar
	:2l: ttk.Sizegrip
	:2m: tkinter.Text
	:2n: ttk.Progressbar
	:2o: ttk.Scale
	:2p: tkinter.Spinbox
	:2q: ttk.Separator
	:2r: ttk.Labelframe
	:2s: ttk.Panedwindow
	:2t: ttk.Notebook
	:2u: ttk.Treeview
	:2v:
	:2w:
	:2x:
	:2y:
	:2z:


:3: geometry manager
	:3a: grid
:4: menus
:5: windows
:6: dialogs
:7: fonts
:8: colors
:9: images
:10: canvas

##############################
:1: general
##############################
	------------------------------
	example:
	------------------------------
		from tkinter import *
		from tkinter import ttk

		def calculate(*args):
		    try:
		        value = float(feet.get())
		        meters.set((0.3048 * value * 10000.0 + 0.5)/10000.0)
		    except ValueError:
		        pass

		root = Tk()
		root.title("Feet to Meters")

		mainframe = ttk.Frame(root, padding="3 3 12 12")
		mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
		mainframe.columnconfigure(0, weight=1)
		mainframe.rowconfigure(0, weight=1)

		feet = StringVar()
		meters = StringVar()

		feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
		feet_entry.grid(column=2, row=1, sticky=(W, E))

		ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))
		ttk.Button(mainframe, text="Calculate", command=calculate).grid(column=3, row=3, sticky=W)

		ttk.Label(mainframe, text="feet").grid(column=3, row=1, sticky=W)
		ttk.Label(mainframe, text="is equivalent to").grid(column=1, row=2, sticky=E)
		ttk.Label(mainframe, text="meters").grid(column=3, row=2, sticky=W)

		for child in mainframe.winfo_children(): child.grid_configure(padx=5, pady=5)

		feet_entry.focus()
		root.bind('<Return>', calculate)

		root.mainloop()

root: Tk()
handle on the root window



##############################
:1.5:general configurations:
##############################
	anchor          : n, ne, e, se, s, sw, w, nw, center
	                  if item has more space than needed
	                  in the grid, anchor to these positions
	background      : name ('red'), hex (#ff340a)
	borderwidth     : border width
	class           :
	command         : a script (string)
	compound        : str:
	                  text, image (only text or image)
	                  center, top, left, bottom, right
	                      (put text at position on image)
	cursor          :
	default         : active: default, normal: normal (for appearance, like Button)
	elide           : tag config for tk.Text
	font            : TkDefaultFont
	                  TkTextFont
	                  TkFixedFont
	                  TkMenuFont
	                  TkHeadingFont
	                  TkCaptionFont
	                  TkSmallCaptionFont
	                  TkIconFont
	                  TkTooltipFont
	foreground      : name ('red'), hex (#ff340a)
	from(from_)     : (need _ because from = reserved)
	                  lower bound (ie of ttk.Scale)
	image           : PhotoImage(file = 'path2file.gif') (only gif or ppm or whatever weird thing)
	                  otherwise use PIL (pip install pillow
	                      from PIL import ImageTk, Image
	                      ImageTk.PhotoImage(file = 'path2file')
	                      ImageTk.PhotoImage(Image.fromarray(nparray))
	justify         : left, center, right
	length          : len (pixels)
	maximum         : (ttk.Progressbar)
	mode            : 'determinate', 'indeterminate' (ttk.Progressbar)
	offvalue        : value for off(like checkbutton)
	onvalue         : value for on  (like checkbutton)
	orient          : 'vertical', 'horizontal' (scrollbars, )
	padding         : like html padding,
	                  all: 1 number
	                  horz, vert: 2 numbers
	                  left top right bottom: 4 numbers
	relief          : border style (flat, raised, sunken, solid, ridge, groove)
	selectmode      : ex for Listbox, 'browse' (single), 'extended' (multi)
	show            : example: Entry->show a different character (ie type a password)
	state           : for tkinter widgets (not ttk), 'normal', 'disabled'
	style           : themes
	takefocus       :
	text            : 'TEXTSTRING'
	textvariable    : StringVar()
	to              : to value
	undo            : allow undo (tk.Text)
	value           : value (ie for radio button)
	values          : for multiple values (like Combobox), a list of values
	width/height    : (ex: 5, 5c, 5i, 5p) (cm, inches, printer's points)
	wrap            : 'none', 'char', 'word' (Text)
	                : True/False (tk.Spinbox) (get to end of list, wrap around?)
	wraplength      : pixel length of text to wrap (Entry)

##############################
:1.6: general functions
##############################
general functions:
	grid(column = M, row = N, sticky = (N, W, E, S...))
		row/column: where to place the item
		sticky    : alignment (north, south, east, west)


	columnconfigure(X, weight=_, padx = _, pady = _)
	rowconfigure(Y, weight=Y, padx = _, pady = _)
		these two affect window resize behavior (expand to fill space)
		these indicate the row/column to expand/resize

	winfo_children()

	focus()

	configure(*args, **kwargs)
		args: name of a property to describe
		kwargs: set the property
		no args or kwargs: describe everything(properties, valid values, etc)

	destroy()
		destroys object and all descendents


##############################
:1.6: general functions
##############################
state(['disabled'])            disable the widget
state(['!disabled'])           enablethe widget

instate(['disabled'])          True if disabled
instate(['!disabled'])         True if not disabled
instate(['!disabled'], cmd)    if not disabled, do cmd

flags:
	active        disabled        focus
	pressed       selected        background
	readonly      alternate       invalid

bind('key description', callback)
	patterns:
		keydescs separated by white space

		1: 'k'
			k = a key
			(any non-space not '<'
			 single-printing ascii character)
		2: <modifier-modifier-type-detail>
			must have at least one type and one detail

		3: <<name>>
			a "virtual event"???
			no modifiers allowed

	callback takes 1 arg: an "event" (e has params, often x, and y)
	description syntax:
		<modifier-modifier-...moremodifiers...-type-detail>
		modifiers:
			Control
			Alt, (Alt_L, Alt_R)
			Shift
			Lock
			Extended
			Button1/B1
			Button2/B2
			Button3/B3
			Button4/B4
			Button5/B5
			Mod1, M1, Command
			Mod2, M2, Option
			Mod3, M3
			Mod4, M4
			Mod5, M5
			Meta, M
			Double
			Triple
			Quadruple
		types:
			FocusOut            Activate
			Gravity             ButtonPress, Button
			KeyPress, Key       ButtonRelease
			KeyRelease,         Circulate
			Leave,              CirculateRequest
			Map,                Colormap
			MapRequest          Configure
			Motion              ConfigureRequest
			MouseWheel          Create
			Property            Deactivate
			Reparent            Destroy
			ResizeRequest       Enter
			Unmap               Expose
			Visibility          Focusin
			Tab                 <<ComboboxSelected>> (for comboboxes)

		example Double-Button-1

	http://www.tcl.tk/man/tcl8.5/TkCmd/bind.htm





##############################
:2:classes
##############################

NOTE: for each
just do:
	from tkinter import ttk
	ttk.CLASSNAME().configure().keys() to see fields
	or
	ttk.CLASSNAME().configure()[field] to see explanations


:2a: tkinter.Tk()
	the root window
	methods:
		title(titlestring)
		mainloop()
	notes:
		not "themed"=>background may be different


:2b: vars
	:2b1:tkinter.StringVar()
		a string variable for linking to widget
	:2b2:tkinter.BooleanVar()
		a boolean variable for linking to widget
	:2b3: tkinter.DoubleVar()
	:2b4: tkinter.IntVar()
	:2b5: tkinter.Variable()

	vars have a trace method:
	trace(mode, callback)
		mode: 'w', 'r', 'u' (write, read, unset)
		callback: a callback function taking some args





:2c: ttk.Frame(parentWindow, padding="3 3 12 12")
	an empty frame (rectangle)

:2d: ttk.Entry(parent, width, textvariable)
	text entrybox
	textvariable: where to store the text input
	width->characters
	methods:
		get(): get value
		delete(start, stop):
			'end' = last index
		insert(0, 'somestring'):
			insert new text at index
	states:
		invalid
		readonly (can't type but can highlight/copy)
	validate:
		'none'
		'key' (on each keystroke)
		focus/focusin/focusout,
		all
		2 callbacks:
			validate: return 0 or 1 (True or False)
			invalidcommand: runs when invalid



:2e: ttk.Label(parent)

:2f: ttk.Button(parent, text=TEXT, command=FUNC)
	a button,
	methods:
	invoke: invoke the callback

:2g: ttk.CheckButton(parent, configs)
	a checkbutton
	methods:
		invoke (see above)
	instate:
		alternate = 3rd value, (ie when you see some checklists
		and check some but not all)

:2h: ttk.Radiobutton
	instate:
		alternate

:2i: ttk.Combobox
	for choosing from a list or enter own value maybe
	selectionclear()
	get()
	set(val)
	current():      return selected index
	current(index): select the index

:2j: tkinter.Listbox
	list of boxes, allow multi-selection
	listvariable: just a python list... isn't working...
	use tkinter.StringVar()
	'item1 {item 2} item3'
	has 3 items
	virtual event: <ListboxSelect>
	alternatively:
		.insert(ind, *items)
		.delete(start, stop = None)
			single item at index start if stop is None
			else from start to stop inclusive
		.get(start, stop = None)
			single item at index start if stop is None
			else from start to stop inclusive
		.size()
	others:
		.curselection()
		.selection_includes(index)
		.selection_clear(start, stop = None)
		.selection_set(start, stop = None)
		.see(index)

	:2k: ttk.Scrollbar
		command:
			pair with a scrollable widget:
				use targetWidget.yview or targetWidget.xview

			on targetWidget:
				xscrollcommand
				yscrollcommand
					use corresponding scrollbar's set command
	:2l: ttk.Sizegrip
	:2m: tkinter.Text
		wrap, undo
		methods:
			.see(index)
				index: (lineNumber.charNumber)
				line = 1-based, charNumber = 0-based
				(1.0 = first line 0th char)
				tagname.first
				tagname.last
				markname
			.get(start, stop)
				start, stop = index format (see .see(index))
				special values:
					chars: unit for get
					lines
					linestart
					wordstart
					lineend
					wordend
				always ends with '\n'
			.insert(index, strval, tags = ())
				index: see .see(index)
				last index is non-inclusive
				tags: associated tags
			.delete(start, stop)
				see .get
			.tag_add(tagname, start, stop)
			.tag_configure(tagname, **kwargs)
				overstrike        background
				relief            bgstipple
				rmargin           borderwidth
				spacing1          elide (hide text)
				spacing2          fgstipple
				spacing3          font
				tabs              foreground
				tabstyle          justify
				underline         lmargin1
				wrap              lmargin2
				                  offset
			.tag_cget(tagname)
				queries configuration values
			tag_raise
			tag_lower
				change priorities
				default: more recent = higher priority
				(clashes = use higher priority to resolve)
			tag_delete(tag)
			tag_remove(tagname, start, stop)
			tag_ranges(tagname)
				list of ranges with tagname
			tag_nextrange
			tag_prevrange
				search tagged range
			tag_names(index = None)
				None: all tags
				index: all tags applied to index
			tag_bind(tagname, 'binddescr', callback)
			mark_set(name, ind)
				mark = just before char at ind
			mark_unset(name)
			mark_next()
			mark_previous()
			mark_names()
			mark_gravity(markname, 'left/right')
				which char does the mark stick to?
				(when text inserted at mark)
			image_create(ind, image=PhotoImage())
			window_create(ind, window=thing)
			search...
			edit_modified
				query if text changed
			edit_undo
			edit_redo
				(for these, undo config should be true)
			peer:
				share text data b/w widgets...
				(like multiwindow in emacs?)
	Other:
		virtual events:
			<<Selection>>
			<<Modified>>

		'sel' tag: selected text

		Marks
			marks: spot between text
			'insert': insert point for new txt when type
			'current': mouse position
		images/widgets
			make sure added im/widget is
			descendent of the text widget they are
			added to
	:2n: ttk.Progressbar
		orient, length (pixels), mode
			mode: determinate
				can give approximate % completion
				change value to between 0 and maximum
				use configure(value = val)
				or configure(variable = tkinter.DoubleVar())
				or progbar.step(amt)
			mode: indeterminate
				bar.start()
				bar.stop()

	:2o: ttk.Scale
		orient, from(_), to, length, variable(float), value,
		command (value appended to args),
		methods:
			state/instate
	:2p: tkinter.Spinbox
		to, from_, textvariable, increment,
		values, command, state
		methods:
			set, get
	:2q: ttk.Separator
		orient
		weird... i don't see anything when I add a separator...

	:2r: ttk.Labelframe
		text
		see Frame

	:2s: ttk.Panedwindow
		resize between adjacent widgets

		orient, height, width
		method:
			add(widget)
			insert(position widget)
			forget(position)

	:2t: ttk.Notebook
		tabbed frames
		methods:
			add(widget, text=tabDescription)
			state(disabled, normal, hidden)
			insert(position, widget, **kwargs)
			forget(position)
			tabs()
			select(arg = None)
				None = currently selected
				else index or widget to select it
			tab(tabindex, **kwargs)
	:2u: ttk.Treeview
		view object and attributes
		scrollable






##############################
:3: gemoetry manager
##############################
:3a: grid

	idea: columns and rows (put on graph paper)
	------------------------------
	widget.grid
		column     :
		row        :
		columnspan :
		rowspan    :
		sticky     : any of 'nswe' (any combination, stretch to be stuck to corresponding spot)
		padx       : 'v1 v2' (if v2 omited, same as v2)(pad within grid) (borderline in master)
		pady       : 'v1 v2'(if v2 omited, same as v1)(pad within grid)(borderline in master)
		ipadx      : same as aboves but
		ipady      : as if borderline is 0 (if frame is 20x20, pad = 10, allocated a 30x30 grid, ipad = stretch
		             pad = don't)
		NOTE:
			this is for putting widget into parent's row/column spot

	------------------------------
	widget.{row, column}configure
		weight  (growth rate for resizing window)
		minsize (column/row should not shrink beyond that
		pad     (padding values, 'v1, v2, v3, v4' etc
		NOTE:
			this is used for splitting up the widget into row/col


	------------------------------
	padding
		master.configure(padding = 'values')(pad within grid)
		(padding at edges of master so can wrap a widget in Frame and use Frame's padding

	------------------------------
	grid_slaves()    : returns map of gridded slaves
	grid_info()      : gives gridinfo on the widget
	grid_configure() : change grid configuration values
	------------------------------
	grid_forget([list of widgets]): removes them, forgets grid settings
	grid_remove([list of widgets]): removed them, remembers grid settings

##############################
:4: menus
##############################
	root = tkinter.Tk()
	root.tk.call('tk', 'windowingsystem')->'x11', 'win32', 'aqua'

	root.option_add('*tearOff', tk.FALSE)
		allows removal of menu from window to own window

	win = Toplevel(root)
	menubar = tk.Menu(win)
	win['menu'] = menubar

	ex:
		menubar = tk.Menu(parent)
		menu_file = Menu(menubar)
		menu_edit = Menu(menubar)
		menubar.add_cascade(menu = menu_file, label = 'File')
		menubar.add_cascade(menu = menu_edit, label = 'Edit')
		menu_file.add_command(label = 'New', command = func)
		menu_file.add_command(label = 'Open...', command = func)
		menu_file.add_command(label = 'Close', command = func)

	summary:
		add_cascade(menu, label)
			add a submenu
		add_command(command, label, accelerator):
			a menu item
		add_separator()
			...???
		add_checkbutton(label, variable, onvalue, offvalue, command, accelerator)
		add_radiobuttn(label, variable, value, command, accelerator)
			display indicator
		accelerators: just an indication of associated shortcut keys
			(still have to manually create the bindings though)

	other configs:
		underline = index_of_letter_to_underline
		image = tk.PhotoImage
		        PIL.ImageTk.PhotoImage
		compound = l,t,rb, center, none


	##############################
	context menus (right click)
		create menu,
		menu.post(x,y)

##############################
:5: windows
##############################
newWindow = tk.Toplevel(parent)

window methods:
	geometry(arg = None)
		if None:
			return current geometry
		else:
			'[width]x[height][+/-][posx][+/-][posy]'
			(+ => distance from top/left,
			 - => distance from bottom/right)
		example:
			make window 500x500, move top left to 0,0
				root.geometry('500x500+/-0+/-0')
				(can omit one of size or position)
			move to top right
				'-0+0'
	title(arg = None)
		if None:
			return current title
		else:
			set the title, return ''

	after(milliseconds, callable, possibleargs):
		call lambda (no args) after milliseconds
	NOTE: callable only!
		if you want to use a registered function or something
		then use widget.tk.call('after', 'args', 'funcname', 'args)
		otherwise, the function is continually wrapped

	lift(otherWindow = None)
	lower(otherWindow = None)
		move to the extremes if None
		else:
			to just above/below the other window

		NOTE:
			above 2 are for stack order
			root.tk.eval('wm stackorder '+str(root))
			returns a str with str(window)
			as order of windows from bottom to top
			can use str.index EXCEPT:
				observation: root is '.'
				tops are '.[some number]'
				implies str.index(root) is always 0
				may need to use regexp
				or... seems to be space delimited
				add space to ends and do .index(
				' ' + str(desiredWindow) + ' ')
		NOTE2:
			the stackorder is only aware of things
			under the same root
			make another root, it is not seen
		NOTE3:
			root seems like it is always '.'
			might be able to just do
			window.tk.eval('wm stackorder .')
		NOTE4:
			wm stackorder {}
			works with "sibling widgets" too (widgets in same plane?)
	resizable(xok, yok)
		T/F if x/y resizable or not
	minsize(x,y)
	maxsize(x,y)

	iconify()
	deiconify()
	withdraw()
	state(state)
		'normal'
		'iconic'
		'withdrawn'
		NOTE:
			on ubuntu, deiconify works after withdraw()
			but not after iconify()
##############################
:6:dialogs
##############################
files:
	from tkinter import filedialog
	filedialog.askopenfilename()
	filedialog.asksaveasfilename()
		kwargs:
			confirmoverwrite = T/F, default=True
			defaultextension: adds extension if user doesn't add one
			filetypes: ['name {extensions...}']
			           ex:
			               ['txt {.txt}',
			               'jpg {.jpg .JPEG .jpeg}',
			               'all {*}']
			initialdir: path_to_initial_dir
			initialfile: path_to_initial_file
			multiple: T/F, can choose multiple files when opening?
			parent: window: makes dialog appear on top of parent
			title: title of dialogbox
	filedialog.askdirectory()
		kwargs:
			initialdir
			mustexist
			parent
			title
	return values:
		success = return FULL PATH
		fail(canceled) = ''
colors:
	from tkinter import colorchooser
	colorchooser.askcolor(initialcolor = '#FF0000')
messages:
	from tkinter import messagebox
		askokcancel
		askquestion
		askretrycancel
		askyesno
		askyesnocancel
		showerror
		showinfo
		showwarning
	args:
		title    : title
		message  : message
		detail   : extra stuff
		icon     : 'info', 'error', 'question', 'warning'
		default  : 'ok', 'cancel', 'retry', etc...
		           (which button to have initial focus)
		parent   : parent window
##############################
:7: fonts
##############################
should create a style and use style
instead of directly using the font option

	------------------------------
	default fonts
	------------------------------
	TkDefaultFont         : for everything else
	TkTextFont            : text entry widgets
	TkFixedFont           : fixed-width
	TkMenuFont            : menu
	TkHeadingFont         : column headings
	TkCaptionFont         : for dialog caption bars
	TkSmallCaptionFont    : smaller form of above
	TkIconFont            : icon captions
	TkTooltipFont         : tooltips


	from tkinter import font
	font.Font(family = 'fontFamily', size = size, weight = weight)

	weight:          'bold', 'normal'
	slant:           'roman', 'italic'
	underline:       bool
	overstrike:      bool

	NOTE:
		guaranteed:
			Courier, Times, Helvetica
			Monospaced, serif, sans-serif
		font.families() to get all families
		NOTE:
			must call tkinter.Tk() before font.families()
	alternative: font descriptions
		ex: 'Helvetica 12 bold italic'


##############################
:8: colors
##############################
system specific color names
rgb "#[hexvalue]"
x11 (mostly just use very common basic colors)

colors reference:
http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm

##############################
:9: images
##############################
tk.PhotoImage(file = 'file.gif')
default allowable formats:
	gif
	PPM/PNM

pip install pillow
from PIL import ImageTk, Image
ImageTk.PhotoImage(file = 'fname')
ImageTk.PhotoImage(Image.fromarray(
    numpy_array_image(RGB)))


    more image formats available


##############################
:10: canvas
##############################
Tk.Canvas(parent)
	represents a canvas to draw stuff on
width, height: space in UI
scrollregion: actual size, ex("0 0 1000 1000")???

create_window((x,y), window = widget, anchor = 'nsew')
NOTE: canvas is scrollable





______________________________
item options:
	use canvas.itemconfigure(value, **options)
	to change options, or set when
	creating it

	acitvedash          :
	activefill          :
	activestipple       :
	activewidth         :
	arrow               :
	arrowshape          :
	capstyle            :
	dash                :
	dashoffset          :
	disableddash        :
	disabledfill        :
	disabledstipple     :
	disabledwidth       :
	fill                : color
	joinstyle           :
	offset              :
	smooth              :
	splinesteps         :
	state               :
	stipple             :
	tags                : tags: extra group ids
	width               : pixel width

______________________________
adding items:
	call a function, returns a value
	item can be modified by

	canvas.create_line(x0,y0,x1,y1)
	canvas.create_rectangle
	canvas.create_oval
	canvas.create_arc
	canvas.create_polygon
	canvas.create_image
	canvas.create_bitmap
	canvas.create_text
	canvas.create_window
		(other widgets in a frame)




______________________________
binding:
	canvas.tag_bind(
		itemID, 'bindingDescr', callback)

______________________________
tagging:
	canvas.addtag(tag, modifier, identifier):
		tag: tag to add
		modifier: 'withtag'
	canvas.gettags()
		return list of tags for an item
	canvas.find_withtag(desiredTag)
		returns list of corresponding ids
	canvas.dtag(identifier, tag)
		removes tag from identified

______________________________
others
	canvas.delete(identifier)
	canvas.move(identifier, amt)
	canvas.coords(identifier, coords)
	canvas.raise(identifier)
	canvas.lower(identifier)

	canvas.canvasx(val)
	canvas.canvasy(val)
		translates event.x event.y to
		actual canvas coordinates
