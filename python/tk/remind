#!/bin/bash
# NOTE: this just starts a process that waits until the given time to
# display a reminder.  The scheduled reminder will not persist on system
# reboot.

# TZ environment variable seems to affect
# python weirdly from cygwin
MYENV=()
if hash cygpath >/dev/null 2>&1
then
	MYENV+=(TZ=)
fi

PYEXE=
for candidate in py python python3
do
	if hash "${candidate}" &>/dev/null
	then
		PYEXE="${candidate}"
		break
	fi
done
if [ -z "${PYEXE}" ]
then
	echo "Failed to find python." >&2
	exit 1
fi

HELP=
JOB=
for item in "${@}"
do
	case "${item}" in
		-h|--help)
			HELP=1
			JOB=1
			;;
		-j|--job)
			JOB=1
			;;
	esac
done

PARSER_SCRIPT="
p = argparse.ArgumentParser(
    description=(
        'Remind with a pop-up.  The full time format is'
        ' \"YYYY-mm-dd HH:MM:SS\".  This can be partially given.'
        '  For a datetime, the omitted values larger than given will be'
        ' taken from now.  The smaller values will be 0.  For a delay,'
        ' all omitted values will be 0.  For the ambiguous cases,  let'
        ' AA and BB be separate 2-digit numbers.  AA will match MM.'
        '  AA:BB will match HH:MM.  Note: this does not persist after'
        ' system restart.'
    ),
)
p.add_argument('time', help='The target date or delay.')
p.add_argument('message', help='message to display', default='', nargs=argparse.REMAINDER)
p.add_argument('-v', '--verbose', action='store_true')
p.add_argument('-t', '--title', default='remind', help='message title')
p.add_argument(
    '-d', '--delay', action='store_true',
    help='interpret time as a delay instead.  Only supports days to seconds.')
p.add_argument(
    '-j', '--job', action='store_true',
    help=(
        'run as a job, otherwise run without job as background'
        ' Running as a job means backgrounding the remind script.'
        ' This makes it show up when using \"jobs\" at the commandline'
        ' which allows you to check if reminders are scheduled.'
        ' However, this also means that fg would put it in fg, and on'
        ' cygwin, it cannot be placed back into bg so if you'
        ' accidentally fg, you might need to cancel and re-schedule it.'
    )
)
p.add_argument(
    '--maxsleep', type=float, default=3600.0,
    help='maximum sleep duration when splitting sleep.')
p.add_argument(
    '--splitsleep', type=float, default=60.0,
    help='''Split sleeping to improve sleep accuracy (more frequent
        time checks when above splitsleep)''')
"

DATE_PARSE="
pat = re.compile(r'^(?:(?=.*[ -])(?:(?=.*-.*-)(?P<year>\d+)?-)?(?:(?P<month>\d+)?-)?(?P<day>\d+)? ?)?(?:(?P<hours>\d+(?:\.\d+)?)?:)?(?P<minutes>\d+(?:\.\d+)?)?(?::(?P<seconds>\d+(?:\.\d+)?)?)?$')
def parse_time(spec):
    m = pat.match(spec)
    if not m:
        raise ValueError('Bad datetime specification: {}'.format(spec))
    vals = list(m.groups())
    assert len(vals) == 6
    return vals
"
GET_TDELTA="
import sys
import argparse
import datetime
import time
import re
import tkinter as tk
import os
quiet = os.environ.get('QUIET')
if quiet:
    class Dummy(object):
        def write(self, data):
            return len(data)
        def close(self):
            pass
        def flush(self):
            pass
    sys.stdout = Dummy()
    sys.stderr = Dummy()
try:
    from tkinter import messagebox
except ImportError:
    import tkMessageBox as messagebox
import platform

def eprint(*args, **kwargs):
    kwargs.setdefault('file', sys.stderr)
    print(*args, **kwargs)

${PARSER_SCRIPT}
try:
    args = p.parse_args()
except SystemExit:
    sys.exit(1)
args.message = ' '.join(args.message)

if quiet:
    args.verbose = False
${DATE_PARSE}
now = datetime.datetime.now()
times = parse_time(args.time)
if args.verbose:
    eprint('now:', now)
    eprint('parsed times:', times)
if args.delay:
    if any(times[:2]):
        raise ValueError('Year/Month not supported for delay interpretation.')
    info = dict(zip(
        'days hours minutes seconds'.split(),
        [float(i) if i else 0 for i in times[2:]]))
    tdelta = datetime.timedelta(**info)
    if args.verbose:
        eprint('delay:')
        for k, v in info.items():
            eprint('  {}: {}'.format(k, v))
else:
    found = 0
    extra_seconds = 0
    for i in range(len(times)-1, -1, -1):
        if times[i]:
            f = float(times[i])
            times[i] = int(f)
            extra_seconds += (f-times[i]) * (0, 0, 24*60*60, 60*60, 60, 1)[i]
            found = 1
            if not times[i]:
                times[i] = (1, 1, 1, 0, 0, 0)[i]
        else:
            times[i] = now.timetuple()[i] if found else (1, 1, 1, 0, 0, 0)[i]
    target = datetime.datetime(*times) + datetime.timedelta(seconds=extra_seconds)
    if target < now and target.hour < 12:
        if args.verbose:
            eprint('Warning, negative duration, assuming pm.')
        target += datetime.timedelta(hours=12)
    tdelta = target - now
if not quiet:
    eprint('Reminding at:', now + tdelta, ':', args.message)
"

PYSCRIPT="
${GET_TDELTA}
now = time.time()
target = now + tdelta.total_seconds()
while now < target:
    sleeptime = target-now
    if sleeptime > args.splitsleep:
        sleeptime = min(sleeptime / 2, args.maxsleep)
    time.sleep(sleeptime)
    now = time.time()

r = tk.Tk()
r.title('remind')
r.withdraw()
# using withdraw() would hide it from view. When working with
# something else, there would be no visual indication of the reminder
# except when alt+tab and see it in the list or no other windows open
# and would obscure it when it is created.

if platform.system() == 'Windows':
    r.attributes('-toolwindow', True, '-topmost', True)
else:
    try:
        r.attributes('-topmost', True)
    except Exception:
        traceback.print_exc()
# Make main window small and hide behind popup(assumed to be at screen
# center).
r.geometry('1x1')
r.update_idletasks()
r.geometry('+{}+{}'.format(
    (r.winfo_screenwidth() - r.winfo_width())//2,
    (r.winfo_screenheight() - r.winfo_height())//2
))

messagebox.showinfo(title=args.title, message=args.message)
r.destroy()
"

# always run reminder in background, but don't want errors or help message
# in background

if [[ -n "${HELP}" ]]
then
	env QUIET= "${MYENV[@]}" "${PYEXE}" -c "${GET_TDELTA}" "${@}"
else
	env QUIET=1 "${MYENV[@]}" "${PYEXE}" -c "${PYSCRIPT}" "${@}" &
	jobpid=$!
	printf 'pid: %s ' ${jobpid}
	if ! env QUIET= "${MYENV[@]}" "${PYEXE}" -c "${GET_TDELTA}" "${@}"
	then
		 wait
		 exit 1
	fi

	if [[ -n "${JOB}" ]]
	then
		echo putting into background and waiting
		bash -c "kill -s SIGSTOP $$; kill -s SIGCONT $$&" &
		wait
	fi
fi
