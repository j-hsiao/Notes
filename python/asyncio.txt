https://docs.python.org/3/library/asyncio-stream.html
Python asyncio notes
asynchronous tasks etc + event loops
coroutines

-0- definitions
	-0.1- syntax
-1- high-level api
	-1.1- runners
	-1.2- coroutines
		-1.2.1- builtin coroutines

-1- asyncio methods
	-1.1- execution management
	-1.2- object types
	-1.3- comms
-2- exceptions


===============
-0- definitions
===============
awaitable:
	something that can be awaited
coroutine:
	A function that returns an awaitable which calls
	the body when awaited.
task:
	An awaitable that wraps a coroutine to run the
	coroutine concurrently (like a thread)
	Tasks are futures.
	methods:
		cancel(msg=None)
		canceled(): was it canceled?
		done(): is it done?
		result(): result of task, only call after awaited
		exception(): the exception when running task
			result() and exception():
				If canceled, raises CancelledError
				If not done, InvalidStateError
		add_done_callback(callback, context=None)
		remove_done_callback(callback)
		get_coro()
		get_name()
		set_name()
futures: An object representing value of await coroutine.
	use future.result(timeout=None) to get the result...
	don't see how this is any different from just calling await on a
	task...
NOTE:
	tasks should always have references saved, otherwise they may
	disappear mid-execution (loop only holds weak references)
event loop: the loop that runs awaitables
	await calls in each awaitable are like pause-points and allow
	switching to a different task to allow it to complete or something

cancelling:
	A task is cancelled by raising CancelledError

	============
	-0.1- syntax
	============
	asyncio adds 2 special syntaxes:

	1. async def funcname(args):
	2. await awaitable_expr
	3. async with

	async def commands return an awaitable

==================
-1- high-level api
==================
	=============
	-1.1- runners
	=============
	Runners are basically wrapped asyncio.EventLoop

	asyncio.run(coro, debug=None, loop_factory=None):
		create a new loop to run coro
		coro: the awaitable to run
		debug: True/False to force, otherwise use system settings
		loop_factory: (3.12+) callable to return a loop replacing "policy" system

	asyncio.Runner(debug=None, loop_factory=None)
		asyncio.run() as a context manager:

		run(awaitable, context=None)
			If coroutine, wrapped in a Task.
		close()
			* finalize asynchronous generators
			* shutdown default executer
			* close event loop
			* release context
		get_loop() -> EventLoop

		with asyncio.Runner(...) as runner:
			(3.11+)
			runner.run(coro)

	================
	-1.2- coroutines
	================
	asyncio.create_task(coroutine):
		Create a task.
		The task is "scheduled" to run.
		`await task` to wait til finished
		task.cancel() to cancel the task
			(use try/finally for proper cleanup)
		NOTE:
			reference to the returned task must be maintained
			or it might be garbage collected.

	asyncio.TaskGroup: group of tasks
		(3.11+)
		Tasks are run on __exit__
		async with asyncio.TaskGroup() as tg:
			t1 = tg.create_task(...)
			t2 = tg.create_task(...)

		==========================
		-1.2.1- builtin coroutines
		==========================
		asyncio.sleep(delay, result=None)

		asyncio.gather(*aws, return_exceptions=False)
			kind of like [await _ for _ in aws] if it was valid syntax
			If return_exceptions=False, then an exception immediately
			interrupts the gather and any remaining tasks CONTINUE RUNNING

			Cancelling a gather also cancels any pending awaitables.

			Cancelling one of the given awaitables will be treated
			as successful so other tasks are not cancelled too.

		asyncio.shield(aw):
			await and shield from cancellation.
			NOTE: shielding just means the task continues running
			BUT the await still gets interrupted (CancelledError)

		asyncio.timeout(delay) (3.11+)
			try:
				async with asyncio.timeout(delay):
					dostuff
			except asyncio.TimeoutError
				handle_timeout

		asyncio.timeout_at(when) (3.11+)
			same as asyncio.timeout(time.time()+delay)

		asyncio.wait(awseq, timeout=None, return_when=ALL_COMPLETED)
			done, pending = asyncio.wait(myawaitables)
			must be a sequence

			return_when:
				ALL_COMPLETED
				FIRST_COMPLETED
				FIRST_EXCEPTION


------------------------------
-1- asyncio methods
	------------------------------
	-1.1- execution management
		asyncio.run(coro, debug=False)
			Create a loop and run the coroutine.  No recursive calls allowed.
		asyncio.create_task(coro, name=None)
			create a task from coroutine
		asyncio.sleep(delay, result=None)
			sleep for delay and return result
			delay=0 is optimized to unblock loop
		asyncio.gather(*aws, return_exceptions=False)
			coroutines in aws are taskified
			return a sequence of results per awaitable
			if return_exceptions is True, exceptions = return values
			otherwise, propagate on first exception.
			cancellation also cancels all awaitables (if not "done" yet)
			where done = awaited
		asyncio.shield(aw):
			shield aw from cancellation by containing awaitable
		asyncio.wait_for(aw, timeout=None)
			call aw with a timeout, cancel if timed out
		asyncio.wait(aws, timeout=None, return_when=ALL_COMPLETED):
			aws is an iterable of TASKS, NO COROUTINES (non-empty)
			return_when = ALL_COMPLETED|FIRST_EXCEPTION|FIRST_COMPLETED
			return (done, pending)
		as_completed(aws, timeout=None)
			return an iterator of coroutines.
			awaiting each coroutine gets the next earliest result
			pending = aws
			similar code:
			while pending:
				fin, pending = wait(pending, return_when=FIRST_COMPLETED)
				do something with fin or whatever
		to_thread(func, *args, **kwargs)
			do something in a thread and get result (don't block event loop)
		run_coroutine_threadsafe(coro, loop)
			return a future object
	------------------------------
	-1.2- object types
		iscoroutine(obj)
		iscoroutinefunction(func)
	------------------------------
	-1.3- comms
		open_connection(host, port,...)
			return (reader,writer) pair
			writer.write(data): schedule a write
			await methods:
				writer.drain
				reader.read
		start_server(connection_callback, host, port, ...)
			def connection_callback(reader, writer):
				#handle connection
				if callable, blocking
				if coroutine, become a task
		open_unix_connection(...)
		start_unix_server(...)

		classes:
			Server
				is a context manager (async with)
				attrs:
					sockets: sequence of listening sockets or None
				methods:
					close()
					get_loop()
					is_serving()
				awaitables:
					wait_closed()
					start_serving()
					serve_forever()

			reader
				awaitables:
					read(n=-1)
					readline()
					readexactly(n)
					readuntil(sep=b'\n')
				ateof()
			writer
				transport
				write(data)
				writelines(data)
				close()
				can_write_eof()
				write_eof()
				is_closing()
				get_extra_info(name, default=None)
					BaseTransport.get_extra_info() args
					sockets:
						peername
						socket
						sockname
					ssl sockets:
						compression
						cipher
						peercert
						sslcontext
						ssl_object
					pipe:
						pipe
					subprocess:
						subprocess
				awaitables:
					drain()
					wait_closed()

------------------------------
-2- exceptions
	asyncio.CancelledError: task was canceled
	asyncio.TimeoutError: timed out (from wait_for)
	asyncio.InvalidStateError: result not ready
