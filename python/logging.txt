https://docs.python.org/3/library/logging.html
https://docs.python.org/3/howto/logging.html#logging-basic-tutorial
https://docs.python.org/3/howto/logging.html#logging-advanced-tutorial
https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook

contents
-0- general
-1- loggers
-2- handlers
-3- Formatters
-4- configs

______________________________
-0- general
	Components of logging:
		logrecords  : the actual log obj/message.
		loggers     : interface to log (emit log records)
		handlers    : log to certain destinations (do the writing)
		filters     : filter log outputs
		formatters  : layout

	______________________________
	flow
		logmethod called
		if methodlevel < logger's loglevel -> stop
		create log record
		filter log record
		handle log record
			if methodlevel < handlerlevel -> stop
			handler filters on log record
			emit+formatting
		propagate log record if applicable
		if no handlers at all, then lastResort.


		Loggers each have a . name, and pass logrecords to parent loggers
		if applicable.

	settings:
		logging.basicConfig(
			filename=...
			encoding=... (3.9+)
			level=...
			format=...
		)

______________________________
-1- loggers
	Loggers are identified with a .-delimited name, much like python packages.

	Recommendation is:
		logger = logging.getLogger(__name__)

	The root logger name is ''.  The module-level logging methods use the
	root logger.

	Child loggers inherit loglevel from parents by default.
	Logrecords are propgated to parents by default as well.

	common methods:
		debug|info|warning|error|critical(msg, *args, **kwargs)
		log(lvl, msg, *args, **kwargs):
		exception(msg, *args, **kwargs)

			Emits a logrecord with message set to `msg % args`.

			These use msg % args to format the log output.
			msg: str
			*args: args for formatstr OR a dict.
			**kwargs:
				exc_info     bool: add exc info to msg, use exception tuple or instance
				             if provided, else use sys.exc_info()
				stack_info   bool: add stack info
				stacklevel   stack level to use for computing position(file, lineno, etc), default 1
				             (the place where logger.logmethod() is called)
				extra        Additional attributes for the LogRecord as if
				             logrecord.__dict__.update(extra).  These are available for use to
				             the format string, (but not the message).
				
			exception:
				does the same, but also adds traceback.format_exc()
				to the end of the logrecord.

		setLevel(lvl: int|str)
			if str, then corresponds to generic logging.loglevel constants:
				logging.NOTSET      0
				logging.DEBUG       10
				logging.INFO        20
				logging.WARNING     30
				logging.ERROR       40
				logging.CRITICAL    50

		[add|remove]Handler|Filter](...)
			add/remove corresponding handler/filter

	attrs:
		name        readonly logger name
		level       log level (setLevel)
		parent      readonly parent logger
		propagate   propagate to parent loggers (directly to handlers).
		            ex: if A.B has level INFO, A has level ERROR,
		            A.info(stuff) would not be logged.
		            A.B.info(stuff) WOULD be logged, AND THEN ALSO
		            propagated to A's handlers EVEN THOUGH A has level
		            ERROR.
		handlers    readonly list of handlers(use [add|remove]Handler() to modify)
		disabled    readonly

	others:
		filter(record):
			Apply filters to record.  True if all filters pass (return truthy).
		isEnabledFor(lvl: int)
			Return if lvl >= getEffectiveLevel()
		getEffectiveLevel()->int
			logger.level or search parents if NOTSET
		getChild(suffix: str)->Logger (3.2+)
		getChildren() (3.12+)
		findCaller(stack_info=False, stackLevel=1)
			Find the stack info (fname, lineno, funcname, stackinfo if stack_info else None)
		handle(record):
			handle the record
		makeRecord(name, level, fn, lno, msg, args, exc_info, func, extra, sinfo)
			Make a LogRecord
		hasHandlers() (3.2+)
			Also searches parents for handlers
______________________________
-2- handlers
	Handlers handle the LogRecord (ex. write or send it somewhere)


	common methods:
		setLevel(level: int|str(3.2+))
		setFormatter(fmt): a Formatter or None
		[add|remove]Filter(filter):

	subclasses should override and call:
		__init__ set level, initialize filters, creates a lock.
		close() remove handler from internal handlers map.
		flush() no-op
		emit(): NotImplementedError
			NOTE: because emit() is called while locked, any use of locks
			      may cause deadlock.  Try to avoid any logging api calls
			      while inside emit().


	other methods:
		filter(record): return whether record passes all filters.
		createLock(): sets self.lock to a new lock.
		acquire()
		release()
		handle(record):
			pseudocode:
				if filter(record):
					with lock:
						try:
							emit(record)
						except Exception:
							handleError(record)
		handleError(record)
		format(record)

	best practices:
		do not add handlers in libraries, only in clients.
		(otherwise, clients can't really control log handling.)
		can add a NullHandler though to not print if no configuration.

	builtins:
		logging:
			NullHandler (3.1+)
			StreamHandler
			FileHandler

		logging.handlers:
			BaseRotatingHandler
			RotatingFileHandler
			TimedRotatingFileHandler
			SocketHandler
			DatagramHandler
			SMTPHandler
			SysLogHandler
			NTEventLogHandler
			MemoryHandler
			HTTPHandler
			WatchedFileHandler
			QueueHandler (3.2+)



______________________________
-3- Formatters
	__init__(fmt='%(message)s', datefmt='%Y-%m-%d %H:%M:%S,uuu', style='%', validate=True, defaults=None)
		Convert a LogRecord to an output string.
		fmt: str, format string using LogRecord's attrs as keys.
		datefmt: str, default to formatTime()
		style: (3.2+)
			%: %(<dictkey>)fmtcode (default) (ex: %(level)03d) etc
			{: {<dictkey>:formatopts}
			$: string.Template.substitute()?
		validate (3.8+): bool
			mismatched fmt and style raise ValueError
		defaults (3.10+): dict/str
			default values for LogRecord custom fields.

	format(record):
		pseudocode
			if '(asctime)' in record:
				record.asctime = formatTime()
			parts = [record.msg % record.__dict__]
			if exc_info:
				parts.append(formatException())
			if traceback:
				parts.append(formatStack())
			return '\n'.join(parts)

			sidenote: exc_text caches the exception formatting. Set it to None
			          if other formatters for the LogRecord might have different exc formatting.

	formatTime(record, datefmt=None)
		asctime is calculated as follows:
			default_msec_format % time.strftime(default_time_format), msecs

		where default_msec_format is only available py3.3+
		and before, it is hard coded as '%s,%03d'.

	formatException(exc_info)
		traceback.format_exc()

	formatStack(stack_info)
		traceback.format_stack()

	attrs:
		converter(tstamp) -> timetuple
			example choices:
				time.localtime()
				time.gmtime()
				lambda x: datetime.datetime.fromtimestamp(x).timetuple()


	Builtin alternative formatter:
		BufferingFormatter(linefmt=None)
			Buffers LogRecords to process together.

			formatHeader(records)
				string in before format(records)
			formatFooter(records)
				string after format(records)
			format(records)
				return ''.join((formatHeader(records), *map(linefmt.format, records), formatFooter(records))

______________________________
-5- filters
	default class:
		logging.Filter(name='')

		filter(record):
			return (
				record.name.startswith(self.name + '.')
				or record.name == self.name)
			NOTE: mutating record is allowed

	3.2+: filter can also be a callable()
	3.12+: Returning a LogRecord instance will replace
	       the input logrecord (allow filters to modify
	       LogRecord before emitted if attached to a handler)


______________________________
-6- configs
	1. create everything explicitly
	2. create a config file: fileConfig()
	3. use a dict: dictConfig()

	{
		formatters: {
			name: {attr:val},
			...
		},
		handlers: {
			name: {attr:val},
			...
		}
		loggers: {
			name: {attr:val},
			...
		}
		root: {
			attr:val,
			...
		}
	}


______________________________
-7- LogRecord
LogRecord subclasses can override getMessage() to allow different formatting.
(still should call str(self.msg))



______________________________
-6- LogRecords
    LogRecord(name, level, pathname, lineno, msg, args, exc_info, func)
        name: original logger
        level: loglevel
        pathname: sourcefile
        lineno: line in sourcefile
        msg: message
        args: args for formatting msg
        exc_info: exception info or None
        func: name of func containing the original call

    getMessage()
        return formatted msg

    attributes: (available for formatters)
        name                code        description
        args
        asctime             s           formatted time
        created             f           unix timestamp
        exc_info
        filename            s           filename of pathname
        funcName            s           name of func that called log
        levelname           s           name for loglevel
        levelno             s           ?? should this be d?
        lineno              d           line in source file
        module              s           module portion of file name
        msecs               d           milliseconds for time
        message             s           the message
        msg                             msg % args
        name                s           name of original logger
        pathname            s           full path of source file
        process             s           pid of proc
        processName         s           name of proc
        relativeCreated     d           time relative to when logging was loaded into sys.modules
        thread              d           thread id
        threadName          s           name of thread


        
______________________________
-7- LoggerAdapters
    basically wrap a logger with some default kwargs
    that are added whenever log is called

    LoggerAdapter(baselogger, defaultKwargs)


______________________________
-8- thread safety
    is threadsafe, except when in signal handlers


______________________________
-9- module-level functions
    getLogger(name = 'root')

    getLoggerClass()

    debug(msg, *args, **kwargs)
    info
    warning
    error
    critical
    exception
    log(lvl, msg, *args, **kwargs)
        call root logger with corresponding value

        NOTE: if not already configured, these methods
        will call basicConfig first

    disable(lvl):
        disable all loglevels <= lvl

    addLevelName(lvl, name)
        name a loglevel

    getLevelName(lvl)
        curlvls = {lvl : name...}
        return curlvls.get(lvl, 'Level {}'.format(lvl))

    makeLogRecord(attrdict)

    basicConfig(**kwargs)
        configure root if not already configured
        
        kwargs:
            filename
            filemode
            format
            datefmt
            level
            stream

    shutdown()
        flush buffers etc
        no more calls should be made

    setLoggerClass(klass)
        set default logger class
        returned from getLogger(name)

    captureWarnings(doCapture):
        if True, catch warnings and log them
        otherwise, don't
