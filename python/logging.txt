https://docs.python.org/3/library/logging.html
https://docs.python.org/3/howto/logging.html#logging-basic-tutorial
https://docs.python.org/3/howto/logging.html#logging-advanced-tutorial
https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook

contents
-0- general
	-0.1- configs
-1- loggers
-2- handlers
-3- Formatters
-4- filters
-5- LogRecord
-6- LoggerAdapters
-7- module-level functions
______________________________
-0- general
	Components of logging:
		logrecords  : the actual log obj/message.
		loggers     : interface to log (emit log records)
		handlers    : log to certain destinations (do the writing)
		filters     : filter log outputs
		formatters  : layout

	______________________________
	Pseudocode:

	def log(self, level, message, args, kwargs)
		record = make_log_record(level, message, args, kwargs)
		if logRecord.level >= self.level:
			if all(filter.filter(record) for filter in self.filters):
				for handler in self.handlers:
					handler.handle(record)
				if self.propagate:
					self.parent.handle(record)
	def handle(self, record)
		if all(filt(record) for filt in self.filters):
			with self.lock:
				try:
					self.emit(record)
				except Exception:
					self.handleError(record)

	Loggers each have a dot-delimited name (ex. a.b.c), and pass
	logrecords to parent loggers if applicable.
	The recommendation is:
		logger = logging.getLogger(__name__)

	settings:
		logging.basicConfig(
			filename=...
			encoding=... (3.9+)
			level=...
			format=...
		)

	Logging is is threadsafe, (except when in signal handlers)

	______________________________
	-0.1- configs
		configure root if not already configured

		BasicConfig:
			kwargs:
				filename: creates FileHandler(filename) instead of StreamHandler(sys.stderr)
				filemode: mode for filename
				encoding: encoding for filename (3.9+)
				errors: used for FileHandler, how are encoding errors handled?
				        default: 'backslashreplace', (3.9+)

				handlers: seq of handlers for root logger (3.3+)

				stream: use StreamHandler

				format: default Formatter for handler
				datefmt: datefmt for formatter
				style: style for formatter (3.2+)
				level: root log level
				force: force reinitialization of root logger (3.8+)

		Set up logging with 3 choices:
			1. create everything explicitly
			2. create a config file: fileConfig() from a configparser-formatted file
			3. use a dict: dictConfig() from a dict

		questions:
			Are the () key and the class key synonyms?

		dictConfig:
			{
				version: 1, # hardcoded
				formatters: {
					name: {
						class: 'package.module.classname',
						(): 'package.module.factory', # Called with REMAINING KWARGS
						.: {attr:val...} # for k,v in this.items(): setattr(formatter,k,v)
						format: ...,
						datefmt: ...,
						style: ...,
						validate: ...,
						defaults: ...,
					},
					...
				},
				filters: {
					name: {constructor kwargs},
				},
				handlers: {
					name: {
						class: 'package.module.classname',
						level: int
						formatter: 'name of formatter in the "formatters" key',
						filters: ['name of filters in "filters" key']
						},
					...
				},
				loggers: {
					name: {
						level: int
						propagate: True/False
						filters: [filtername(s) in 'filters' key]
						handlers: [handlername(s) in 'handlers' key]
					},
					...
				},
				root: {constructor kwargs}
				incremental: True/False
					# 0. Ignore formatters and filters
					# 1. level settings in handlers
					# 2. level, + propagate in loggers/root
				disable_existing_loggers: True/False
			}

		References:
			NOTE: can also use [key] if key contains spaces
			'cfg://key.key...' can be used in handlers/filters, etc
			                   to refer to the corresponding location within the dict
			'ext://package.module.name' can be used to refer to external objects
			                            ex: ext://sys.stderr
______________________________
-1- loggers
	Loggers are identified with a .-delimited name, much like python packages.


	The root logger name is ''.  The module-level logging methods use the
	root logger.

	Child loggers inherit loglevel from parents by default.
	Logrecords are propgated to parents by default as well.

	common methods:
		debug|info|warning|error|critical()
		log(lvl, msg, *args, **kwargs):
		exception(msg, *args, **kwargs)

			Emits a logrecord with message set to `msg % args`.

			These use msg % args to format the log output.
			msg: str
			*args: args for formatstr OR a dict.
			**kwargs:
				exc_info     bool: add exc info to msg, use exception tuple or instance
				             if provided, else use sys.exc_info()
				stack_info   bool: add stack info
				stacklevel   stack level to use for computing position(file, lineno, etc), default 1
				             (the place where logger.logmethod() is called)
				extra        Additional attributes for the LogRecord as if
				             logrecord.__dict__.update(extra).  These are available for use to
				             the format string, (but not the message).
				
			exception:
				does the same, but also adds traceback.format_exc()
				to the end of the logrecord.

		setLevel(lvl: int|str)
			if str, then corresponds to generic logging.loglevel constants:
				logging.NOTSET      0
				logging.DEBUG       10
				logging.INFO        20
				logging.WARNING     30
				logging.ERROR       40
				logging.CRITICAL    50

		[add|remove]Handler|Filter](...)
			add/remove corresponding handler/filter

	attrs:
		name        readonly logger name
		level       log level (setLevel)
		parent      readonly parent logger
		propagate   propagate to parent loggers (directly to handlers).
		            ex: if A.B has level INFO, A has level ERROR,
		            A.info(stuff) would not be logged.
		            A.B.info(stuff) WOULD be logged, AND THEN ALSO
		            propagated to A's handlers EVEN THOUGH A has level
		            ERROR.
		handlers    readonly list of handlers(use [add|remove]Handler() to modify)
		disabled    readonly

	others:
		filter(record):
			Apply filters to record.  True if all filters pass (return truthy).
		isEnabledFor(lvl: int)
			Return if lvl >= getEffectiveLevel()
		getEffectiveLevel()->int
			logger.level or search parents if NOTSET
		getChild(suffix: str)->Logger (3.2+)
		getChildren() (3.12+)
		findCaller(stack_info=False, stackLevel=1)
			Find the stack info (fname, lineno, funcname, stackinfo if stack_info else None)
		handle(record):
			handle the record
		makeRecord(name, level, fn, lno, msg, args, exc_info, func, extra, sinfo)
			Make a LogRecord
		hasHandlers() (3.2+)
			Also searches parents for handlers
______________________________
-2- handlers
	Handlers handle the LogRecord (ex. write or send it somewhere)

	common methods:
		setLevel(level: int|str(3.2+))
		setFormatter(fmt):
			a Formatter or None
			NOTE: handlers do not take formatters via __init__.
			      You must call setFormatter separately.
		[add|remove]Filter(filter):

	subclasses should override and call:
		__init__ set level, initialize filters, creates a lock.
		close() remove handler from internal handlers map.
		flush() no-op
		emit(): NotImplementedError
			NOTE: because emit() is called while locked, any use of locks
			      may cause deadlock.  Try to avoid any logging api calls
			      while inside emit().


	other methods:
		filter(record): return whether record passes all filters.
		createLock(): sets self.lock to a new lock.
		acquire()
		release()
		handle(record):
		handleError(record)
		format(record)

	best practices:
		do not add handlers in libraries, only in clients.
		(otherwise, clients can't really control log handling.)
		can add a NullHandler though to not print if no configuration.

	______________________________
	-2.1- builtin handlers
		logging:
			StreamHandler(stream=None)
				Emit LogRecords to the given stream.
				NOTE: close() does not close the given stream.
				attributes:
					terminator: (3.2+)

			FileHandler(fname, mode='a', encoding=None, delay=False, errors=None)
				like StreamHandler(open(fname, mode, encoding=encoding, errors=errors))
				except also close the file when close() is called
				delay: bool, delay opening the file until the first write.

			NullHandler (3.1+)

		logging.handlers:
			BaseRotatingHandler
			RotatingFileHandler(fname, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False, errors=None)
				Rotate based on size.
				Both maxBytes and backupCount must be non-zero for rotation.
				This renames backups accordingly and then creates a new file.
			TimedRotatingFileHandler(fname, when='SMHD|W0-W6|midnight', interval, backupCount, encoding, delay, utc, atTime, errors)
				Rotate based on time and size, whichever is first
				when:
					W0 = monday
				Extensions will be a datetime string.
			SocketHandler(host, port)
				Sends pickled LogRecord to host:port. (TCP)
			DatagramHandler
				Sends pickled LogRecord to host:port. (UDP)
			SysLogHandler(address=(host, port), facility=LOG_USER, socktype=dgram, timeout=None)
				?send to a syslog?
			SMTPHandler
				email
			NTEventLogHandler
				Send to Windows NT event log
			MemoryHandler(capacity, flushLevel=Error, target=None, flushOnClose=True)
				Buffer in memory, flush to handler when accumulated or severe LogRecord.
			HTTPHandler(host, url, method='GET', secure=False, credentials=None, context=None)
				Send http to server with get or post
				context: ssl.SSLContext
				credentials: 2-tuple of userid, password
				             placed into Authorization header with BasicAuth
				             (should use secure=True to encrypt user/password etc)
				Sends attrs as url-encoded dictionary
				host:port?key=value&key=value...
			WatchedFileHandler
				Same as FiileHandler except watch for file changes between emit()s
				ex. if the file was moved (log rotation etc), then reopen it.
			QueueHandler (3.2+)
				queue.push(logRecord)
			QueueListener(queue, handlers, respect_handler_level=False)
				Consume messages from the given queue
				start(): starts listener in background
				stop(): stop the listener

______________________________
-3- Formatters
	__init__(fmt='%(message)s', datefmt='%Y-%m-%d %H:%M:%S,uuu', style='%', validate=True, defaults=None)
		Convert a LogRecord to an output string.
		fmt: str, format string using LogRecord's attrs as keys.
		datefmt: str, default to formatTime()
		style: (3.2+)
			%: %(<dictkey>)fmtcode (default) (ex: %(level)03d) etc
			{: {<dictkey>:formatopts}
			$: string.Template.substitute()?
		validate (3.8+): bool
			mismatched fmt and style raise ValueError
		defaults (3.10+): dict/str
			default values for LogRecord custom fields.

	format(record):
		pseudocode
			if '(asctime)' in record:
				record.asctime = formatTime()
			parts = [record.msg % record.__dict__]
			if exc_info:
				parts.append(formatException())
			if traceback:
				parts.append(formatStack())
			return '\n'.join(parts)

			sidenote: exc_text caches the exception formatting. Set it to None
			          if other formatters for the LogRecord might have different exc formatting.

	formatTime(record, datefmt=None)
		asctime is calculated as follows:
			default_msec_format % time.strftime(default_time_format), msecs

		where default_msec_format is only available py3.3+
		and before, it is hard coded as '%s,%03d'.

	formatException(exc_info)
		traceback.format_exc()

	formatStack(stack_info)
		traceback.format_stack()

	attrs:
		converter(tstamp) -> timetuple
			example choices:
				time.localtime()
				time.gmtime()
				lambda x: datetime.datetime.fromtimestamp(x).timetuple()


	Builtin alternative formatter:
		BufferingFormatter(linefmt=None)
			Buffers LogRecords to process together.

			formatHeader(records)
				string in before format(records)
			formatFooter(records)
				string after format(records)
			format(records)
				return ''.join((formatHeader(records), *map(linefmt.format, records), formatFooter(records))

______________________________
-4- filters
	default class:
		logging.Filter(name='')

		filter(record):
			return (
				record.name.startswith(self.name + '.')
				or record.name == self.name)
			NOTE: mutating record is allowed

	3.2+: filter can also be a callable()
	3.12+: Returning a LogRecord instance will replace
	       the input logrecord (allow filters to modify
	       LogRecord before emitted if attached to a handler)

______________________________
-5- LogRecord
	A log message.
	LogRecord subclasses can override getMessage() to allow different formatting.
	(still should call str(self.msg))

	logging.makeLogRecord(attrdict)
		LogRecord(name, level, pathname, lineno, msg, args, exc_info, func)
				name: original logger
				level: loglevel
				pathname: sourcefile path name
				lineno: line in sourcefile
				msg: message
				args: args for formatting msg
				exc_info: exception info (sys.exc_info()) or None
				func: name of func containing the original call
				sinfo: text string of stack info

		getMessage()
				return formatted msg

		attributes: (available for formatters)
				name                code        description
				args
				asctime             s           formatted time
				created             f           unix timestamp
				exc_info
				exc_text
				filename            s           filename of pathname
				funcName            s           name of func that called log
				levelname           s           name for loglevel
				levelno             s           loglevel number. ?should this be d?
				lineno              d           line in source file
				message             s           the message (formatter.format()ed)
				module              s           module portion of file name
				msecs               d           milliseconds for time
				msg                             msg % args
				name                s           name of original logger
				pathname            s           full path of source file
				process             s           pid of proc
				processName         s           name of proc
				relativeCreated     d           time relative to when logging was loaded into sys.modules
				stack_info
				thread              d           thread id
				threadName          s           name of thread
				taskName            s           asyncio.Task name

______________________________
-6- LoggerAdapters
		basically wrap a logger with some default kwargs
		that are added whenever log is called

		LoggerAdapter(baselogger, defaultKwargs)

______________________________
-7- module-level functions
	getLogger(name='')

	getLoggerClass()
	getLogRecordFactory()
	setLoggerClass(klass)
	setLogRecordFactory(factory)

	debug|info|warning|error|critical|exception|log(...)
		same as logger.name, except for root logger.

	disable(lvl):
		system-wide overriding loglevel
		All loggers act as if logger.level = max(logger.level, lvl+1)
		(lvl is included in being disabled)

	addLevelName(lvl, name)
		name a loglevel
	getLevelName(lvl)
		curlvls = {lvl : name...}
		return curlvls.get(lvl, 'Level {}'.format(lvl))
	getLevelNamesMapping()

	getHandlerByName(name)
		3.12
	getHandlerNames()
		3.12

	makeLogRecord(attrdict)

	basicConfig(**kwargs)
		see:
		-0.1- configs

	shutdown()
		flush and close all handlers.
		Call this at application exit.
		On import, this is registered via atexit()
		usually no need for explicitly calling this


	captureWarnings(doCapture):
		if True, catch warnings and log them
		otherwise, don't

	lastResort: Handler|None
		Used if no other handlers exist.
	raiseException: bool
		logging errors are raised instead of ignored.
