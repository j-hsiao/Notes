------------------------------
contents
------------------------------
-1- spec
-2- basics
-3- rebase
-4- history
-5- alias
-6- miscellaneous
	-6.1- line endings
	-6.2- gitignore
-7- usage notes
-8- authorization
-9- config


------------------------------
-1-spec
------------------------------
______________________________
pathspecs
    rules
        paths match itself
        scope is limited to directory up to the last slash
        rest of pathspec = for pattern matching


        examples:
            d1/*.jpg
                any .jpg under d1 directory tree
                including:
                    d1/im1.jpg
                    d1/d2/im2.jpg

        magic signature
            short:
                :sig:pathmatcher
            long:
                :(magic,words,comma,delimited)pathmatcher

            ______________________________
            terms:
                top      (/), pathspec is from top of git tree
                exclude  (^ or !), ignore paths
                literal  treat * and ? as literal
                icase    case insensitive


        notes:
            generally can add -- to delimit the start of pathspecs
______________________________
refspecs
    format:
        [+]<src>:<dst>
        
        +: update even if not fast-forward
        src: source file
        dst: local file path
    example:
        git push origin master:refs/heads/master
            push local master to origin master

        git push origin :refs/heads/master
            push nothing (delete) origin master

______________________________
other
    tags:
        refs/tags/<tagname>
    heads:
        refs/heads/<headname>

    relative:
      HEAD~n  (go back n commits)
      HEAD^n  (go to nth parent (if merge, multiple parents))




------------------------------
-2- basics
------------------------------
  clone a repo
      git clone uri

  add
      git add <files>

  commit
      git commit -m 'message'

      git commit --fixup <commit>
        fix the commit and keep its message
      git commit --squash <commit>
        merge commits into a single commit and specify final message after merge with rebase -i

      protip:
        use HEAD for commit

  checkout
      git checkout [branchname]
          checkout branch from repo (use git branch -a to see repo branches too)
      git checkout -b [newbranch]
          create/checkout branch
      git checkout [branchname] -- [path-to-filename]
          checkout file

  branch
      git branch -a:
          display all branches
      git branch -d [name]
          delete branch
      
  diff
      git diff -- [path-to-file]
          difference between file current and since last stage
          (so git reset if want to see dif since last commit)
      git diff --cached [commit] [--] [path]
          diff between staged changes for next commit and [commit] (defaults to head)
      git diff commit -- path
          dif between cur state and commit (not staged necessarily)
      git diff commit commit -- path
          dif between path for the two commits

  reflog:
      shows hashes for previous commits/checkouts etc

  reset:
      (reset current branch (if applicable) to the ref)
      NOTE: reflog may still point to commits so will not be able to prune
      git reset --hard 'hash/string_thing'
          reset all files to state from corresponding commit (delete files too)
      git reset
          unstage commits (keep files the same)

  pull changes from repo (fetch & merge)
      git pull [remote] [local]
      
  push changes to repo
      git push [remote] [local]

  tags:
      creation:
        git tag -a <tagname> -m 'tag message/description'
        (add -f to change tag commit if already exist)
      deletion:
        local:
          git tag -d <tagname>
        remote:
          git push origin :tagname
          git push origin :refs/tags/tagname
          git push origin --delete <tagname>
      display:
        git tag
        git tag -n
      pull tags:
        git fetch --tags
      push tags:
        git push origin --tags
        git push origin <tagname>


------------------------------
-3- rebase
------------------------------
  "reapply commits on top of another base tip"

  git rebase [--onto commit] <upstream> [branch]

    branch: git checkout branch if given before rebase
    upstream: indicate the commits to transplant (from HEAD to intersection with upstream, does not the intersection)

      example:
        if upstream == HEAD~2, then this indicates HEAD~1 and HEAD


    onto: location to plop commits onto (defaults to upstream)



  example:
    first-----a-----b-------c master
     \
      d-----e feature

    git checkout feature
    git rebase master

    first-----a-----b-------c master
                             \
                              d-----e feature

  if conflict, can git rebase --abort to cancel rebase

  interactive rebase
    pick commits to rebase and fixup, squash, or pick

------------------------------
-4- history
------------------------------
  git reflog: history of what actually happened
              (includes reset, rebase, etc)

      expire: expire reflog entries (dangling commits will then be able to be pruned)
        --expire-unreachable=<time> 
        --expire=<time>
          (can use "now" for time)

        --all
          (dunno bout this, but need this to cause reflogs to dangling commits to be removed)

  git log: history of the path to HEAD

  git log --all --decorate --oneline --graph
    (adog)

------------------------------
-5- alias
------------------------------

git config [--global | --local] alias.<aliascommand> "command and args"

example:
  git config --local alias.graph "log --all --decorate --oneline --graph"
  git config --local --unset alias.graph

------------------------------
-6- miscellaneous
------------------------------
	-6.1- line endings
		global:
			git config core.autocrlf
		per repo:
			.gitattributes file
		by file:
			.git/info/attributes

			pattern attr attr attr...
			attr:
				attrname: set the attr
				-attrname: unset the attr
				attrname=val: set to value
				unspecified: not specified... (no matches or not in .gitattributes)

			later lines override previous lines
			must be in repo root (but newer versions maybe not?)
			example:
				* text=auto
				*.c text
				*.h text
				*.sln text eol=crlf
				*.sh text eol=lf
				*.png binary
				*.jpg binary

	-6.2- gitignore
		.gitignore file per directory: all users will ignore
		.git/info/exclude: exclude only for this checked-out repo
		ignores matched files

		#: comment (can escape with \)
		trailing spaces can be escaped with \ else ignored
		! : negates pattern
		/ at beginning or middle, then it is relative
		otherwise, matches anything in subdirectories as well
		end with /: directories only
		*: anything except /
		?: any single char ecxept /
		[a-zA-Z] single char in range
		**:
			**/: in all directories
			/**: everything inside dir (infinite depth)
			a/**/b: any b under some ancestor a

------------------------------
-7- usage notes
------------------------------
usage method one:

features:

  master     a-b-c          h
                   \       / \
  feature 1         d-e-f-g  feature2 ...
                          |
                       deleted
  code:
    git init
    git checkout -b feature1
    ...work on feature1...
    git checkout master
    git merge --squash feature1
    git branch -d feature1
    git checkout -b feature2
    ...work on feature2...


dev branch
  master     a         f
              \       / \
  dev          b c d e   g

  code:
    git init
    git checkout -b dev
    ...work on dev...
    git checkout master
    git merge dev --squash??
    git checkout dev
    git merge master
    ...continue working on dev...


features: useful for cleaner history
dev: separte from master features/versions
  ...although...
  can just git tag instead of have master branch with only versions...
  (in other words, dev branch is useless?)
git tags = your "main" branch with only fully functioning versions

overall usage probably like this:
master: version X.X...
  squash merge dev branch followed by merge master back into dev to sync the branches
dev: branch off "feature" branches
  feature branches get merged (squash? maybe maybe not) into dev
  delete (or maybe not?) the feature branch

saw a note that seems agreeable:
  if release are always chronological, master branch is fine
  if not, (ie 1.0.1 can come after 1.1.0), then tagging may be a better approach
  or maybe separate release branches per version...
------------------------------
-8- authorization
------------------------------
git and bitbucket do not allow username/password anymore:
  bitbucket:
    OAuth2: see bboauth.py for bitbucket oauth method.
    app password:
      go to personal settings, app passwords
      create an app password (only shown 1 time, select permissions, etc)
      when using app password, use the username, NOT EMAIL
      username is under general->account settings
  git: create a token and use that as password instead

------------------------------
-9- config
------------------------------
general usage:
git config [--system | --global | --local] [-e | [--unset] <name> [value] | --list ]
  system: all repos for all users
  global: all repos for (current user only) (${HOME}/.gitconfig)
  local: current repo only

  use the settings from the most specific scope

  -e: edit the config file
  --unset: remove the variable
  --list: list all variables in the config file for corresponding scope
  <name>: print the current value
  <name> <value>: set the current value

  list all possible config keys:
    git help [--config|-c]

  useful settings:
    core.attributesFile
      path to global gitattributes file
    core.autocrlf:
      auto conversion between crlf and lf on windows (always lf on unix)
    core.safecrlf:
      checks that conversion between crlf/lf is reversible (if file has both
      then not reversible)
    credential.helper
      name is "credential-<name>"
      git config value is just <name>
      list all helpers installed:
        git help -a | grep credential-
      builtin helpers:
        cache: cache for short period of time
        store: store forever
        manager-core: opensource builtin to git for windows
